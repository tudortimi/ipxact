# ./raw/ipxact.py
# -*- coding: utf-8 -*-
# PyXB bindings for NM:55b012395bb7324482553a00707a2638eda11d61
# Generated 2016-06-23 18:05:09.194549 by PyXB version 1.2.4 using Python 2.7.10.final.0
# Namespace http://www.accellera.org/XMLSchema/IPXACT/1685-2014

from __future__ import unicode_literals
import pyxb
import pyxb.binding
import pyxb.binding.saxer
import io
import pyxb.utils.utility
import pyxb.utils.domutils
import sys
import pyxb.utils.six as _six

# Unique identifier for bindings created at the same time
_GenerationUID = pyxb.utils.utility.UniqueIdentifier('urn:uuid:d9a86364-3953-11e6-80da-560f6efe5e31')

# Version of PyXB used to generate the bindings
_PyXBVersion = '1.2.4'
# Generated bindings are not compatible across PyXB versions
if pyxb.__version__ != _PyXBVersion:
    raise pyxb.PyXBVersionError(_PyXBVersion)

# Import bindings for namespaces imported into schema
import pyxb.binding.xml_
import pyxb.binding.datatypes

# NOTE: All namespace declarations are reserved within the binding
Namespace = pyxb.namespace.NamespaceForURI('http://www.accellera.org/XMLSchema/IPXACT/1685-2014', create_if_missing=True)
Namespace.configureCategories(['typeBinding', 'elementBinding'])

def CreateFromDocument (xml_text, default_namespace=None, location_base=None):
    """Parse the given XML and use the document element to create a
    Python instance.

    @param xml_text An XML document.  This should be data (Python 2
    str or Python 3 bytes), or a text (Python 2 unicode or Python 3
    str) in the L{pyxb._InputEncoding} encoding.

    @keyword default_namespace The L{pyxb.Namespace} instance to use as the
    default namespace where there is no default namespace in scope.
    If unspecified or C{None}, the namespace of the module containing
    this function will be used.

    @keyword location_base: An object to be recorded as the base of all
    L{pyxb.utils.utility.Location} instances associated with events and
    objects handled by the parser.  You might pass the URI from which
    the document was obtained.
    """

    if pyxb.XMLStyle_saxer != pyxb._XMLStyle:
        dom = pyxb.utils.domutils.StringToDOM(xml_text)
        return CreateFromDOM(dom.documentElement, default_namespace=default_namespace)
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    saxer = pyxb.binding.saxer.make_parser(fallback_namespace=default_namespace, location_base=location_base)
    handler = saxer.getContentHandler()
    xmld = xml_text
    if isinstance(xmld, _six.text_type):
        xmld = xmld.encode(pyxb._InputEncoding)
    saxer.parse(io.BytesIO(xmld))
    instance = handler.rootObject()
    return instance

def CreateFromDOM (node, default_namespace=None):
    """Create a Python instance from the given DOM node.
    The node tag must correspond to an element declaration in this module.

    @deprecated: Forcing use of DOM interface is unnecessary; use L{CreateFromDocument}."""
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    return pyxb.binding.basis.element.AnyCreateFromDOM(node, default_namespace)


# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}presenceType
class presenceType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'presenceType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 56, 1)
    _Documentation = None
presenceType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=presenceType, enum_prefix=None)
presenceType.required = presenceType._CF_enumeration.addEnumeration(unicode_value='required', tag='required')
presenceType.illegal = presenceType._CF_enumeration.addEnumeration(unicode_value='illegal', tag='illegal')
presenceType.optional = presenceType._CF_enumeration.addEnumeration(unicode_value='optional', tag='optional')
presenceType._InitializeFacetMap(presenceType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'presenceType', presenceType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}direction
class direction (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'direction')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 63, 1)
    _Documentation = None
direction._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=direction, enum_prefix=None)
direction.in_ = direction._CF_enumeration.addEnumeration(unicode_value='in', tag='in_')
direction.out = direction._CF_enumeration.addEnumeration(unicode_value='out', tag='out')
direction.inout = direction._CF_enumeration.addEnumeration(unicode_value='inout', tag='inout')
direction._InitializeFacetMap(direction._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'direction', direction)

# Atomic simple type: [anonymous]
class STD_ANON (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 88, 4)
    _Documentation = None
STD_ANON._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON, enum_prefix=None)
STD_ANON.requires = STD_ANON._CF_enumeration.addEnumeration(unicode_value='requires', tag='requires')
STD_ANON.provides = STD_ANON._CF_enumeration.addEnumeration(unicode_value='provides', tag='provides')
STD_ANON.both = STD_ANON._CF_enumeration.addEnumeration(unicode_value='both', tag='both')
STD_ANON._InitializeFacetMap(STD_ANON._CF_enumeration)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractorModeType
class abstractorModeType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Mode for this abstractor"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'abstractorModeType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 175, 1)
    _Documentation = 'Mode for this abstractor'
abstractorModeType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=abstractorModeType, enum_prefix=None)
abstractorModeType.master = abstractorModeType._CF_enumeration.addEnumeration(unicode_value='master', tag='master')
abstractorModeType.slave = abstractorModeType._CF_enumeration.addEnumeration(unicode_value='slave', tag='slave')
abstractorModeType.direct = abstractorModeType._CF_enumeration.addEnumeration(unicode_value='direct', tag='direct')
abstractorModeType.system = abstractorModeType._CF_enumeration.addEnumeration(unicode_value='system', tag='system')
abstractorModeType._InitializeFacetMap(abstractorModeType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'abstractorModeType', abstractorModeType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}formatType
class formatType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """This is an indication on the format of the value. bit: 1-bit or more (vector) bits unsigned integer, byte: 8-bit signed integer, shortint: 16-bit signed integer, int: 32-bit signed integer, longint: 64-bit signed integer, shortreal: 32-bit signed floating point number, real: 64-bit signed floating point number, string: textual information."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'formatType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 53, 1)
    _Documentation = 'This is an indication on the format of the value. bit: 1-bit or more (vector) bits unsigned integer, byte: 8-bit signed integer, shortint: 16-bit signed integer, int: 32-bit signed integer, longint: 64-bit signed integer, shortreal: 32-bit signed floating point number, real: 64-bit signed floating point number, string: textual information.'
formatType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=formatType, enum_prefix=None)
formatType.bit = formatType._CF_enumeration.addEnumeration(unicode_value='bit', tag='bit')
formatType.byte = formatType._CF_enumeration.addEnumeration(unicode_value='byte', tag='byte')
formatType.shortint = formatType._CF_enumeration.addEnumeration(unicode_value='shortint', tag='shortint')
formatType.int = formatType._CF_enumeration.addEnumeration(unicode_value='int', tag='int')
formatType.longint = formatType._CF_enumeration.addEnumeration(unicode_value='longint', tag='longint')
formatType.shortreal = formatType._CF_enumeration.addEnumeration(unicode_value='shortreal', tag='shortreal')
formatType.real = formatType._CF_enumeration.addEnumeration(unicode_value='real', tag='real')
formatType.string = formatType._CF_enumeration.addEnumeration(unicode_value='string', tag='string')
formatType._InitializeFacetMap(formatType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'formatType', formatType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}signType
class signType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """This is an indication of the signedness of the value."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'signType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 68, 1)
    _Documentation = 'This is an indication of the signedness of the value.'
signType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=signType, enum_prefix=None)
signType.signed = signType._CF_enumeration.addEnumeration(unicode_value='signed', tag='signed')
signType.unsigned = signType._CF_enumeration.addEnumeration(unicode_value='unsigned', tag='unsigned')
signType._InitializeFacetMap(signType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'signType', signType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}delayValueUnitType
class delayValueUnitType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """Indicates legal units for delay values."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'delayValueUnitType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 77, 2)
    _Documentation = 'Indicates legal units for delay values.'
delayValueUnitType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=delayValueUnitType, enum_prefix=None)
delayValueUnitType.ps = delayValueUnitType._CF_enumeration.addEnumeration(unicode_value='ps', tag='ps')
delayValueUnitType.ns = delayValueUnitType._CF_enumeration.addEnumeration(unicode_value='ns', tag='ns')
delayValueUnitType._InitializeFacetMap(delayValueUnitType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'delayValueUnitType', delayValueUnitType)

# Atomic simple type: [anonymous]
class STD_ANON_ (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 77, 5)
    _Documentation = None
STD_ANON_._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_, enum_prefix=None)
STD_ANON_.on = STD_ANON_._CF_enumeration.addEnumeration(unicode_value='on', tag='on')
STD_ANON_.off = STD_ANON_._CF_enumeration.addEnumeration(unicode_value='off', tag='off')
STD_ANON_._InitializeFacetMap(STD_ANON_._CF_enumeration)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}endianessType
class endianessType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """'big': means the most significant element of any multi-element  data field is stored at the lowest memory address. 'little' means the least significant element of any multi-element data field is stored at the lowest memory address. If this element is not present the default is 'little' endian."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'endianessType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 87, 1)
    _Documentation = "'big': means the most significant element of any multi-element  data field is stored at the lowest memory address. 'little' means the least significant element of any multi-element data field is stored at the lowest memory address. If this element is not present the default is 'little' endian."
endianessType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=endianessType, enum_prefix=None)
endianessType.big = endianessType._CF_enumeration.addEnumeration(unicode_value='big', tag='big')
endianessType.little = endianessType._CF_enumeration.addEnumeration(unicode_value='little', tag='little')
endianessType._InitializeFacetMap(endianessType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'endianessType', endianessType)

# Atomic simple type: [anonymous]
class STD_ANON_2 (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 401, 6)
    _Documentation = None
STD_ANON_2._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_2, enum_prefix=None)
STD_ANON_2.master = STD_ANON_2._CF_enumeration.addEnumeration(unicode_value='master', tag='master')
STD_ANON_2.slave = STD_ANON_2._CF_enumeration.addEnumeration(unicode_value='slave', tag='slave')
STD_ANON_2.system = STD_ANON_2._CF_enumeration.addEnumeration(unicode_value='system', tag='system')
STD_ANON_2.mirroredMaster = STD_ANON_2._CF_enumeration.addEnumeration(unicode_value='mirroredMaster', tag='mirroredMaster')
STD_ANON_2.mirroredSlave = STD_ANON_2._CF_enumeration.addEnumeration(unicode_value='mirroredSlave', tag='mirroredSlave')
STD_ANON_2.mirroredSystem = STD_ANON_2._CF_enumeration.addEnumeration(unicode_value='mirroredSystem', tag='mirroredSystem')
STD_ANON_2._InitializeFacetMap(STD_ANON_2._CF_enumeration)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}ipxactFileTypesEnum
class ipxactFileTypesEnum (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ipxactFileTypesEnum')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 65, 1)
    _Documentation = None
ipxactFileTypesEnum._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=ipxactFileTypesEnum, enum_prefix=None)
ipxactFileTypesEnum.busDefinition = ipxactFileTypesEnum._CF_enumeration.addEnumeration(unicode_value='busDefinition', tag='busDefinition')
ipxactFileTypesEnum.abstractionDefinition = ipxactFileTypesEnum._CF_enumeration.addEnumeration(unicode_value='abstractionDefinition', tag='abstractionDefinition')
ipxactFileTypesEnum.component = ipxactFileTypesEnum._CF_enumeration.addEnumeration(unicode_value='component', tag='component')
ipxactFileTypesEnum.abstractor = ipxactFileTypesEnum._CF_enumeration.addEnumeration(unicode_value='abstractor', tag='abstractor')
ipxactFileTypesEnum.design = ipxactFileTypesEnum._CF_enumeration.addEnumeration(unicode_value='design', tag='design')
ipxactFileTypesEnum.designConfig = ipxactFileTypesEnum._CF_enumeration.addEnumeration(unicode_value='designConfig', tag='designConfig')
ipxactFileTypesEnum.generatorChain = ipxactFileTypesEnum._CF_enumeration.addEnumeration(unicode_value='generatorChain', tag='generatorChain')
ipxactFileTypesEnum.catalog = ipxactFileTypesEnum._CF_enumeration.addEnumeration(unicode_value='catalog', tag='catalog')
ipxactFileTypesEnum._InitializeFacetMap(ipxactFileTypesEnum._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'ipxactFileTypesEnum', ipxactFileTypesEnum)

# Atomic simple type: [anonymous]
class STD_ANON_3 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 71, 5)
    _Documentation = None
STD_ANON_3._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_3, enum_prefix=None)
STD_ANON_3.nontyped = STD_ANON_3._CF_enumeration.addEnumeration(unicode_value='nontyped', tag='nontyped')
STD_ANON_3.typed = STD_ANON_3._CF_enumeration.addEnumeration(unicode_value='typed', tag='typed')
STD_ANON_3._InitializeFacetMap(STD_ANON_3._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_4 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 435, 3)
    _Documentation = None
STD_ANON_4._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_4, enum_prefix=None)
STD_ANON_4.deca = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='deca', tag='deca')
STD_ANON_4.hecto = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='hecto', tag='hecto')
STD_ANON_4.kilo = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='kilo', tag='kilo')
STD_ANON_4.mega = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='mega', tag='mega')
STD_ANON_4.giga = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='giga', tag='giga')
STD_ANON_4.tera = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='tera', tag='tera')
STD_ANON_4.peta = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='peta', tag='peta')
STD_ANON_4.exa = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='exa', tag='exa')
STD_ANON_4.zetta = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='zetta', tag='zetta')
STD_ANON_4.yotta = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='yotta', tag='yotta')
STD_ANON_4.deci = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='deci', tag='deci')
STD_ANON_4.centi = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='centi', tag='centi')
STD_ANON_4.milli = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='milli', tag='milli')
STD_ANON_4.micro = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='micro', tag='micro')
STD_ANON_4.nano = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='nano', tag='nano')
STD_ANON_4.pico = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='pico', tag='pico')
STD_ANON_4.femto = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='femto', tag='femto')
STD_ANON_4.atto = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='atto', tag='atto')
STD_ANON_4.zepto = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='zepto', tag='zepto')
STD_ANON_4.yocto = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='yocto', tag='yocto')
STD_ANON_4._InitializeFacetMap(STD_ANON_4._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_5 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 464, 3)
    _Documentation = None
STD_ANON_5._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_5, enum_prefix=None)
STD_ANON_5.second = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='second', tag='second')
STD_ANON_5.ampere = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='ampere', tag='ampere')
STD_ANON_5.kelvin = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='kelvin', tag='kelvin')
STD_ANON_5.hertz = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='hertz', tag='hertz')
STD_ANON_5.joule = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='joule', tag='joule')
STD_ANON_5.watt = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='watt', tag='watt')
STD_ANON_5.coulomb = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='coulomb', tag='coulomb')
STD_ANON_5.volt = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='volt', tag='volt')
STD_ANON_5.farad = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='farad', tag='farad')
STD_ANON_5.ohm = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='ohm', tag='ohm')
STD_ANON_5.siemens = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='siemens', tag='siemens')
STD_ANON_5.henry = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='henry', tag='henry')
STD_ANON_5.Celsius = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='Celsius', tag='Celsius')
STD_ANON_5._InitializeFacetMap(STD_ANON_5._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_6 (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """Determines how a parameter is resolved. User means the value must be obtained from the user. Generated means the value will be provided by a generator."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 491, 5)
    _Documentation = 'Determines how a parameter is resolved. User means the value must be obtained from the user. Generated means the value will be provided by a generator.'
STD_ANON_6._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_6, enum_prefix=None)
STD_ANON_6.immediate = STD_ANON_6._CF_enumeration.addEnumeration(unicode_value='immediate', tag='immediate')
STD_ANON_6.user = STD_ANON_6._CF_enumeration.addEnumeration(unicode_value='user', tag='user')
STD_ANON_6.generated = STD_ANON_6._CF_enumeration.addEnumeration(unicode_value='generated', tag='generated')
STD_ANON_6._InitializeFacetMap(STD_ANON_6._CF_enumeration)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}simpleWhiteboxType
class simpleWhiteboxType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'simpleWhiteboxType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 310, 1)
    _Documentation = None
simpleWhiteboxType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=simpleWhiteboxType, enum_prefix=None)
simpleWhiteboxType.signal = simpleWhiteboxType._CF_enumeration.addEnumeration(unicode_value='signal', tag='signal')
simpleWhiteboxType.pin = simpleWhiteboxType._CF_enumeration.addEnumeration(unicode_value='pin', tag='pin')
simpleWhiteboxType.interface = simpleWhiteboxType._CF_enumeration.addEnumeration(unicode_value='interface', tag='interface')
simpleWhiteboxType._InitializeFacetMap(simpleWhiteboxType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'simpleWhiteboxType', simpleWhiteboxType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}cellFunctionValueType
class cellFunctionValueType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """Indicates legal cell function values."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'cellFunctionValueType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 54, 4)
    _Documentation = 'Indicates legal cell function values.'
cellFunctionValueType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=cellFunctionValueType, enum_prefix=None)
cellFunctionValueType.nand2 = cellFunctionValueType._CF_enumeration.addEnumeration(unicode_value='nand2', tag='nand2')
cellFunctionValueType.buf = cellFunctionValueType._CF_enumeration.addEnumeration(unicode_value='buf', tag='buf')
cellFunctionValueType.inv = cellFunctionValueType._CF_enumeration.addEnumeration(unicode_value='inv', tag='inv')
cellFunctionValueType.mux21 = cellFunctionValueType._CF_enumeration.addEnumeration(unicode_value='mux21', tag='mux21')
cellFunctionValueType.dff = cellFunctionValueType._CF_enumeration.addEnumeration(unicode_value='dff', tag='dff')
cellFunctionValueType.latch = cellFunctionValueType._CF_enumeration.addEnumeration(unicode_value='latch', tag='latch')
cellFunctionValueType.xor2 = cellFunctionValueType._CF_enumeration.addEnumeration(unicode_value='xor2', tag='xor2')
cellFunctionValueType.other = cellFunctionValueType._CF_enumeration.addEnumeration(unicode_value='other', tag='other')
cellFunctionValueType._InitializeFacetMap(cellFunctionValueType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'cellFunctionValueType', cellFunctionValueType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}cellClassValueType
class cellClassValueType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """Indicates legal cell class values."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'cellClassValueType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 70, 4)
    _Documentation = 'Indicates legal cell class values.'
cellClassValueType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=cellClassValueType, enum_prefix=None)
cellClassValueType.combinational = cellClassValueType._CF_enumeration.addEnumeration(unicode_value='combinational', tag='combinational')
cellClassValueType.sequential = cellClassValueType._CF_enumeration.addEnumeration(unicode_value='sequential', tag='sequential')
cellClassValueType._InitializeFacetMap(cellClassValueType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'cellClassValueType', cellClassValueType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}cellStrengthValueType
class cellStrengthValueType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """Indicates legal cell strength values."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'cellStrengthValueType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 80, 4)
    _Documentation = 'Indicates legal cell strength values.'
cellStrengthValueType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=cellStrengthValueType, enum_prefix=None)
cellStrengthValueType.low = cellStrengthValueType._CF_enumeration.addEnumeration(unicode_value='low', tag='low')
cellStrengthValueType.median = cellStrengthValueType._CF_enumeration.addEnumeration(unicode_value='median', tag='median')
cellStrengthValueType.high = cellStrengthValueType._CF_enumeration.addEnumeration(unicode_value='high', tag='high')
cellStrengthValueType._InitializeFacetMap(cellStrengthValueType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'cellStrengthValueType', cellStrengthValueType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}edgeValueType
class edgeValueType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """Indicates legal values for edge specification attributes."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'edgeValueType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 91, 4)
    _Documentation = 'Indicates legal values for edge specification attributes.'
edgeValueType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=edgeValueType, enum_prefix=None)
edgeValueType.rise = edgeValueType._CF_enumeration.addEnumeration(unicode_value='rise', tag='rise')
edgeValueType.fall = edgeValueType._CF_enumeration.addEnumeration(unicode_value='fall', tag='fall')
edgeValueType._InitializeFacetMap(edgeValueType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'edgeValueType', edgeValueType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}delayValueType
class delayValueType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """Indicates the type of delay value - minimum or maximum delay."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'delayValueType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 101, 4)
    _Documentation = 'Indicates the type of delay value - minimum or maximum delay.'
delayValueType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=delayValueType, enum_prefix=None)
delayValueType.min = delayValueType._CF_enumeration.addEnumeration(unicode_value='min', tag='min')
delayValueType.max = delayValueType._CF_enumeration.addEnumeration(unicode_value='max', tag='max')
delayValueType._InitializeFacetMap(delayValueType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'delayValueType', delayValueType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}delayPercentageType
class delayPercentageType (pyxb.binding.datatypes.float):

    """Type used to record percentage values."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'delayPercentageType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 111, 4)
    _Documentation = 'Type used to record percentage values.'
delayPercentageType._CF_maxInclusive = pyxb.binding.facets.CF_maxInclusive(value_datatype=delayPercentageType, value=pyxb.binding.datatypes.float(100.0))
delayPercentageType._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=delayPercentageType, value=pyxb.binding.datatypes.float(0.0))
delayPercentageType._InitializeFacetMap(delayPercentageType._CF_maxInclusive,
   delayPercentageType._CF_minInclusive)
Namespace.addCategoryObject('typeBinding', 'delayPercentageType', delayPercentageType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}nonNegativeFloat
class nonNegativeFloat (pyxb.binding.datatypes.float):

    """Defines a non-negative floating point number."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'nonNegativeFloat')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 121, 4)
    _Documentation = 'Defines a non-negative floating point number.'
nonNegativeFloat._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=nonNegativeFloat, value=pyxb.binding.datatypes.float(0.0))
nonNegativeFloat._InitializeFacetMap(nonNegativeFloat._CF_minInclusive)
Namespace.addCategoryObject('typeBinding', 'nonNegativeFloat', nonNegativeFloat)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}returnTypeType
class returnTypeType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'returnTypeType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 371, 4)
    _Documentation = None
returnTypeType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=returnTypeType, enum_prefix=None)
returnTypeType.void = returnTypeType._CF_enumeration.addEnumeration(unicode_value='void', tag='void')
returnTypeType.int = returnTypeType._CF_enumeration.addEnumeration(unicode_value='int', tag='int')
returnTypeType._InitializeFacetMap(returnTypeType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'returnTypeType', returnTypeType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}dataTypeType
class dataTypeType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Enumerates C argument data types."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'dataTypeType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 475, 4)
    _Documentation = 'Enumerates C argument data types.'
dataTypeType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=dataTypeType, enum_prefix=None)
dataTypeType.int = dataTypeType._CF_enumeration.addEnumeration(unicode_value='int', tag='int')
dataTypeType.unsigned_int = dataTypeType._CF_enumeration.addEnumeration(unicode_value='unsigned int', tag='unsigned_int')
dataTypeType.long = dataTypeType._CF_enumeration.addEnumeration(unicode_value='long', tag='long')
dataTypeType.unsigned_long = dataTypeType._CF_enumeration.addEnumeration(unicode_value='unsigned long', tag='unsigned_long')
dataTypeType.float = dataTypeType._CF_enumeration.addEnumeration(unicode_value='float', tag='float')
dataTypeType.double = dataTypeType._CF_enumeration.addEnumeration(unicode_value='double', tag='double')
dataTypeType.char = dataTypeType._CF_enumeration.addEnumeration(unicode_value='char *', tag='char')
dataTypeType.void = dataTypeType._CF_enumeration.addEnumeration(unicode_value='void *', tag='void')
dataTypeType._InitializeFacetMap(dataTypeType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'dataTypeType', dataTypeType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}simpleFileType
class simpleFileType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'simpleFileType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/fileType.xsd', 52, 1)
    _Documentation = None
simpleFileType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=simpleFileType, enum_prefix=None)
simpleFileType.unknown = simpleFileType._CF_enumeration.addEnumeration(unicode_value='unknown', tag='unknown')
simpleFileType.cSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='cSource', tag='cSource')
simpleFileType.cppSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='cppSource', tag='cppSource')
simpleFileType.asmSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='asmSource', tag='asmSource')
simpleFileType.vhdlSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='vhdlSource', tag='vhdlSource')
simpleFileType.vhdlSource_87 = simpleFileType._CF_enumeration.addEnumeration(unicode_value='vhdlSource-87', tag='vhdlSource_87')
simpleFileType.vhdlSource_93 = simpleFileType._CF_enumeration.addEnumeration(unicode_value='vhdlSource-93', tag='vhdlSource_93')
simpleFileType.verilogSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='verilogSource', tag='verilogSource')
simpleFileType.verilogSource_95 = simpleFileType._CF_enumeration.addEnumeration(unicode_value='verilogSource-95', tag='verilogSource_95')
simpleFileType.verilogSource_2001 = simpleFileType._CF_enumeration.addEnumeration(unicode_value='verilogSource-2001', tag='verilogSource_2001')
simpleFileType.swObject = simpleFileType._CF_enumeration.addEnumeration(unicode_value='swObject', tag='swObject')
simpleFileType.swObjectLibrary = simpleFileType._CF_enumeration.addEnumeration(unicode_value='swObjectLibrary', tag='swObjectLibrary')
simpleFileType.vhdlBinaryLibrary = simpleFileType._CF_enumeration.addEnumeration(unicode_value='vhdlBinaryLibrary', tag='vhdlBinaryLibrary')
simpleFileType.verilogBinaryLibrary = simpleFileType._CF_enumeration.addEnumeration(unicode_value='verilogBinaryLibrary', tag='verilogBinaryLibrary')
simpleFileType.unelaboratedHdl = simpleFileType._CF_enumeration.addEnumeration(unicode_value='unelaboratedHdl', tag='unelaboratedHdl')
simpleFileType.executableHdl = simpleFileType._CF_enumeration.addEnumeration(unicode_value='executableHdl', tag='executableHdl')
simpleFileType.systemVerilogSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='systemVerilogSource', tag='systemVerilogSource')
simpleFileType.systemVerilogSource_3_0 = simpleFileType._CF_enumeration.addEnumeration(unicode_value='systemVerilogSource-3.0', tag='systemVerilogSource_3_0')
simpleFileType.systemVerilogSource_3_1 = simpleFileType._CF_enumeration.addEnumeration(unicode_value='systemVerilogSource-3.1', tag='systemVerilogSource_3_1')
simpleFileType.systemCSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='systemCSource', tag='systemCSource')
simpleFileType.systemCSource_2_0 = simpleFileType._CF_enumeration.addEnumeration(unicode_value='systemCSource-2.0', tag='systemCSource_2_0')
simpleFileType.systemCSource_2_0_1 = simpleFileType._CF_enumeration.addEnumeration(unicode_value='systemCSource-2.0.1', tag='systemCSource_2_0_1')
simpleFileType.systemCSource_2_1 = simpleFileType._CF_enumeration.addEnumeration(unicode_value='systemCSource-2.1', tag='systemCSource_2_1')
simpleFileType.systemCSource_2_2 = simpleFileType._CF_enumeration.addEnumeration(unicode_value='systemCSource-2.2', tag='systemCSource_2_2')
simpleFileType.veraSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='veraSource', tag='veraSource')
simpleFileType.eSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='eSource', tag='eSource')
simpleFileType.perlSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='perlSource', tag='perlSource')
simpleFileType.tclSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='tclSource', tag='tclSource')
simpleFileType.OVASource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='OVASource', tag='OVASource')
simpleFileType.SVASource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='SVASource', tag='SVASource')
simpleFileType.pslSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='pslSource', tag='pslSource')
simpleFileType.systemVerilogSource_3_1a = simpleFileType._CF_enumeration.addEnumeration(unicode_value='systemVerilogSource-3.1a', tag='systemVerilogSource_3_1a')
simpleFileType.SDC = simpleFileType._CF_enumeration.addEnumeration(unicode_value='SDC', tag='SDC')
simpleFileType.vhdlAmsSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='vhdlAmsSource', tag='vhdlAmsSource')
simpleFileType.verilogAmsSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='verilogAmsSource', tag='verilogAmsSource')
simpleFileType.systemCAmsSource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='systemCAmsSource', tag='systemCAmsSource')
simpleFileType.libertySource = simpleFileType._CF_enumeration.addEnumeration(unicode_value='libertySource', tag='libertySource')
simpleFileType.user = simpleFileType._CF_enumeration.addEnumeration(unicode_value='user', tag='user')
simpleFileType._InitializeFacetMap(simpleFileType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'simpleFileType', simpleFileType)

# Atomic simple type: [anonymous]
class STD_ANON_7 (pyxb.binding.datatypes.Name, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 157, 4)
    _Documentation = None
STD_ANON_7._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_7, enum_prefix=None)
STD_ANON_7.and_ = STD_ANON_7._CF_enumeration.addEnumeration(unicode_value='and', tag='and_')
STD_ANON_7.or_ = STD_ANON_7._CF_enumeration.addEnumeration(unicode_value='or', tag='or_')
STD_ANON_7._InitializeFacetMap(STD_ANON_7._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_8 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 193, 5)
    _Documentation = None
STD_ANON_8._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_8, enum_prefix=None)
STD_ANON_8.instance = STD_ANON_8._CF_enumeration.addEnumeration(unicode_value='instance', tag='instance')
STD_ANON_8.entity = STD_ANON_8._CF_enumeration.addEnumeration(unicode_value='entity', tag='entity')
STD_ANON_8._InitializeFacetMap(STD_ANON_8._CF_enumeration)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}apiType
class apiType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'apiType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 229, 1)
    _Documentation = None
apiType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=apiType, enum_prefix=None)
apiType.TGI_2009 = apiType._CF_enumeration.addEnumeration(unicode_value='TGI_2009', tag='TGI_2009')
apiType.TGI_2014_BASE = apiType._CF_enumeration.addEnumeration(unicode_value='TGI_2014_BASE', tag='TGI_2014_BASE')
apiType.TGI_2014_EXTENDED = apiType._CF_enumeration.addEnumeration(unicode_value='TGI_2014_EXTENDED', tag='TGI_2014_EXTENDED')
apiType.none = apiType._CF_enumeration.addEnumeration(unicode_value='none', tag='none')
apiType._InitializeFacetMap(apiType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'apiType', apiType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}transportMethodType
class transportMethodType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'transportMethodType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 237, 1)
    _Documentation = None
transportMethodType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=transportMethodType, enum_prefix=None)
transportMethodType.file = transportMethodType._CF_enumeration.addEnumeration(unicode_value='file', tag='file')
transportMethodType._InitializeFacetMap(transportMethodType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'transportMethodType', transportMethodType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessType
class accessType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """The read/write accessability of an addess block."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'accessType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 53, 1)
    _Documentation = 'The read/write accessability of an addess block.'
accessType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=accessType, enum_prefix=None)
accessType.read_only = accessType._CF_enumeration.addEnumeration(unicode_value='read-only', tag='read_only')
accessType.write_only = accessType._CF_enumeration.addEnumeration(unicode_value='write-only', tag='write_only')
accessType.read_write = accessType._CF_enumeration.addEnumeration(unicode_value='read-write', tag='read_write')
accessType.writeOnce = accessType._CF_enumeration.addEnumeration(unicode_value='writeOnce', tag='writeOnce')
accessType.read_writeOnce = accessType._CF_enumeration.addEnumeration(unicode_value='read-writeOnce', tag='read_writeOnce')
accessType._InitializeFacetMap(accessType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'accessType', accessType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}sharedType
class sharedType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """The sharedness of the memoryMap content."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'sharedType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 65, 1)
    _Documentation = 'The sharedness of the memoryMap content.'
sharedType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=sharedType, enum_prefix=None)
sharedType.yes = sharedType._CF_enumeration.addEnumeration(unicode_value='yes', tag='yes')
sharedType.no = sharedType._CF_enumeration.addEnumeration(unicode_value='no', tag='no')
sharedType.undefined = sharedType._CF_enumeration.addEnumeration(unicode_value='undefined', tag='undefined')
sharedType._InitializeFacetMap(sharedType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'sharedType', sharedType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bankAlignmentType
class bankAlignmentType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """'serial' or 'parallel' bank alignment."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'bankAlignmentType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 75, 1)
    _Documentation = "'serial' or 'parallel' bank alignment."
bankAlignmentType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=bankAlignmentType, enum_prefix=None)
bankAlignmentType.serial = bankAlignmentType._CF_enumeration.addEnumeration(unicode_value='serial', tag='serial')
bankAlignmentType.parallel = bankAlignmentType._CF_enumeration.addEnumeration(unicode_value='parallel', tag='parallel')
bankAlignmentType._InitializeFacetMap(bankAlignmentType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'bankAlignmentType', bankAlignmentType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}usageType
class usageType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """Describes the usage of an address block."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'usageType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 84, 1)
    _Documentation = 'Describes the usage of an address block.'
usageType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=usageType, enum_prefix=None)
usageType.memory = usageType._CF_enumeration.addEnumeration(unicode_value='memory', tag='memory')
usageType.register = usageType._CF_enumeration.addEnumeration(unicode_value='register', tag='register')
usageType.reserved = usageType._CF_enumeration.addEnumeration(unicode_value='reserved', tag='reserved')
usageType._InitializeFacetMap(usageType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'usageType', usageType)

# Atomic simple type: [anonymous]
class STD_ANON_9 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 839, 7)
    _Documentation = None
STD_ANON_9._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_9, enum_prefix=None)
STD_ANON_9.read = STD_ANON_9._CF_enumeration.addEnumeration(unicode_value='read', tag='read')
STD_ANON_9.write = STD_ANON_9._CF_enumeration.addEnumeration(unicode_value='write', tag='write')
STD_ANON_9.read_write = STD_ANON_9._CF_enumeration.addEnumeration(unicode_value='read-write', tag='read_write')
STD_ANON_9._InitializeFacetMap(STD_ANON_9._CF_enumeration)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}modifiedWriteValueType
class modifiedWriteValueType (pyxb.binding.datatypes.Name, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'modifiedWriteValueType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 863, 1)
    _Documentation = None
modifiedWriteValueType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=modifiedWriteValueType, enum_prefix=None)
modifiedWriteValueType.oneToClear = modifiedWriteValueType._CF_enumeration.addEnumeration(unicode_value='oneToClear', tag='oneToClear')
modifiedWriteValueType.oneToSet = modifiedWriteValueType._CF_enumeration.addEnumeration(unicode_value='oneToSet', tag='oneToSet')
modifiedWriteValueType.oneToToggle = modifiedWriteValueType._CF_enumeration.addEnumeration(unicode_value='oneToToggle', tag='oneToToggle')
modifiedWriteValueType.zeroToClear = modifiedWriteValueType._CF_enumeration.addEnumeration(unicode_value='zeroToClear', tag='zeroToClear')
modifiedWriteValueType.zeroToSet = modifiedWriteValueType._CF_enumeration.addEnumeration(unicode_value='zeroToSet', tag='zeroToSet')
modifiedWriteValueType.zeroToToggle = modifiedWriteValueType._CF_enumeration.addEnumeration(unicode_value='zeroToToggle', tag='zeroToToggle')
modifiedWriteValueType.clear = modifiedWriteValueType._CF_enumeration.addEnumeration(unicode_value='clear', tag='clear')
modifiedWriteValueType.set_ = modifiedWriteValueType._CF_enumeration.addEnumeration(unicode_value='set', tag='set_')
modifiedWriteValueType.modify = modifiedWriteValueType._CF_enumeration.addEnumeration(unicode_value='modify', tag='modify')
modifiedWriteValueType._InitializeFacetMap(modifiedWriteValueType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'modifiedWriteValueType', modifiedWriteValueType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}readActionType
class readActionType (pyxb.binding.datatypes.Name, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'readActionType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 876, 1)
    _Documentation = None
readActionType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=readActionType, enum_prefix=None)
readActionType.clear = readActionType._CF_enumeration.addEnumeration(unicode_value='clear', tag='clear')
readActionType.set_ = readActionType._CF_enumeration.addEnumeration(unicode_value='set', tag='set_')
readActionType.modify = readActionType._CF_enumeration.addEnumeration(unicode_value='modify', tag='modify')
readActionType._InitializeFacetMap(readActionType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'readActionType', readActionType)

# Atomic simple type: [anonymous]
class STD_ANON_10 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 935, 8)
    _Documentation = None
STD_ANON_10._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_10, enum_prefix=None)
STD_ANON_10.unconstrained = STD_ANON_10._CF_enumeration.addEnumeration(unicode_value='unconstrained', tag='unconstrained')
STD_ANON_10.restore = STD_ANON_10._CF_enumeration.addEnumeration(unicode_value='restore', tag='restore')
STD_ANON_10.writeAsRead = STD_ANON_10._CF_enumeration.addEnumeration(unicode_value='writeAsRead', tag='writeAsRead')
STD_ANON_10.readOnly = STD_ANON_10._CF_enumeration.addEnumeration(unicode_value='readOnly', tag='readOnly')
STD_ANON_10._InitializeFacetMap(STD_ANON_10._CF_enumeration)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}envIdentifierType
class envIdentifierType (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'envIdentifierType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 54, 1)
    _Documentation = None
envIdentifierType._CF_pattern = pyxb.binding.facets.CF_pattern()
envIdentifierType._CF_pattern.addPattern(pattern='[a-zA-Z0-9_+\\*\\.]*:[a-zA-Z0-9_+\\*\\.]*:[a-zA-Z0-9_+\\*\\.]*')
envIdentifierType._InitializeFacetMap(envIdentifierType._CF_pattern)
Namespace.addCategoryObject('typeBinding', 'envIdentifierType', envIdentifierType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}modelInstantiationType
class modelInstantiationType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'modelInstantiationType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 390, 1)
    _Documentation = None
modelInstantiationType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=modelInstantiationType, enum_prefix=None)
modelInstantiationType.module = modelInstantiationType._CF_enumeration.addEnumeration(unicode_value='module', tag='module')
modelInstantiationType.entityarchitecture = modelInstantiationType._CF_enumeration.addEnumeration(unicode_value='entity(architecture)', tag='entityarchitecture')
modelInstantiationType.configuration = modelInstantiationType._CF_enumeration.addEnumeration(unicode_value='configuration', tag='configuration')
modelInstantiationType._InitializeFacetMap(modelInstantiationType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'modelInstantiationType', modelInstantiationType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}componentPortDirectionType
class componentPortDirectionType (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """The direction of a component port."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'componentPortDirectionType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 55, 1)
    _Documentation = 'The direction of a component port.'
componentPortDirectionType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=componentPortDirectionType, enum_prefix=None)
componentPortDirectionType.in_ = componentPortDirectionType._CF_enumeration.addEnumeration(unicode_value='in', tag='in_')
componentPortDirectionType.out = componentPortDirectionType._CF_enumeration.addEnumeration(unicode_value='out', tag='out')
componentPortDirectionType.inout = componentPortDirectionType._CF_enumeration.addEnumeration(unicode_value='inout', tag='inout')
componentPortDirectionType.phantom = componentPortDirectionType._CF_enumeration.addEnumeration(unicode_value='phantom', tag='phantom')
componentPortDirectionType._InitializeFacetMap(componentPortDirectionType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'componentPortDirectionType', componentPortDirectionType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}initiativeType
class initiativeType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'initiativeType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 139, 1)
    _Documentation = None
initiativeType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=initiativeType, enum_prefix=None)
initiativeType.requires = initiativeType._CF_enumeration.addEnumeration(unicode_value='requires', tag='requires')
initiativeType.provides = initiativeType._CF_enumeration.addEnumeration(unicode_value='provides', tag='provides')
initiativeType.both = initiativeType._CF_enumeration.addEnumeration(unicode_value='both', tag='both')
initiativeType.phantom = initiativeType._CF_enumeration.addEnumeration(unicode_value='phantom', tag='phantom')
initiativeType._InitializeFacetMap(initiativeType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'initiativeType', initiativeType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}protocolTypeType
class protocolTypeType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'protocolTypeType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 176, 1)
    _Documentation = None
protocolTypeType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=protocolTypeType, enum_prefix=None)
protocolTypeType.tlm = protocolTypeType._CF_enumeration.addEnumeration(unicode_value='tlm', tag='tlm')
protocolTypeType.custom = protocolTypeType._CF_enumeration.addEnumeration(unicode_value='custom', tag='custom')
protocolTypeType._InitializeFacetMap(protocolTypeType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'protocolTypeType', protocolTypeType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}kindType
class kindType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'kindType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 182, 1)
    _Documentation = None
kindType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=kindType, enum_prefix=None)
kindType.tlm_port = kindType._CF_enumeration.addEnumeration(unicode_value='tlm_port', tag='tlm_port')
kindType.tlm_socket = kindType._CF_enumeration.addEnumeration(unicode_value='tlm_socket', tag='tlm_socket')
kindType.simple_socket = kindType._CF_enumeration.addEnumeration(unicode_value='simple_socket', tag='simple_socket')
kindType.multi_socket = kindType._CF_enumeration.addEnumeration(unicode_value='multi_socket', tag='multi_socket')
kindType.custom = kindType._CF_enumeration.addEnumeration(unicode_value='custom', tag='custom')
kindType._InitializeFacetMap(kindType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'kindType', kindType)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}simplePortAccessType
class simplePortAccessType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'simplePortAccessType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 203, 1)
    _Documentation = None
simplePortAccessType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=simplePortAccessType, enum_prefix=None)
simplePortAccessType.ref = simplePortAccessType._CF_enumeration.addEnumeration(unicode_value='ref', tag='ref')
simplePortAccessType.ptr = simplePortAccessType._CF_enumeration.addEnumeration(unicode_value='ptr', tag='ptr')
simplePortAccessType._InitializeFacetMap(simplePortAccessType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'simplePortAccessType', simplePortAccessType)

# Atomic simple type: [anonymous]
class STD_ANON_11 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 229, 5)
    _Documentation = None
STD_ANON_11._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_11, enum_prefix=None)
STD_ANON_11.generic = STD_ANON_11._CF_enumeration.addEnumeration(unicode_value='generic', tag='generic')
STD_ANON_11.specific = STD_ANON_11._CF_enumeration.addEnumeration(unicode_value='specific', tag='specific')
STD_ANON_11._InitializeFacetMap(STD_ANON_11._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_12 (pyxb.binding.datatypes.token, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 110, 6)
    _Documentation = None
STD_ANON_12._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_12, enum_prefix=None)
STD_ANON_12.clock = STD_ANON_12._CF_enumeration.addEnumeration(unicode_value='clock', tag='clock')
STD_ANON_12.singleShot = STD_ANON_12._CF_enumeration.addEnumeration(unicode_value='singleShot', tag='singleShot')
STD_ANON_12.any = STD_ANON_12._CF_enumeration.addEnumeration(unicode_value='any', tag='any')
STD_ANON_12._InitializeFacetMap(STD_ANON_12._CF_enumeration)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portName
class portName (pyxb.binding.datatypes.string):

    """A type for a port name string, allows letters, digits, dash, colon, underscore and period"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'portName')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 228, 4)
    _Documentation = 'A type for a port name string, allows letters, digits, dash, colon, underscore and period'
portName._CF_pattern = pyxb.binding.facets.CF_pattern()
portName._CF_pattern.addPattern(pattern='\\i[\\p{L}\\p{N}\\.\\-:_]*')
portName._CF_whiteSpace = pyxb.binding.facets.CF_whiteSpace(value=pyxb.binding.facets._WhiteSpace_enum.collapse)
portName._InitializeFacetMap(portName._CF_pattern,
   portName._CF_whiteSpace)
Namespace.addCategoryObject('typeBinding', 'portName', portName)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}instancePath
class instancePath (pyxb.binding.datatypes.string):

    """A type for a instance name path string, allows letters, digits, dash, colon, underscore, period and slash"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'instancePath')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 238, 4)
    _Documentation = 'A type for a instance name path string, allows letters, digits, dash, colon, underscore, period and slash'
instancePath._CF_pattern = pyxb.binding.facets.CF_pattern()
instancePath._CF_pattern.addPattern(pattern='\\i[\\p{L}\\p{N}\\.\\-:_]*')
instancePath._CF_pattern.addPattern(pattern='\\i[\\p{L}\\p{N}\\.\\-:_]*/\\i[\\p{L}\\p{N}\\.\\-:_]*')
instancePath._CF_pattern.addPattern(pattern='(\\i[\\p{L}\\p{N}\\.\\-:_]*/)+[\\i\\p{L}\\p{N}\\.\\-:_]*')
instancePath._CF_whiteSpace = pyxb.binding.facets.CF_whiteSpace(value=pyxb.binding.facets._WhiteSpace_enum.collapse)
instancePath._InitializeFacetMap(instancePath._CF_pattern,
   instancePath._CF_whiteSpace)
Namespace.addCategoryObject('typeBinding', 'instancePath', instancePath)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}simpleBaseExpression
class simpleBaseExpression (pyxb.binding.datatypes.string):

    """Represents the base-type for an expressions, it forces a non whitespace value to be specified."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'simpleBaseExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 275, 4)
    _Documentation = 'Represents the base-type for an expressions, it forces a non whitespace value to be specified.'
simpleBaseExpression._CF_minLength = pyxb.binding.facets.CF_minLength(value=pyxb.binding.datatypes.nonNegativeInteger(1))
simpleBaseExpression._CF_whiteSpace = pyxb.binding.facets.CF_whiteSpace(value=pyxb.binding.facets._WhiteSpace_enum.collapse)
simpleBaseExpression._InitializeFacetMap(simpleBaseExpression._CF_minLength,
   simpleBaseExpression._CF_whiteSpace)
Namespace.addCategoryObject('typeBinding', 'simpleBaseExpression', simpleBaseExpression)

# Atomic simple type: [anonymous]
class STD_ANON_13 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 82, 5)
    _Documentation = None
STD_ANON_13._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_13, enum_prefix=None)
STD_ANON_13.open = STD_ANON_13._CF_enumeration.addEnumeration(unicode_value='open', tag='open')
STD_ANON_13.default = STD_ANON_13._CF_enumeration.addEnumeration(unicode_value='default', tag='default')
STD_ANON_13._InitializeFacetMap(STD_ANON_13._CF_enumeration)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}simpleUnsignedBitExpression
class simpleUnsignedBitExpression (simpleBaseExpression):

    """Represents a single-bit/bool. It supports an expression value."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'simpleUnsignedBitExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 261, 4)
    _Documentation = 'Represents a single-bit/bool. It supports an expression value.'
simpleUnsignedBitExpression._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', 'simpleUnsignedBitExpression', simpleUnsignedBitExpression)

# Atomic simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}simpleUnsignedLongintExpression
class simpleUnsignedLongintExpression (simpleBaseExpression):

    """>An unsigned longint which supports an expression value."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'simpleUnsignedLongintExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 268, 4)
    _Documentation = '>An unsigned longint which supports an expression value.'
simpleUnsignedLongintExpression._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', 'simpleUnsignedLongintExpression', simpleUnsignedLongintExpression)

# Union simple type: [anonymous]
# superclasses pyxb.binding.datatypes.anySimpleType
class STD_ANON_14 (pyxb.binding.basis.STD_union):

    """Simple type that is a union of simpleUnsignedBitExpression, STD_ANON_."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 75, 3)
    _Documentation = None

    _MemberTypes = ( simpleUnsignedBitExpression, STD_ANON_, )
STD_ANON_14._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_14)
STD_ANON_14._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_14.on = 'on'                             # originally STD_ANON_.on
STD_ANON_14.off = 'off'                           # originally STD_ANON_.off
STD_ANON_14._InitializeFacetMap(STD_ANON_14._CF_enumeration,
   STD_ANON_14._CF_pattern)

# Union simple type: [anonymous]
# superclasses pyxb.binding.datatypes.anySimpleType
class STD_ANON_15 (pyxb.binding.basis.STD_union):

    """Simple type that is a union of simpleUnsignedLongintExpression, STD_ANON_13."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 80, 3)
    _Documentation = None

    _MemberTypes = ( simpleUnsignedLongintExpression, STD_ANON_13, )
STD_ANON_15._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_15)
STD_ANON_15._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_15.open = 'open'                         # originally STD_ANON_13.open
STD_ANON_15.default = 'default'                   # originally STD_ANON_13.default
STD_ANON_15._InitializeFacetMap(STD_ANON_15._CF_enumeration,
   STD_ANON_15._CF_pattern)

# Union simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}simpleBitSteeringExpression
# superclasses STD_ANON_14
class simpleBitSteeringExpression (pyxb.binding.basis.STD_union):

    """Indicates whether bit steering should be used to map this interface onto a bus of different data width.
            
  Values are "on", "off" (defaults to "off")."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'simpleBitSteeringExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 68, 1)
    _Documentation = 'Indicates whether bit steering should be used to map this interface onto a bus of different data width.\n            \n  Values are "on", "off" (defaults to "off").'

    _MemberTypes = ( simpleUnsignedBitExpression, STD_ANON_, )
simpleBitSteeringExpression.on = 'on'             # originally STD_ANON_.on
simpleBitSteeringExpression.off = 'off'           # originally STD_ANON_.off
simpleBitSteeringExpression._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', 'simpleBitSteeringExpression', simpleBitSteeringExpression)

# Union simple type: {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}simpleTiedValueType
# superclasses STD_ANON_15
class simpleTiedValueType (pyxb.binding.basis.STD_union):

    """Simple type that is a union of simpleUnsignedLongintExpression, STD_ANON_13."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'simpleTiedValueType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 75, 1)
    _Documentation = ''

    _MemberTypes = ( simpleUnsignedLongintExpression, STD_ANON_13, )
simpleTiedValueType.open = 'open'                 # originally STD_ANON_13.open
simpleTiedValueType.default = 'default'           # originally STD_ANON_13.default
simpleTiedValueType._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', 'simpleTiedValueType', simpleTiedValueType)

# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON (pyxb.binding.basis.complexTypeDefinition):
    """Define the ports and other information of a particular abstraction of the bus"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 143, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}busType uses Python identifier busType
    __busType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'busType'), 'busType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_httpwww_accellera_orgXMLSchemaIPXACT1685_2014busType', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 146, 4), )

    
    busType = property(__busType.value, __busType.set, None, 'Reference to the busDefinition that this abstractionDefinition implements.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}extends uses Python identifier extends
    __extends = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'extends'), 'extends', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_httpwww_accellera_orgXMLSchemaIPXACT1685_2014extends', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 151, 4), )

    
    extends = property(__extends.value, __extends.set, None, 'Optional name of abstraction type that this abstraction definition is compatible with. This abstraction definition may change the definitions of ports in the existing abstraction definition and add new ports, the ports in the original abstraction are not deleted but may be marked illegal to disallow their use.\n\t\t\t\tThis abstraction definition may only extend another abstraction definition if the bus type of this abstraction definition extends the bus type of the extended abstraction definition')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}ports uses Python identifier ports
    __ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'ports'), 'ports', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_httpwww_accellera_orgXMLSchemaIPXACT1685_2014ports', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 157, 4), )

    
    ports = property(__ports.value, __ports.set, None, 'This is a list of logical ports defined by the bus.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}assertions uses Python identifier assertions
    __assertions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'assertions'), 'assertions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_httpwww_accellera_orgXMLSchemaIPXACT1685_2014assertions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1), )

    
    assertions = property(__assertions.value, __assertions.set, None, 'List of assertions about allowed parameter values.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendor uses Python identifier vendor
    __vendor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendor'), 'vendor', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendor', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3), )

    
    vendor = property(__vendor.value, __vendor.set, None, 'Name of the vendor who supplies this file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}library uses Python identifier library
    __library = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'library'), 'library', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_httpwww_accellera_orgXMLSchemaIPXACT1685_2014library', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3), )

    
    library = property(__library.value, __library.set, None, 'Name of the logical library this element belongs to.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3), )

    
    name = property(__name.value, __name.set, None, 'The name of the object.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}version uses Python identifier version
    __version = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'version'), 'version', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_httpwww_accellera_orgXMLSchemaIPXACT1685_2014version', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3), )

    
    version = property(__version.value, __version.set, None, 'Indicates the version of the named element.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __busType.name() : __busType,
        __extends.name() : __extends,
        __ports.name() : __ports,
        __assertions.name() : __assertions,
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __description.name() : __description,
        __vendor.name() : __vendor,
        __library.name() : __library,
        __name.name() : __name,
        __version.name() : __version
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_ (pyxb.binding.basis.complexTypeDefinition):
    """This is a list of logical ports defined by the bus."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 161, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}port uses Python identifier port
    __port = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'port'), 'port', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON__httpwww_accellera_orgXMLSchemaIPXACT1685_2014port', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 163, 7), )

    
    port = property(__port.value, __port.set, None, None)

    _ElementMap.update({
        __port.name() : __port
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_2 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 164, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}logicalName uses Python identifier logicalName
    __logicalName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'logicalName'), 'logicalName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_2_httpwww_accellera_orgXMLSchemaIPXACT1685_2014logicalName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 167, 10), )

    
    logicalName = property(__logicalName.value, __logicalName.set, None, 'The assigned name of this port in bus specifications.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}wire uses Python identifier wire
    __wire = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'wire'), 'wire', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_2_httpwww_accellera_orgXMLSchemaIPXACT1685_2014wire', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 178, 11), )

    
    wire = property(__wire.value, __wire.set, None, 'A port that carries logic or an array of logic values')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}transactional uses Python identifier transactional
    __transactional = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'transactional'), 'transactional', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_2_httpwww_accellera_orgXMLSchemaIPXACT1685_2014transactional', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 258, 11), )

    
    transactional = property(__transactional.value, __transactional.set, None, 'A port that carries complex information modeled at a high level of abstraction.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_2_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_2_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_2_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_2_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_2_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __logicalName.name() : __logicalName,
        __wire.name() : __wire,
        __transactional.name() : __transactional,
        __vendorExtensions.name() : __vendorExtensions,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_3 (pyxb.binding.basis.complexTypeDefinition):
    """A port that carries logic or an array of logic values"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 182, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}qualifier uses Python identifier qualifier
    __qualifier = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'qualifier'), 'qualifier', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_3_httpwww_accellera_orgXMLSchemaIPXACT1685_2014qualifier', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 184, 14), )

    
    qualifier = property(__qualifier.value, __qualifier.set, None, 'The type of information this port carries A wire port can carry both address and data, but may not mix this with a clock or reset')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}onSystem uses Python identifier onSystem
    __onSystem = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'onSystem'), 'onSystem', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_3_httpwww_accellera_orgXMLSchemaIPXACT1685_2014onSystem', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 215, 14), )

    
    onSystem = property(__onSystem.value, __onSystem.set, None, 'Defines constraints for this port when present in a system bus interface with a matching group name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}onMaster uses Python identifier onMaster
    __onMaster = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'onMaster'), 'onMaster', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_3_httpwww_accellera_orgXMLSchemaIPXACT1685_2014onMaster', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 231, 14), )

    
    onMaster = property(__onMaster.value, __onMaster.set, None, 'Defines constraints for this port when present in a master bus interface.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}onSlave uses Python identifier onSlave
    __onSlave = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'onSlave'), 'onSlave', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_3_httpwww_accellera_orgXMLSchemaIPXACT1685_2014onSlave', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 239, 14), )

    
    onSlave = property(__onSlave.value, __onSlave.set, None, 'Defines constraints for this port when present in a slave bus interface.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}defaultValue uses Python identifier defaultValue
    __defaultValue = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'defaultValue'), 'defaultValue', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_3_httpwww_accellera_orgXMLSchemaIPXACT1685_2014defaultValue', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 248, 15), )

    
    defaultValue = property(__defaultValue.value, __defaultValue.set, None, 'Indicates the default value for this wire port.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}requiresDriver uses Python identifier requiresDriver
    __requiresDriver = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'requiresDriver'), 'requiresDriver', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_3_httpwww_accellera_orgXMLSchemaIPXACT1685_2014requiresDriver', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 99, 1), )

    
    requiresDriver = property(__requiresDriver.value, __requiresDriver.set, None, 'Specifies if a port requires a driver. Default is false. The attribute driverType can further qualify what type of driver is required. Undefined behaviour if direction is not input or inout. Driver type any indicates that any unspecified type of driver must be connected')

    _ElementMap.update({
        __qualifier.name() : __qualifier,
        __onSystem.name() : __onSystem,
        __onMaster.name() : __onMaster,
        __onSlave.name() : __onSlave,
        __defaultValue.name() : __defaultValue,
        __requiresDriver.name() : __requiresDriver
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_4 (pyxb.binding.basis.complexTypeDefinition):
    """The type of information this port carries A wire port can carry both address and data, but may not mix this with a clock or reset"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 188, 15)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isAddress uses Python identifier isAddress
    __isAddress = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isAddress'), 'isAddress', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_4_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isAddress', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 191, 18), )

    
    isAddress = property(__isAddress.value, __isAddress.set, None, 'If this element is present, the port contains address information.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isData uses Python identifier isData
    __isData = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isData'), 'isData', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_4_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isData', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 196, 18), )

    
    isData = property(__isData.value, __isData.set, None, 'If this element is present, the port contains data information.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isClock uses Python identifier isClock
    __isClock = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isClock'), 'isClock', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_4_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isClock', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 202, 17), )

    
    isClock = property(__isClock.value, __isClock.set, None, 'If this element is present, the port contains only clock information.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isReset uses Python identifier isReset
    __isReset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isReset'), 'isReset', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_4_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isReset', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 207, 17), )

    
    isReset = property(__isReset.value, __isReset.set, None, 'Is this element is present, the port contains only reset information.')

    _ElementMap.update({
        __isAddress.name() : __isAddress,
        __isData.name() : __isData,
        __isClock.name() : __isClock,
        __isReset.name() : __isReset
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_5 (pyxb.binding.basis.complexTypeDefinition):
    """Defines constraints for this port when present in a system bus interface with a matching group name."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 219, 15)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}presence uses Python identifier presence
    __presence = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'presence'), 'presence', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_5_httpwww_accellera_orgXMLSchemaIPXACT1685_2014presence', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 70, 1), )

    
    presence = property(__presence.value, __presence.set, None, "If this element is present, the\n            existance of the port is controlled by the specified\n            value. valid values are 'illegal', 'required' and\n            'optional'.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}width uses Python identifier width
    __width = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'width'), 'width', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_5_httpwww_accellera_orgXMLSchemaIPXACT1685_2014width', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 115, 3), )

    
    width = property(__width.value, __width.set, None, 'Number of bits required to represent this port. Absence of this element indicates unconstrained number of bits, i.e. the component will define the number of bits in this port. The logical numbering of the port starts at 0 to width-1.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}direction uses Python identifier direction
    __direction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'direction'), 'direction', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_5_httpwww_accellera_orgXMLSchemaIPXACT1685_2014direction', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 120, 3), )

    
    direction = property(__direction.value, __direction.set, None, 'If this element is present, the direction of this port is restricted to the specified value. The direction is relative to the non-mirrored interface.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}modeConstraints uses Python identifier modeConstraints
    __modeConstraints = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'modeConstraints'), 'modeConstraints', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_5_httpwww_accellera_orgXMLSchemaIPXACT1685_2014modeConstraints', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 126, 4), )

    
    modeConstraints = property(__modeConstraints.value, __modeConstraints.set, None, "Specifies default constraints for the enclosing wire type port. If the mirroredModeConstraints element is not defined, then these constraints applied to this port when it appears in a 'mode' bus interface or a mirrored-'mode' bus interface. Otherwise they only apply when the port appears in a 'mode' bus interface.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}mirroredModeConstraints uses Python identifier mirroredModeConstraints
    __mirroredModeConstraints = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'mirroredModeConstraints'), 'mirroredModeConstraints', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_5_httpwww_accellera_orgXMLSchemaIPXACT1685_2014mirroredModeConstraints', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 131, 4), )

    
    mirroredModeConstraints = property(__mirroredModeConstraints.value, __mirroredModeConstraints.set, None, "Specifies default constraints for the enclosing wire type port when it appears in a mirrored-'mode' bus interface. ")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'group'), 'group', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_5_httpwww_accellera_orgXMLSchemaIPXACT1685_2014group', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 221, 17), )

    
    group = property(__group.value, __group.set, None, 'Used to group system ports into different groups within a common bus.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_5_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __presence.name() : __presence,
        __width.name() : __width,
        __direction.name() : __direction,
        __modeConstraints.name() : __modeConstraints,
        __mirroredModeConstraints.name() : __mirroredModeConstraints,
        __group.name() : __group
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_6 (pyxb.binding.basis.complexTypeDefinition):
    """Defines constraints for this port when present in a master bus interface."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 235, 15)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}presence uses Python identifier presence
    __presence = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'presence'), 'presence', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_6_httpwww_accellera_orgXMLSchemaIPXACT1685_2014presence', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 70, 1), )

    
    presence = property(__presence.value, __presence.set, None, "If this element is present, the\n            existance of the port is controlled by the specified\n            value. valid values are 'illegal', 'required' and\n            'optional'.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}width uses Python identifier width
    __width = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'width'), 'width', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_6_httpwww_accellera_orgXMLSchemaIPXACT1685_2014width', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 115, 3), )

    
    width = property(__width.value, __width.set, None, 'Number of bits required to represent this port. Absence of this element indicates unconstrained number of bits, i.e. the component will define the number of bits in this port. The logical numbering of the port starts at 0 to width-1.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}direction uses Python identifier direction
    __direction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'direction'), 'direction', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_6_httpwww_accellera_orgXMLSchemaIPXACT1685_2014direction', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 120, 3), )

    
    direction = property(__direction.value, __direction.set, None, 'If this element is present, the direction of this port is restricted to the specified value. The direction is relative to the non-mirrored interface.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}modeConstraints uses Python identifier modeConstraints
    __modeConstraints = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'modeConstraints'), 'modeConstraints', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_6_httpwww_accellera_orgXMLSchemaIPXACT1685_2014modeConstraints', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 126, 4), )

    
    modeConstraints = property(__modeConstraints.value, __modeConstraints.set, None, "Specifies default constraints for the enclosing wire type port. If the mirroredModeConstraints element is not defined, then these constraints applied to this port when it appears in a 'mode' bus interface or a mirrored-'mode' bus interface. Otherwise they only apply when the port appears in a 'mode' bus interface.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}mirroredModeConstraints uses Python identifier mirroredModeConstraints
    __mirroredModeConstraints = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'mirroredModeConstraints'), 'mirroredModeConstraints', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_6_httpwww_accellera_orgXMLSchemaIPXACT1685_2014mirroredModeConstraints', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 131, 4), )

    
    mirroredModeConstraints = property(__mirroredModeConstraints.value, __mirroredModeConstraints.set, None, "Specifies default constraints for the enclosing wire type port when it appears in a mirrored-'mode' bus interface. ")

    _ElementMap.update({
        __presence.name() : __presence,
        __width.name() : __width,
        __direction.name() : __direction,
        __modeConstraints.name() : __modeConstraints,
        __mirroredModeConstraints.name() : __mirroredModeConstraints
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_7 (pyxb.binding.basis.complexTypeDefinition):
    """Defines constraints for this port when present in a slave bus interface."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 243, 15)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}presence uses Python identifier presence
    __presence = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'presence'), 'presence', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_7_httpwww_accellera_orgXMLSchemaIPXACT1685_2014presence', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 70, 1), )

    
    presence = property(__presence.value, __presence.set, None, "If this element is present, the\n            existance of the port is controlled by the specified\n            value. valid values are 'illegal', 'required' and\n            'optional'.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}width uses Python identifier width
    __width = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'width'), 'width', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_7_httpwww_accellera_orgXMLSchemaIPXACT1685_2014width', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 115, 3), )

    
    width = property(__width.value, __width.set, None, 'Number of bits required to represent this port. Absence of this element indicates unconstrained number of bits, i.e. the component will define the number of bits in this port. The logical numbering of the port starts at 0 to width-1.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}direction uses Python identifier direction
    __direction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'direction'), 'direction', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_7_httpwww_accellera_orgXMLSchemaIPXACT1685_2014direction', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 120, 3), )

    
    direction = property(__direction.value, __direction.set, None, 'If this element is present, the direction of this port is restricted to the specified value. The direction is relative to the non-mirrored interface.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}modeConstraints uses Python identifier modeConstraints
    __modeConstraints = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'modeConstraints'), 'modeConstraints', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_7_httpwww_accellera_orgXMLSchemaIPXACT1685_2014modeConstraints', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 126, 4), )

    
    modeConstraints = property(__modeConstraints.value, __modeConstraints.set, None, "Specifies default constraints for the enclosing wire type port. If the mirroredModeConstraints element is not defined, then these constraints applied to this port when it appears in a 'mode' bus interface or a mirrored-'mode' bus interface. Otherwise they only apply when the port appears in a 'mode' bus interface.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}mirroredModeConstraints uses Python identifier mirroredModeConstraints
    __mirroredModeConstraints = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'mirroredModeConstraints'), 'mirroredModeConstraints', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_7_httpwww_accellera_orgXMLSchemaIPXACT1685_2014mirroredModeConstraints', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 131, 4), )

    
    mirroredModeConstraints = property(__mirroredModeConstraints.value, __mirroredModeConstraints.set, None, "Specifies default constraints for the enclosing wire type port when it appears in a mirrored-'mode' bus interface. ")

    _ElementMap.update({
        __presence.name() : __presence,
        __width.name() : __width,
        __direction.name() : __direction,
        __modeConstraints.name() : __modeConstraints,
        __mirroredModeConstraints.name() : __mirroredModeConstraints
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_8 (pyxb.binding.basis.complexTypeDefinition):
    """A port that carries complex information modeled at a high level of abstraction."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 262, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}qualifier uses Python identifier qualifier
    __qualifier = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'qualifier'), 'qualifier', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_8_httpwww_accellera_orgXMLSchemaIPXACT1685_2014qualifier', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 264, 14), )

    
    qualifier = property(__qualifier.value, __qualifier.set, None, 'The type of information this port carries A transactional port can carry both address and data information.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}onSystem uses Python identifier onSystem
    __onSystem = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'onSystem'), 'onSystem', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_8_httpwww_accellera_orgXMLSchemaIPXACT1685_2014onSystem', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 283, 14), )

    
    onSystem = property(__onSystem.value, __onSystem.set, None, 'Defines constraints for this port when present in a system bus interface with a matching group name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}onMaster uses Python identifier onMaster
    __onMaster = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'onMaster'), 'onMaster', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_8_httpwww_accellera_orgXMLSchemaIPXACT1685_2014onMaster', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 299, 14), )

    
    onMaster = property(__onMaster.value, __onMaster.set, None, 'Defines constraints for this port when present in a master bus interface.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}onSlave uses Python identifier onSlave
    __onSlave = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'onSlave'), 'onSlave', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_8_httpwww_accellera_orgXMLSchemaIPXACT1685_2014onSlave', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 307, 14), )

    
    onSlave = property(__onSlave.value, __onSlave.set, None, 'Defines constraints for this port when present in a slave bus interface.')

    _ElementMap.update({
        __qualifier.name() : __qualifier,
        __onSystem.name() : __onSystem,
        __onMaster.name() : __onMaster,
        __onSlave.name() : __onSlave
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_9 (pyxb.binding.basis.complexTypeDefinition):
    """The type of information this port carries A transactional port can carry both address and data information."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 268, 15)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isAddress uses Python identifier isAddress
    __isAddress = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isAddress'), 'isAddress', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_9_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isAddress', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 270, 17), )

    
    isAddress = property(__isAddress.value, __isAddress.set, None, 'If this element is present, the port contains address information.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isData uses Python identifier isData
    __isData = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isData'), 'isData', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_9_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isData', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 275, 17), )

    
    isData = property(__isData.value, __isData.set, None, 'If this element is present, the port contains data information.')

    _ElementMap.update({
        __isAddress.name() : __isAddress,
        __isData.name() : __isData
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_10 (pyxb.binding.basis.complexTypeDefinition):
    """Defines constraints for this port when present in a system bus interface with a matching group name."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 287, 15)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}presence uses Python identifier presence
    __presence = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'presence'), 'presence', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_10_httpwww_accellera_orgXMLSchemaIPXACT1685_2014presence', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 70, 1), )

    
    presence = property(__presence.value, __presence.set, None, "If this element is present, the\n            existance of the port is controlled by the specified\n            value. valid values are 'illegal', 'required' and\n            'optional'.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}initiative uses Python identifier initiative
    __initiative = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'initiative'), 'initiative', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_10_httpwww_accellera_orgXMLSchemaIPXACT1685_2014initiative', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 84, 3), )

    
    initiative = property(__initiative.value, __initiative.set, None, 'If this element is present, the type of access is restricted to the specified value.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}busWidth uses Python identifier busWidth
    __busWidth = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'busWidth'), 'busWidth', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_10_httpwww_accellera_orgXMLSchemaIPXACT1685_2014busWidth', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 97, 3), )

    
    busWidth = property(__busWidth.value, __busWidth.set, None, 'If this element is present, the width must match')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'group'), 'group', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_10_httpwww_accellera_orgXMLSchemaIPXACT1685_2014group', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 289, 17), )

    
    group = property(__group.value, __group.set, None, 'Used to group system ports into different groups within a common bus.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}protocol uses Python identifier protocol
    __protocol = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'protocol'), 'protocol', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_10_httpwww_accellera_orgXMLSchemaIPXACT1685_2014protocol', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 157, 1), )

    
    protocol = property(__protocol.value, __protocol.set, None, 'defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}kind uses Python identifier kind
    __kind = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'kind'), 'kind', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_10_httpwww_accellera_orgXMLSchemaIPXACT1685_2014kind', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 191, 1), )

    
    kind = property(__kind.value, __kind.set, None, 'Defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_10_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __presence.name() : __presence,
        __initiative.name() : __initiative,
        __busWidth.name() : __busWidth,
        __group.name() : __group,
        __protocol.name() : __protocol,
        __kind.name() : __kind
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_11 (pyxb.binding.basis.complexTypeDefinition):
    """Defines constraints for this port when present in a master bus interface."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 303, 15)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}presence uses Python identifier presence
    __presence = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'presence'), 'presence', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_11_httpwww_accellera_orgXMLSchemaIPXACT1685_2014presence', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 70, 1), )

    
    presence = property(__presence.value, __presence.set, None, "If this element is present, the\n            existance of the port is controlled by the specified\n            value. valid values are 'illegal', 'required' and\n            'optional'.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}initiative uses Python identifier initiative
    __initiative = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'initiative'), 'initiative', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_11_httpwww_accellera_orgXMLSchemaIPXACT1685_2014initiative', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 84, 3), )

    
    initiative = property(__initiative.value, __initiative.set, None, 'If this element is present, the type of access is restricted to the specified value.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}busWidth uses Python identifier busWidth
    __busWidth = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'busWidth'), 'busWidth', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_11_httpwww_accellera_orgXMLSchemaIPXACT1685_2014busWidth', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 97, 3), )

    
    busWidth = property(__busWidth.value, __busWidth.set, None, 'If this element is present, the width must match')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}protocol uses Python identifier protocol
    __protocol = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'protocol'), 'protocol', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_11_httpwww_accellera_orgXMLSchemaIPXACT1685_2014protocol', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 157, 1), )

    
    protocol = property(__protocol.value, __protocol.set, None, 'defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}kind uses Python identifier kind
    __kind = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'kind'), 'kind', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_11_httpwww_accellera_orgXMLSchemaIPXACT1685_2014kind', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 191, 1), )

    
    kind = property(__kind.value, __kind.set, None, 'Defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets')

    _ElementMap.update({
        __presence.name() : __presence,
        __initiative.name() : __initiative,
        __busWidth.name() : __busWidth,
        __protocol.name() : __protocol,
        __kind.name() : __kind
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_12 (pyxb.binding.basis.complexTypeDefinition):
    """Defines constraints for this port when present in a slave bus interface."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 311, 15)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}presence uses Python identifier presence
    __presence = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'presence'), 'presence', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_12_httpwww_accellera_orgXMLSchemaIPXACT1685_2014presence', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 70, 1), )

    
    presence = property(__presence.value, __presence.set, None, "If this element is present, the\n            existance of the port is controlled by the specified\n            value. valid values are 'illegal', 'required' and\n            'optional'.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}initiative uses Python identifier initiative
    __initiative = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'initiative'), 'initiative', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_12_httpwww_accellera_orgXMLSchemaIPXACT1685_2014initiative', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 84, 3), )

    
    initiative = property(__initiative.value, __initiative.set, None, 'If this element is present, the type of access is restricted to the specified value.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}busWidth uses Python identifier busWidth
    __busWidth = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'busWidth'), 'busWidth', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_12_httpwww_accellera_orgXMLSchemaIPXACT1685_2014busWidth', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 97, 3), )

    
    busWidth = property(__busWidth.value, __busWidth.set, None, 'If this element is present, the width must match')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}protocol uses Python identifier protocol
    __protocol = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'protocol'), 'protocol', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_12_httpwww_accellera_orgXMLSchemaIPXACT1685_2014protocol', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 157, 1), )

    
    protocol = property(__protocol.value, __protocol.set, None, 'defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}kind uses Python identifier kind
    __kind = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'kind'), 'kind', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_12_httpwww_accellera_orgXMLSchemaIPXACT1685_2014kind', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 191, 1), )

    
    kind = property(__kind.value, __kind.set, None, 'Defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets')

    _ElementMap.update({
        __presence.name() : __presence,
        __initiative.name() : __initiative,
        __busWidth.name() : __busWidth,
        __protocol.name() : __protocol,
        __kind.name() : __kind
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractorType with content type ELEMENT_ONLY
class abstractorType (pyxb.binding.basis.complexTypeDefinition):
    """Abstractor-specific extension to abstractorType"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'abstractorType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 58, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractorMode uses Python identifier abstractorMode
    __abstractorMode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'abstractorMode'), 'abstractorMode', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014abstractorMode', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 64, 3), )

    
    abstractorMode = property(__abstractorMode.value, __abstractorMode.set, None, 'Define the mode for the interfaces on this abstractor. \n\nFor master the first interface connects to the master, the second connects to the mirroredMaster\n\nFor slave the first interface connects to the mirroredSlave the second connects to the slave\n\nFor direct the first interface connects to the master, the second connects to the slave\n\nFor system the first interface connects to the system, the second connects to the mirroredSystem. For system the group attribute is required')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}busType uses Python identifier busType
    __busType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'busType'), 'busType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014busType', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 88, 3), )

    
    busType = property(__busType.value, __busType.set, None, 'The bus type of both interfaces. Refers to bus definition using vendor, library, name, version attributes.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractorInterfaces uses Python identifier abstractorInterfaces
    __abstractorInterfaces = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'abstractorInterfaces'), 'abstractorInterfaces', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014abstractorInterfaces', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 93, 3), )

    
    abstractorInterfaces = property(__abstractorInterfaces.value, __abstractorInterfaces.set, None, 'The interfaces supported by this abstractor')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}model uses Python identifier model
    __model = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'model'), 'model', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014model', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 107, 3), )

    
    model = property(__model.value, __model.set, None, 'Model information.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}choices uses Python identifier choices
    __choices = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'choices'), 'choices', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014choices', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 95, 1), )

    
    choices = property(__choices.value, __choices.set, None, 'Choices used by elements with an attribute ipxact:choiceRef.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}assertions uses Python identifier assertions
    __assertions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'assertions'), 'assertions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014assertions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1), )

    
    assertions = property(__assertions.value, __assertions.set, None, 'List of assertions about allowed parameter values.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileSets uses Python identifier fileSets
    __fileSets = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'fileSets'), 'fileSets', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014fileSets', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 337, 4), )

    
    fileSets = property(__fileSets.value, __fileSets.set, None, 'List of file sets associated with component.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractorGenerators uses Python identifier abstractorGenerators
    __abstractorGenerators = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'abstractorGenerators'), 'abstractorGenerators', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014abstractorGenerators', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 219, 1), )

    
    abstractorGenerators = property(__abstractorGenerators.value, __abstractorGenerators.set, None, 'List of abstractor generators.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendor uses Python identifier vendor
    __vendor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendor'), 'vendor', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendor', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3), )

    
    vendor = property(__vendor.value, __vendor.set, None, 'Name of the vendor who supplies this file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}library uses Python identifier library
    __library = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'library'), 'library', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014library', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3), )

    
    library = property(__library.value, __library.set, None, 'Name of the logical library this element belongs to.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3), )

    
    name = property(__name.value, __name.set, None, 'The name of the object.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}version uses Python identifier version
    __version = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'version'), 'version', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014version', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3), )

    
    version = property(__version.value, __version.set, None, 'Indicates the version of the named element.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __abstractorMode.name() : __abstractorMode,
        __busType.name() : __busType,
        __abstractorInterfaces.name() : __abstractorInterfaces,
        __model.name() : __model,
        __choices.name() : __choices,
        __assertions.name() : __assertions,
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __description.name() : __description,
        __fileSets.name() : __fileSets,
        __abstractorGenerators.name() : __abstractorGenerators,
        __vendor.name() : __vendor,
        __library.name() : __library,
        __name.name() : __name,
        __version.name() : __version
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'abstractorType', abstractorType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_13 (pyxb.binding.basis.complexTypeDefinition):
    """The interfaces supported by this abstractor"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 97, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractorInterface uses Python identifier abstractorInterface
    __abstractorInterface = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'abstractorInterface'), 'abstractorInterface', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_13_httpwww_accellera_orgXMLSchemaIPXACT1685_2014abstractorInterface', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 99, 6), )

    
    abstractorInterface = property(__abstractorInterface.value, __abstractorInterface.set, None, 'An abstractor must have exactly 2 Interfaces.')

    _ElementMap.update({
        __abstractorInterface.name() : __abstractorInterface
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_14 (pyxb.binding.basis.complexTypeDefinition):
    """Choices used by elements with an attribute ipxact:choiceRef."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 99, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}choice uses Python identifier choice
    __choice = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'choice'), 'choice', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_14_httpwww_accellera_orgXMLSchemaIPXACT1685_2014choice', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 101, 4), )

    
    choice = property(__choice.value, __choice.set, None, 'Non-empty set of legal values for a elements with an attribute ipxact:choiceRef.')

    _ElementMap.update({
        __choice.name() : __choice
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_15 (pyxb.binding.basis.complexTypeDefinition):
    """Non-empty set of legal values for a elements with an attribute ipxact:choiceRef."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 105, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_15_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 107, 7), )

    
    name = property(__name.value, __name.set, None, 'Choice key, available for reference by the ipxact:choiceRef attribute.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}enumeration uses Python identifier enumeration
    __enumeration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'enumeration'), 'enumeration', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_15_httpwww_accellera_orgXMLSchemaIPXACT1685_2014enumeration', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 112, 7), )

    
    enumeration = property(__enumeration.value, __enumeration.set, None, 'One possible value of ipxact:choice')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_15_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __name.name() : __name,
        __enumeration.name() : __enumeration
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_16 (pyxb.binding.basis.complexTypeDefinition):
    """Defines the structural information associated with a bus type, independent of the abstraction level."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 68, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}directConnection uses Python identifier directConnection
    __directConnection = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'directConnection'), 'directConnection', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014directConnection', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 71, 4), )

    
    directConnection = property(__directConnection.value, __directConnection.set, None, 'This element indicates that a master interface may be directly connected to a slave interface (under certain conditions) for busses of this type.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}broadcast uses Python identifier broadcast
    __broadcast = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'broadcast'), 'broadcast', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014broadcast', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 76, 4), )

    
    broadcast = property(__broadcast.value, __broadcast.set, None, "This element indicates that this bus definition supports 'broadcast' mode. This means that it is legal to make one-to-many interface connections.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isAddressable uses Python identifier isAddressable
    __isAddressable = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isAddressable'), 'isAddressable', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isAddressable', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 81, 4), )

    
    isAddressable = property(__isAddressable.value, __isAddressable.set, None, 'If true, indicates that this is an addressable bus.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}extends uses Python identifier extends
    __extends = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'extends'), 'extends', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014extends', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 86, 4), )

    
    extends = property(__extends.value, __extends.set, None, 'Optional name of bus type that this bus definition is compatible with. This bus definition may change the definitions in the existing bus definition')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}maxMasters uses Python identifier maxMasters
    __maxMasters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'maxMasters'), 'maxMasters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014maxMasters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 91, 4), )

    
    maxMasters = property(__maxMasters.value, __maxMasters.set, None, 'Indicates the maximum number of masters this bus supports.  If this element is not present, the number of masters allowed is unbounded. ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}maxSlaves uses Python identifier maxSlaves
    __maxSlaves = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'maxSlaves'), 'maxSlaves', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014maxSlaves', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 96, 4), )

    
    maxSlaves = property(__maxSlaves.value, __maxSlaves.set, None, 'Indicates the maximum number of slaves this bus supports.  If the element is not present, the number of slaves allowed is unbounded.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}systemGroupNames uses Python identifier systemGroupNames
    __systemGroupNames = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'systemGroupNames'), 'systemGroupNames', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014systemGroupNames', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 101, 4), )

    
    systemGroupNames = property(__systemGroupNames.value, __systemGroupNames.set, None, 'Indicates the list of system group names that are defined for this bus definition.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}assertions uses Python identifier assertions
    __assertions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'assertions'), 'assertions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014assertions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1), )

    
    assertions = property(__assertions.value, __assertions.set, None, 'List of assertions about allowed parameter values.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendor uses Python identifier vendor
    __vendor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendor'), 'vendor', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendor', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3), )

    
    vendor = property(__vendor.value, __vendor.set, None, 'Name of the vendor who supplies this file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}library uses Python identifier library
    __library = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'library'), 'library', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014library', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3), )

    
    library = property(__library.value, __library.set, None, 'Name of the logical library this element belongs to.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3), )

    
    name = property(__name.value, __name.set, None, 'The name of the object.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}version uses Python identifier version
    __version = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'version'), 'version', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_accellera_orgXMLSchemaIPXACT1685_2014version', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3), )

    
    version = property(__version.value, __version.set, None, 'Indicates the version of the named element.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_16_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __directConnection.name() : __directConnection,
        __broadcast.name() : __broadcast,
        __isAddressable.name() : __isAddressable,
        __extends.name() : __extends,
        __maxMasters.name() : __maxMasters,
        __maxSlaves.name() : __maxSlaves,
        __systemGroupNames.name() : __systemGroupNames,
        __assertions.name() : __assertions,
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __description.name() : __description,
        __vendor.name() : __vendor,
        __library.name() : __library,
        __name.name() : __name,
        __version.name() : __version
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_17 (pyxb.binding.basis.complexTypeDefinition):
    """Indicates the list of system group names that are defined for this bus definition."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 105, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}systemGroupName uses Python identifier systemGroupName
    __systemGroupName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'systemGroupName'), 'systemGroupName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_17_httpwww_accellera_orgXMLSchemaIPXACT1685_2014systemGroupName', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 107, 7), )

    
    systemGroupName = property(__systemGroupName.value, __systemGroupName.set, None, 'Indicates the name of a system group defined for this bus definition.')

    _ElementMap.update({
        __systemGroupName.name() : __systemGroupName
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_18 (pyxb.binding.basis.complexTypeDefinition):
    """Indicates the name of a system group defined for this bus definition."""
    _TypeDefinition = pyxb.binding.datatypes.Name
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 111, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.Name
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_18_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_19 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type SIMPLE"""
    _TypeDefinition = pyxb.binding.datatypes.NMTOKEN
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 102, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.NMTOKEN
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_19_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_20 (pyxb.binding.basis.complexTypeDefinition):
    """A list of bus interfaces supported by this component."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 119, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}busInterface uses Python identifier busInterface
    __busInterface = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'busInterface'), 'busInterface', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_20_httpwww_accellera_orgXMLSchemaIPXACT1685_2014busInterface', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 110, 1), )

    
    busInterface = property(__busInterface.value, __busInterface.set, None, 'Describes one of the bus interfaces supported by this component.')

    _ElementMap.update({
        __busInterface.name() : __busInterface
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}busInterfaceType with content type ELEMENT_ONLY
class busInterfaceType (pyxb.binding.basis.complexTypeDefinition):
    """Type definition for a busInterface in a component"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'busInterfaceType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 125, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bitsInLau uses Python identifier bitsInLau
    __bitsInLau = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'bitsInLau'), 'bitsInLau', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014bitsInLau', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 96, 1), )

    
    bitsInLau = property(__bitsInLau.value, __bitsInLau.set, None, 'The number of bits in the least addressable unit. The default is byte addressable (8 bits).')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}busType uses Python identifier busType
    __busType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'busType'), 'busType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014busType', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 132, 3), )

    
    busType = property(__busType.value, __busType.set, None, 'The bus type of this interface. Refers to bus definition using vendor, library, name, version attributes along with any configurable element values needed to configure this interface.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}connectionRequired uses Python identifier connectionRequired
    __connectionRequired = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'connectionRequired'), 'connectionRequired', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014connectionRequired', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 143, 3), )

    
    connectionRequired = property(__connectionRequired.value, __connectionRequired.set, None, 'Indicates whether a connection to this interface is required for proper component functionality.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bitSteering uses Python identifier bitSteering
    __bitSteering = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'bitSteering'), 'bitSteering', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014bitSteering', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 149, 3), )

    
    bitSteering = property(__bitSteering.value, __bitSteering.set, None, 'Indicates whether bit steering should be used to map this interface onto a bus of different data width.\n\nValues are "on", "off" (defaults to "off").')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}endianness uses Python identifier endianness
    __endianness = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'endianness'), 'endianness', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014endianness', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 156, 3), )

    
    endianness = property(__endianness.value, __endianness.set, None, "'big': means the most significant element of any multi-element  data field is stored at the lowest memory address. 'little' means the least significant element of any multi-element data field is stored at the lowest memory address. If this element is not present the default is 'little' endian.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}master uses Python identifier master
    __master = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'master'), 'master', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014master', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 261, 3), )

    
    master = property(__master.value, __master.set, None, 'If this element is present, the bus interface can serve as a master.  This element encapsulates additional information related to its role as master.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}slave uses Python identifier slave
    __slave = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'slave'), 'slave', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014slave', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 291, 3), )

    
    slave = property(__slave.value, __slave.set, None, 'If this element is present, the bus interface can serve as a slave.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}system uses Python identifier system
    __system = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'system'), 'system', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014system', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 322, 3), )

    
    system = property(__system.value, __system.set, None, 'If this element is present, the bus interface is a system interface, neither master nor slave, with a specific function on the bus.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}mirroredSlave uses Python identifier mirroredSlave
    __mirroredSlave = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'mirroredSlave'), 'mirroredSlave', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014mirroredSlave', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 332, 3), )

    
    mirroredSlave = property(__mirroredSlave.value, __mirroredSlave.set, None, 'If this element is present, the bus interface represents a mirrored slave interface. All directional constraints on ports are reversed relative to the specification in the bus definition.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}mirroredMaster uses Python identifier mirroredMaster
    __mirroredMaster = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'mirroredMaster'), 'mirroredMaster', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014mirroredMaster', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 372, 3), )

    
    mirroredMaster = property(__mirroredMaster.value, __mirroredMaster.set, None, 'If this element is present, the bus interface represents a mirrored master interface. All directional constraints on ports are reversed relative to the specification in the bus definition.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}mirroredSystem uses Python identifier mirroredSystem
    __mirroredSystem = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'mirroredSystem'), 'mirroredSystem', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014mirroredSystem', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 378, 3), )

    
    mirroredSystem = property(__mirroredSystem.value, __mirroredSystem.set, None, 'If this element is present, the bus interface represents a mirrored system interface. All directional constraints on ports are reversed relative to the specification in the bus definition.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}monitor uses Python identifier monitor
    __monitor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'monitor'), 'monitor', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014monitor', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 388, 3), )

    
    monitor = property(__monitor.value, __monitor.set, None, 'Indicates that this is a (passive) monitor interface. All of the ports in the interface must be inputs. The type of interface to be monitored is specified with the required interfaceType attribute. The ipxact:group element must be specified if monitoring a system interface.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractionTypes uses Python identifier abstractionTypes
    __abstractionTypes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'abstractionTypes'), 'abstractionTypes', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014abstractionTypes', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 545, 1), )

    
    abstractionTypes = property(__abstractionTypes.value, __abstractionTypes.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_busInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        __bitsInLau.name() : __bitsInLau,
        __busType.name() : __busType,
        __connectionRequired.name() : __connectionRequired,
        __bitSteering.name() : __bitSteering,
        __endianness.name() : __endianness,
        __master.name() : __master,
        __slave.name() : __slave,
        __system.name() : __system,
        __mirroredSlave.name() : __mirroredSlave,
        __mirroredMaster.name() : __mirroredMaster,
        __mirroredSystem.name() : __mirroredSystem,
        __monitor.name() : __monitor,
        __abstractionTypes.name() : __abstractionTypes,
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'busInterfaceType', busInterfaceType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_21 (pyxb.binding.basis.complexTypeDefinition):
    """Lists all channel connections between mirror interfaces of this component."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 175, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}channel uses Python identifier channel
    __channel = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'channel'), 'channel', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_21_httpwww_accellera_orgXMLSchemaIPXACT1685_2014channel', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 177, 4), )

    
    channel = property(__channel.value, __channel.set, None, 'Defines a set of mirrored interfaces of this component that are connected to one another.')

    _ElementMap.update({
        __channel.name() : __channel
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_22 (pyxb.binding.basis.complexTypeDefinition):
    """Defines a set of mirrored interfaces of this component that are connected to one another."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 181, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}busInterfaceRef uses Python identifier busInterfaceRef
    __busInterfaceRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'busInterfaceRef'), 'busInterfaceRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_22_httpwww_accellera_orgXMLSchemaIPXACT1685_2014busInterfaceRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 185, 7), )

    
    busInterfaceRef = property(__busInterfaceRef.value, __busInterfaceRef.set, None, 'Contains the name of one of the bus interfaces that is part of this channel. The ordering of the references may be important to the design environment.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_22_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_22_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_22_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_22_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_22_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __busInterfaceRef.name() : __busInterfaceRef,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_23 (pyxb.binding.basis.complexTypeDefinition):
    """Contains the name of one of the bus interfaces that is part of this channel. The ordering of the references may be important to the design environment."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 189, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}localName uses Python identifier localName
    __localName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'localName'), 'localName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_23_httpwww_accellera_orgXMLSchemaIPXACT1685_2014localName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 191, 10), )

    
    localName = property(__localName.value, __localName.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_23_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_23_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __localName.name() : __localName,
        __isPresent.name() : __isPresent
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_24 (pyxb.binding.basis.complexTypeDefinition):
    """Contains a list of remap state names and associated port values"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 212, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}remapState uses Python identifier remapState
    __remapState = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'remapState'), 'remapState', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_24_httpwww_accellera_orgXMLSchemaIPXACT1685_2014remapState', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 214, 4), )

    
    remapState = property(__remapState.value, __remapState.set, None, 'Contains a list of ports and values in remapPort and a list of registers and values that when all evaluate to true which tell the decoder to enter this remap state. The name attribute identifies the name of the state. If a list of remapPorts and/or remapRegisters is not defined then the condition for that state cannot be defined.')

    _ElementMap.update({
        __remapState.name() : __remapState
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_25 (pyxb.binding.basis.complexTypeDefinition):
    """Contains a list of ports and values in remapPort and a list of registers and values that when all evaluate to true which tell the decoder to enter this remap state. The name attribute identifies the name of the state. If a list of remapPorts and/or remapRegisters is not defined then the condition for that state cannot be defined."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 218, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}remapPorts uses Python identifier remapPorts
    __remapPorts = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'remapPorts'), 'remapPorts', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_25_httpwww_accellera_orgXMLSchemaIPXACT1685_2014remapPorts', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 221, 7), )

    
    remapPorts = property(__remapPorts.value, __remapPorts.set, None, 'List of ports and their values that shall invoke this remap state.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_25_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_25_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_25_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    _ElementMap.update({
        __remapPorts.name() : __remapPorts,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_26 (pyxb.binding.basis.complexTypeDefinition):
    """List of ports and their values that shall invoke this remap state."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 225, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}remapPort uses Python identifier remapPort
    __remapPort = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'remapPort'), 'remapPort', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_26_httpwww_accellera_orgXMLSchemaIPXACT1685_2014remapPort', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 227, 10), )

    
    remapPort = property(__remapPort.value, __remapPort.set, None, 'Contains the name and value of a port on the component, the value indicates the logic value which this port must take to effect the remapping. The portMapRef attribute stores the name of the port which takes that value.')

    _ElementMap.update({
        __remapPort.name() : __remapPort
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_27 (pyxb.binding.basis.complexTypeDefinition):
    """If this element is present, the bus interface can serve as a master.  This element encapsulates additional information related to its role as master."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 265, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressSpaceRef uses Python identifier addressSpaceRef
    __addressSpaceRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressSpaceRef'), 'addressSpaceRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_27_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressSpaceRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 267, 6), )

    
    addressSpaceRef = property(__addressSpaceRef.value, __addressSpaceRef.set, None, 'If this master connects to an addressable bus, this element references the address space it maps to.')

    _ElementMap.update({
        __addressSpaceRef.name() : __addressSpaceRef
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_28 (pyxb.binding.basis.complexTypeDefinition):
    """If this element is present, the bus interface can serve as a slave."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 295, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileSetRefGroup uses Python identifier fileSetRefGroup
    __fileSetRefGroup = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'fileSetRefGroup'), 'fileSetRefGroup', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_28_httpwww_accellera_orgXMLSchemaIPXACT1685_2014fileSetRefGroup', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 301, 6), )

    
    fileSetRefGroup = property(__fileSetRefGroup.value, __fileSetRefGroup.set, None, 'This reference is used to point the filesets that are associated with this slave port.\n\nDepending on the slave port function, there may be completely different software drivers associated with the different ports. ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}transparentBridge uses Python identifier transparentBridge
    __transparentBridge = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'transparentBridge'), 'transparentBridge', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_28_httpwww_accellera_orgXMLSchemaIPXACT1685_2014transparentBridge', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 416, 1), )

    
    transparentBridge = property(__transparentBridge.value, __transparentBridge.set, None, 'If this element is present, it indicates that the bus interface provides a transparent bridge to another master bus interface on the same component.  It has a masterRef attribute which contains the name of the other bus interface.\n\nAny slave interface can bridge to multiple master interfaces, and multiple slave interfaces can bridge to the same master interface.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}memoryMapRef uses Python identifier memoryMapRef
    __memoryMapRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'memoryMapRef'), 'memoryMapRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_28_httpwww_accellera_orgXMLSchemaIPXACT1685_2014memoryMapRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 522, 1), )

    
    memoryMapRef = property(__memoryMapRef.value, __memoryMapRef.set, None, 'References the memory map. The name of the memory map is kept in its memoryMapRef attribute.')

    _ElementMap.update({
        __fileSetRefGroup.name() : __fileSetRefGroup,
        __transparentBridge.name() : __transparentBridge,
        __memoryMapRef.name() : __memoryMapRef
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_29 (pyxb.binding.basis.complexTypeDefinition):
    """This reference is used to point the filesets that are associated with this slave port.

Depending on the slave port function, there may be completely different software drivers associated with the different ports. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 307, 7)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'group'), 'group', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_29_httpwww_accellera_orgXMLSchemaIPXACT1685_2014group', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 309, 9), )

    
    group = property(__group.value, __group.set, None, 'Abritray name assigned to the collections of fileSets.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileSetRef uses Python identifier fileSetRef
    __fileSetRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'fileSetRef'), 'fileSetRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_29_httpwww_accellera_orgXMLSchemaIPXACT1685_2014fileSetRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 309, 4), )

    
    fileSetRef = property(__fileSetRef.value, __fileSetRef.set, None, 'A reference to a fileSet.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_29_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __group.name() : __group,
        __fileSetRef.name() : __fileSetRef
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_30 (pyxb.binding.basis.complexTypeDefinition):
    """If this element is present, the bus interface is a system interface, neither master nor slave, with a specific function on the bus."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 326, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'group'), 'group', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_30_httpwww_accellera_orgXMLSchemaIPXACT1685_2014group', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 166, 1), )

    
    group = property(__group.value, __group.set, None, 'Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.')

    _ElementMap.update({
        __group.name() : __group
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_31 (pyxb.binding.basis.complexTypeDefinition):
    """If this element is present, the bus interface represents a mirrored slave interface. All directional constraints on ports are reversed relative to the specification in the bus definition."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 336, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}baseAddresses uses Python identifier baseAddresses
    __baseAddresses = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'baseAddresses'), 'baseAddresses', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_31_httpwww_accellera_orgXMLSchemaIPXACT1685_2014baseAddresses', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 338, 6), )

    
    baseAddresses = property(__baseAddresses.value, __baseAddresses.set, None, 'Represents a set of remap base addresses.')

    _ElementMap.update({
        __baseAddresses.name() : __baseAddresses
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_32 (pyxb.binding.basis.complexTypeDefinition):
    """Represents a set of remap base addresses."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 342, 7)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}remapAddress uses Python identifier remapAddress
    __remapAddress = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'remapAddress'), 'remapAddress', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_32_httpwww_accellera_orgXMLSchemaIPXACT1685_2014remapAddress', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 344, 9), )

    
    remapAddress = property(__remapAddress.value, __remapAddress.set, None, 'Base of an address block, expressed as the number of bitsInLAU from the containing busInterface. The state attribute indicates the name of the remap state for which this address is valid.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}range uses Python identifier range
    __range = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'range'), 'range', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_32_httpwww_accellera_orgXMLSchemaIPXACT1685_2014range', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 361, 9), )

    
    range = property(__range.value, __range.set, None, 'The address range of mirrored slave, expressed as the number of bitsInLAU from the containing busInterface. ')

    _ElementMap.update({
        __remapAddress.name() : __remapAddress,
        __range.name() : __range
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type EMPTY
class CTD_ANON_33 (pyxb.binding.basis.complexTypeDefinition):
    """If this element is present, the bus interface represents a mirrored master interface. All directional constraints on ports are reversed relative to the specification in the bus definition."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 376, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_34 (pyxb.binding.basis.complexTypeDefinition):
    """If this element is present, the bus interface represents a mirrored system interface. All directional constraints on ports are reversed relative to the specification in the bus definition."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 382, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'group'), 'group', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_34_httpwww_accellera_orgXMLSchemaIPXACT1685_2014group', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 166, 1), )

    
    group = property(__group.value, __group.set, None, 'Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.')

    _ElementMap.update({
        __group.name() : __group
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_35 (pyxb.binding.basis.complexTypeDefinition):
    """If this element is present, it indicates that the bus interface provides a transparent bridge to another master bus interface on the same component.  It has a masterRef attribute which contains the name of the other bus interface.

Any slave interface can bridge to multiple master interfaces, and multiple slave interfaces can bridge to the same master interface."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 422, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_35_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_35_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute masterRef uses Python identifier masterRef
    __masterRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'masterRef'), 'masterRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_35_masterRef', pyxb.binding.datatypes.Name, required=True)
    __masterRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 426, 3)
    __masterRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 426, 3)
    
    masterRef = property(__masterRef.value, __masterRef.set, None, 'The name of the master bus interface to which this interface bridges.')

    _ElementMap.update({
        __isPresent.name() : __isPresent
    })
    _AttributeMap.update({
        __id.name() : __id,
        __masterRef.name() : __masterRef
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_36 (pyxb.binding.basis.complexTypeDefinition):
    """If this element is present, the bus interface is a system interface, neither master nor slave, with a specific function on the bus."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 453, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'group'), 'group', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_36_httpwww_accellera_orgXMLSchemaIPXACT1685_2014group', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 166, 1), )

    
    group = property(__group.value, __group.set, None, 'Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.')

    _ElementMap.update({
        __group.name() : __group
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_37 (pyxb.binding.basis.complexTypeDefinition):
    """If this element is present, the bus interface represents a mirrored system interface. All directional constraints on ports are reversed relative to the specification in the bus definition."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 473, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'group'), 'group', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_37_httpwww_accellera_orgXMLSchemaIPXACT1685_2014group', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 166, 1), )

    
    group = property(__group.value, __group.set, None, 'Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.')

    _ElementMap.update({
        __group.name() : __group
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractorBusInterfaceType with content type ELEMENT_ONLY
class abstractorBusInterfaceType (pyxb.binding.basis.complexTypeDefinition):
    """Type definition for a busInterface in a component"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'abstractorBusInterfaceType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 481, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractionTypes uses Python identifier abstractionTypes
    __abstractionTypes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'abstractionTypes'), 'abstractionTypes', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorBusInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014abstractionTypes', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 545, 1), )

    
    abstractionTypes = property(__abstractionTypes.value, __abstractionTypes.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorBusInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorBusInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorBusInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorBusInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorBusInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        __abstractionTypes.name() : __abstractionTypes,
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'abstractorBusInterfaceType', abstractorBusInterfaceType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_38 (pyxb.binding.basis.complexTypeDefinition):
    """A list of bus interfaces supported by this component."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 502, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}indirectInterface uses Python identifier indirectInterface
    __indirectInterface = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'indirectInterface'), 'indirectInterface', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_38_httpwww_accellera_orgXMLSchemaIPXACT1685_2014indirectInterface', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 493, 1), )

    
    indirectInterface = property(__indirectInterface.value, __indirectInterface.set, None, 'Describes one of the bus interfaces supported by this component.')

    _ElementMap.update({
        __indirectInterface.name() : __indirectInterface
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}indirectInterfaceType with content type ELEMENT_ONLY
class indirectInterfaceType (pyxb.binding.basis.complexTypeDefinition):
    """Type definition for a indirectInterface in a component"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'indirectInterfaceType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 508, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bitsInLau uses Python identifier bitsInLau
    __bitsInLau = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'bitsInLau'), 'bitsInLau', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indirectInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014bitsInLau', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 96, 1), )

    
    bitsInLau = property(__bitsInLau.value, __bitsInLau.set, None, 'The number of bits in the least addressable unit. The default is byte addressable (8 bits).')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}transparentBridge uses Python identifier transparentBridge
    __transparentBridge = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'transparentBridge'), 'transparentBridge', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indirectInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014transparentBridge', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 416, 1), )

    
    transparentBridge = property(__transparentBridge.value, __transparentBridge.set, None, 'If this element is present, it indicates that the bus interface provides a transparent bridge to another master bus interface on the same component.  It has a masterRef attribute which contains the name of the other bus interface.\n\nAny slave interface can bridge to multiple master interfaces, and multiple slave interfaces can bridge to the same master interface.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}memoryMapRef uses Python identifier memoryMapRef
    __memoryMapRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'memoryMapRef'), 'memoryMapRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indirectInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014memoryMapRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 517, 4), )

    
    memoryMapRef = property(__memoryMapRef.value, __memoryMapRef.set, None, 'A reference to a memoryMap. This memoryMap is indirectly accessible through this interface.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}endianness uses Python identifier endianness
    __endianness = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'endianness'), 'endianness', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indirectInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014endianness', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 525, 3), )

    
    endianness = property(__endianness.value, __endianness.set, None, "'big': means the most significant element of any multi-element  data field is stored at the lowest memory address. 'little' means the least significant element of any multi-element data field is stored at the lowest memory address. If this element is not present the default is 'little' endian.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}indirectAddressRef uses Python identifier indirectAddressRef
    __indirectAddressRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'indirectAddressRef'), 'indirectAddressRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indirectInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014indirectAddressRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 535, 1), )

    
    indirectAddressRef = property(__indirectAddressRef.value, __indirectAddressRef.set, None, 'A reference to a field used for addressing the indirectly accessible memoryMap.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}indirectDataRef uses Python identifier indirectDataRef
    __indirectDataRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'indirectDataRef'), 'indirectDataRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indirectInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014indirectDataRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 540, 1), )

    
    indirectDataRef = property(__indirectDataRef.value, __indirectDataRef.set, None, 'A reference to a field used for read/write access to the indirectly accessible memoryMap.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indirectInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indirectInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indirectInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indirectInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indirectInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=pyxb.binding.content.Wildcard.NC_any)
    _ElementMap.update({
        __bitsInLau.name() : __bitsInLau,
        __transparentBridge.name() : __transparentBridge,
        __memoryMapRef.name() : __memoryMapRef,
        __endianness.name() : __endianness,
        __indirectAddressRef.name() : __indirectAddressRef,
        __indirectDataRef.name() : __indirectDataRef,
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'indirectInterfaceType', indirectInterfaceType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_39 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 546, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractionType uses Python identifier abstractionType
    __abstractionType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'abstractionType'), 'abstractionType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_39_httpwww_accellera_orgXMLSchemaIPXACT1685_2014abstractionType', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 548, 4), )

    
    abstractionType = property(__abstractionType.value, __abstractionType.set, None, 'The abstraction type/level of this interface. Refers to abstraction definition using vendor, library, name, version attributes along with any configurable element values needed to configure this abstraction. Bus definition can be found through a reference in this file.')

    _ElementMap.update({
        __abstractionType.name() : __abstractionType
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_40 (pyxb.binding.basis.complexTypeDefinition):
    """The abstraction type/level of this interface. Refers to abstraction definition using vendor, library, name, version attributes along with any configurable element values needed to configure this abstraction. Bus definition can be found through a reference in this file."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 552, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}viewRef uses Python identifier viewRef
    __viewRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), 'viewRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_40_httpwww_accellera_orgXMLSchemaIPXACT1685_2014viewRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 101, 1), )

    
    viewRef = property(__viewRef.value, __viewRef.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractionRef uses Python identifier abstractionRef
    __abstractionRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'abstractionRef'), 'abstractionRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_40_httpwww_accellera_orgXMLSchemaIPXACT1685_2014abstractionRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 559, 7), )

    
    abstractionRef = property(__abstractionRef.value, __abstractionRef.set, None, 'Provides the VLNV of the abstraction type.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portMaps uses Python identifier portMaps
    __portMaps = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'portMaps'), 'portMaps', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_40_httpwww_accellera_orgXMLSchemaIPXACT1685_2014portMaps', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 564, 7), )

    
    portMaps = property(__portMaps.value, __portMaps.set, None, 'Listing of maps between component ports and bus ports.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_40_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __viewRef.name() : __viewRef,
        __abstractionRef.name() : __abstractionRef,
        __portMaps.name() : __portMaps
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_41 (pyxb.binding.basis.complexTypeDefinition):
    """Listing of maps between component ports and bus ports."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 568, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portMap uses Python identifier portMap
    __portMap = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'portMap'), 'portMap', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_41_httpwww_accellera_orgXMLSchemaIPXACT1685_2014portMap', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 570, 10), )

    
    portMap = property(__portMap.value, __portMap.set, None, "Maps a component's port to a port in a bus description. This is the logical to physical mapping. The logical pin comes from the bus interface and the physical pin from the component.")

    _ElementMap.update({
        __portMap.name() : __portMap
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_42 (pyxb.binding.basis.complexTypeDefinition):
    """Maps a component's port to a port in a bus description. This is the logical to physical mapping. The logical pin comes from the bus interface and the physical pin from the component."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 574, 11)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}logicalPort uses Python identifier logicalPort
    __logicalPort = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'logicalPort'), 'logicalPort', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_42_httpwww_accellera_orgXMLSchemaIPXACT1685_2014logicalPort', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 577, 13), )

    
    logicalPort = property(__logicalPort.value, __logicalPort.set, None, 'Logical port from abstraction definition')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}physicalPort uses Python identifier physicalPort
    __physicalPort = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'physicalPort'), 'physicalPort', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_42_httpwww_accellera_orgXMLSchemaIPXACT1685_2014physicalPort', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 593, 14), )

    
    physicalPort = property(__physicalPort.value, __physicalPort.set, None, 'Physical port from this component')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}logicalTieOff uses Python identifier logicalTieOff
    __logicalTieOff = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'logicalTieOff'), 'logicalTieOff', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_42_httpwww_accellera_orgXMLSchemaIPXACT1685_2014logicalTieOff', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 608, 14), )

    
    logicalTieOff = property(__logicalTieOff.value, __logicalTieOff.set, None, 'Identifies a value to tie this logical port to.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isInformative uses Python identifier isInformative
    __isInformative = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isInformative'), 'isInformative', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_42_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isInformative', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 614, 13), )

    
    isInformative = property(__isInformative.value, __isInformative.set, None, 'When true, indicates that this portMap element is for information purpose only.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_42_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_42_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute invert uses Python identifier invert
    __invert = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'invert'), 'invert', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_42_invert', pyxb.binding.datatypes.anySimpleType, unicode_default='false')
    __invert._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 621, 12)
    __invert._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 621, 12)
    
    invert = property(__invert.value, __invert.set, None, 'Indicates that the connection between the logical and physical ports should include an inversion.')

    _ElementMap.update({
        __logicalPort.name() : __logicalPort,
        __physicalPort.name() : __physicalPort,
        __logicalTieOff.name() : __logicalTieOff,
        __isInformative.name() : __isInformative,
        __isPresent.name() : __isPresent
    })
    _AttributeMap.update({
        __id.name() : __id,
        __invert.name() : __invert
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_43 (pyxb.binding.basis.complexTypeDefinition):
    """Logical port from abstraction definition"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 581, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_43_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 583, 16), )

    
    name = property(__name.value, __name.set, None, 'Bus port name as specified inside the abstraction definition')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}range uses Python identifier range
    __range = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'range'), 'range', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_43_httpwww_accellera_orgXMLSchemaIPXACT1685_2014range', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 549, 1), )

    
    range = property(__range.value, __range.set, None, 'Left and right bound of a reference into a vector.')

    _ElementMap.update({
        __name.name() : __name,
        __range.name() : __range
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_44 (pyxb.binding.basis.complexTypeDefinition):
    """Physical port from this component"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 597, 15)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_44_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 599, 17), )

    
    name = property(__name.value, __name.set, None, 'Component port name as specified inside the model port section')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}partSelect uses Python identifier partSelect
    __partSelect = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'partSelect'), 'partSelect', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_44_httpwww_accellera_orgXMLSchemaIPXACT1685_2014partSelect', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 560, 1), )

    
    partSelect = property(__partSelect.value, __partSelect.set, None, 'Bit range definition.')

    _ElementMap.update({
        __name.name() : __name,
        __partSelect.name() : __partSelect
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}ipxactFilesType with content type ELEMENT_ONLY
class ipxactFilesType (pyxb.binding.basis.complexTypeDefinition):
    """Contains a list of IP-XACT files to include."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ipxactFilesType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 57, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}ipxactFile uses Python identifier ipxactFile
    __ipxactFile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'ipxactFile'), 'ipxactFile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_ipxactFilesType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014ipxactFile', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 62, 3), )

    
    ipxactFile = property(__ipxactFile.value, __ipxactFile.set, None, None)

    _ElementMap.update({
        __ipxactFile.name() : __ipxactFile
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ipxactFilesType', ipxactFilesType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_45 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 78, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}catalogs uses Python identifier catalogs
    __catalogs = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'catalogs'), 'catalogs', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_45_httpwww_accellera_orgXMLSchemaIPXACT1685_2014catalogs', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 83, 5), )

    
    catalogs = property(__catalogs.value, __catalogs.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}busDefinitions uses Python identifier busDefinitions
    __busDefinitions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'busDefinitions'), 'busDefinitions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_45_httpwww_accellera_orgXMLSchemaIPXACT1685_2014busDefinitions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 86, 5), )

    
    busDefinitions = property(__busDefinitions.value, __busDefinitions.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractionDefinitions uses Python identifier abstractionDefinitions
    __abstractionDefinitions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'abstractionDefinitions'), 'abstractionDefinitions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_45_httpwww_accellera_orgXMLSchemaIPXACT1685_2014abstractionDefinitions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 89, 5), )

    
    abstractionDefinitions = property(__abstractionDefinitions.value, __abstractionDefinitions.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}components uses Python identifier components
    __components = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'components'), 'components', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_45_httpwww_accellera_orgXMLSchemaIPXACT1685_2014components', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 92, 5), )

    
    components = property(__components.value, __components.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractors uses Python identifier abstractors
    __abstractors = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'abstractors'), 'abstractors', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_45_httpwww_accellera_orgXMLSchemaIPXACT1685_2014abstractors', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 95, 5), )

    
    abstractors = property(__abstractors.value, __abstractors.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}designs uses Python identifier designs
    __designs = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'designs'), 'designs', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_45_httpwww_accellera_orgXMLSchemaIPXACT1685_2014designs', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 98, 5), )

    
    designs = property(__designs.value, __designs.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}designConfigurations uses Python identifier designConfigurations
    __designConfigurations = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'designConfigurations'), 'designConfigurations', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_45_httpwww_accellera_orgXMLSchemaIPXACT1685_2014designConfigurations', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 101, 5), )

    
    designConfigurations = property(__designConfigurations.value, __designConfigurations.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorChains uses Python identifier generatorChains
    __generatorChains = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'generatorChains'), 'generatorChains', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_45_httpwww_accellera_orgXMLSchemaIPXACT1685_2014generatorChains', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 104, 5), )

    
    generatorChains = property(__generatorChains.value, __generatorChains.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_45_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_45_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendor uses Python identifier vendor
    __vendor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendor'), 'vendor', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_45_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendor', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3), )

    
    vendor = property(__vendor.value, __vendor.set, None, 'Name of the vendor who supplies this file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}library uses Python identifier library
    __library = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'library'), 'library', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_45_httpwww_accellera_orgXMLSchemaIPXACT1685_2014library', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3), )

    
    library = property(__library.value, __library.set, None, 'Name of the logical library this element belongs to.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_45_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3), )

    
    name = property(__name.value, __name.set, None, 'The name of the object.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}version uses Python identifier version
    __version = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'version'), 'version', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_45_httpwww_accellera_orgXMLSchemaIPXACT1685_2014version', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3), )

    
    version = property(__version.value, __version.set, None, 'Indicates the version of the named element.')

    _ElementMap.update({
        __catalogs.name() : __catalogs,
        __busDefinitions.name() : __busDefinitions,
        __abstractionDefinitions.name() : __abstractionDefinitions,
        __components.name() : __components,
        __abstractors.name() : __abstractors,
        __designs.name() : __designs,
        __designConfigurations.name() : __designConfigurations,
        __generatorChains.name() : __generatorChains,
        __vendorExtensions.name() : __vendorExtensions,
        __description.name() : __description,
        __vendor.name() : __vendor,
        __library.name() : __library,
        __name.name() : __name,
        __version.name() : __version
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}ipxactFileType with content type ELEMENT_ONLY
class ipxactFileType (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}ipxactFileType with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ipxactFileType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 110, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vlnv uses Python identifier vlnv
    __vlnv = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vlnv'), 'vlnv', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_ipxactFileType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vlnv', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 112, 3), )

    
    vlnv = property(__vlnv.value, __vlnv.set, None, 'VLNV of the IP-XACT file being cataloged.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_ipxactFileType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 117, 3), )

    
    name = property(__name.value, __name.set, None, 'Name of the IP-XACT file being cataloged.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_ipxactFileType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_ipxactFileType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    _ElementMap.update({
        __vlnv.name() : __vlnv,
        __name.name() : __name,
        __vendorExtensions.name() : __vendorExtensions,
        __description.name() : __description
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ipxactFileType', ipxactFileType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_46 (pyxb.binding.basis.complexTypeDefinition):
    """Provides an expression for describing valid parameter value settings.  If a assertion assert expression evaluates false, the name, displayName and/or description can be used to communicate the assertion failure."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 90, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}assert uses Python identifier assert_
    __assert = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'assert'), 'assert_', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_46_httpwww_accellera_orgXMLSchemaIPXACT1685_2014assert', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 93, 4), )

    
    assert_ = property(__assert.value, __assert.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_46_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_46_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_46_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_46_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __assert.name() : __assert,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_47 (pyxb.binding.basis.complexTypeDefinition):
    """List of assertions about allowed parameter values."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 102, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}assertion uses Python identifier assertion
    __assertion = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'assertion'), 'assertion', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_47_httpwww_accellera_orgXMLSchemaIPXACT1685_2014assertion', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 86, 1), )

    
    assertion = property(__assertion.value, __assertion.set, None, 'Provides an expression for describing valid parameter value settings.  If a assertion assert expression evaluates false, the name, displayName and/or description can be used to communicate the assertion failure.')

    _ElementMap.update({
        __assertion.name() : __assertion
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_48 (pyxb.binding.basis.complexTypeDefinition):
    """A collection of parameters and associated value assertions."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 112, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameter uses Python identifier parameter
    __parameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameter'), 'parameter', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_48_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameter', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 81, 1), )

    
    parameter = property(__parameter.value, __parameter.set, None, 'A name value pair.  The name is specified by the name element.  The value is in the text content of the value element.  This value element supports all configurability attributes.')

    _ElementMap.update({
        __parameter.name() : __parameter
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_49 (pyxb.binding.basis.complexTypeDefinition):
    """Container for vendor specific extensions."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 122, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _HasWildcardElement = True
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}leafAccessHandle with content type ELEMENT_ONLY
class leafAccessHandle (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}leafAccessHandle with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'leafAccessHandle')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 146, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}viewRef uses Python identifier viewRef
    __viewRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), 'viewRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_leafAccessHandle_httpwww_accellera_orgXMLSchemaIPXACT1685_2014viewRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 148, 5), )

    
    viewRef = property(__viewRef.value, __viewRef.set, None, 'A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}indices uses Python identifier indices
    __indices = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'indices'), 'indices', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_leafAccessHandle_httpwww_accellera_orgXMLSchemaIPXACT1685_2014indices', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 160, 3), )

    
    indices = property(__indices.value, __indices.set, None, 'For a multi dimensional IP-XACT object, indices can be specified to select the element the accessHandle applies to. This is an index into a multi-dimensional array and follows C-semantics for indexing.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}slices uses Python identifier slices
    __slices = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'slices'), 'slices', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_leafAccessHandle_httpwww_accellera_orgXMLSchemaIPXACT1685_2014slices', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 174, 3), )

    
    slices = property(__slices.value, __slices.set, None, None)

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_leafAccessHandle_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute force uses Python identifier force
    __force = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'force'), 'force', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_leafAccessHandle_force', pyxb.binding.datatypes.boolean, unicode_default='true')
    __force._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 176, 2)
    __force._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 176, 2)
    
    force = property(__force.value, __force.set, None, None)

    _ElementMap.update({
        __viewRef.name() : __viewRef,
        __indices.name() : __indices,
        __slices.name() : __slices
    })
    _AttributeMap.update({
        __id.name() : __id,
        __force.name() : __force
    })
Namespace.addCategoryObject('typeBinding', 'leafAccessHandle', leafAccessHandle)


# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_50 (pyxb.binding.basis.complexTypeDefinition):
    """A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views."""
    _TypeDefinition = pyxb.binding.datatypes.Name
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 152, 6)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.Name
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_50_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_51 (pyxb.binding.basis.complexTypeDefinition):
    """For a multi dimensional IP-XACT object, indices can be specified to select the element the accessHandle applies to. This is an index into a multi-dimensional array and follows C-semantics for indexing."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 164, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}index uses Python identifier index
    __index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'index'), 'index', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_51_httpwww_accellera_orgXMLSchemaIPXACT1685_2014index', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 166, 6), )

    
    index = property(__index.value, __index.set, None, 'An index into the IP-XACT object.')

    _ElementMap.update({
        __index.name() : __index
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}nonIndexedLeafAccessHandle with content type ELEMENT_ONLY
class nonIndexedLeafAccessHandle (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}nonIndexedLeafAccessHandle with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'nonIndexedLeafAccessHandle')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 179, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}viewRef uses Python identifier viewRef
    __viewRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), 'viewRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_nonIndexedLeafAccessHandle_httpwww_accellera_orgXMLSchemaIPXACT1685_2014viewRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 181, 5), )

    
    viewRef = property(__viewRef.value, __viewRef.set, None, 'A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}slices uses Python identifier slices
    __slices = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'slices'), 'slices', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_nonIndexedLeafAccessHandle_httpwww_accellera_orgXMLSchemaIPXACT1685_2014slices', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 193, 3), )

    
    slices = property(__slices.value, __slices.set, None, None)

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_nonIndexedLeafAccessHandle_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute force uses Python identifier force
    __force = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'force'), 'force', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_nonIndexedLeafAccessHandle_force', pyxb.binding.datatypes.boolean, unicode_default='true')
    __force._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 195, 2)
    __force._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 195, 2)
    
    force = property(__force.value, __force.set, None, None)

    _ElementMap.update({
        __viewRef.name() : __viewRef,
        __slices.name() : __slices
    })
    _AttributeMap.update({
        __id.name() : __id,
        __force.name() : __force
    })
Namespace.addCategoryObject('typeBinding', 'nonIndexedLeafAccessHandle', nonIndexedLeafAccessHandle)


# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_52 (pyxb.binding.basis.complexTypeDefinition):
    """A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views."""
    _TypeDefinition = pyxb.binding.datatypes.Name
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 185, 6)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.Name
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_52_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}indexedAccessHandle with content type ELEMENT_ONLY
class indexedAccessHandle (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}indexedAccessHandle with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'indexedAccessHandle')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 198, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}viewRef uses Python identifier viewRef
    __viewRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), 'viewRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indexedAccessHandle_httpwww_accellera_orgXMLSchemaIPXACT1685_2014viewRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 200, 5), )

    
    viewRef = property(__viewRef.value, __viewRef.set, None, 'A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}indices uses Python identifier indices
    __indices = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'indices'), 'indices', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indexedAccessHandle_httpwww_accellera_orgXMLSchemaIPXACT1685_2014indices', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 212, 3), )

    
    indices = property(__indices.value, __indices.set, None, 'For a multi dimensional IP-XACT object, indices can be specified to select the element the accessHandle applies to. This is an index into a multi-dimensional array and follows C-semantics for indexing.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}pathSegments uses Python identifier pathSegments
    __pathSegments = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'pathSegments'), 'pathSegments', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indexedAccessHandle_httpwww_accellera_orgXMLSchemaIPXACT1685_2014pathSegments', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 226, 3), )

    
    pathSegments = property(__pathSegments.value, __pathSegments.set, None, 'An ordered list of pathSegment elements. When concatenated with a desired separator the elements in this form a HDL path for the parent slice into the referenced view.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indexedAccessHandle_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __viewRef.name() : __viewRef,
        __indices.name() : __indices,
        __pathSegments.name() : __pathSegments
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'indexedAccessHandle', indexedAccessHandle)


# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_53 (pyxb.binding.basis.complexTypeDefinition):
    """A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views."""
    _TypeDefinition = pyxb.binding.datatypes.Name
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 204, 6)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.Name
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_53_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_54 (pyxb.binding.basis.complexTypeDefinition):
    """For a multi dimensional IP-XACT object, indices can be specified to select the element the accessHandle applies to. This is an index into a multi-dimensional array and follows C-semantics for indexing."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 216, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}index uses Python identifier index
    __index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'index'), 'index', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_54_httpwww_accellera_orgXMLSchemaIPXACT1685_2014index', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 218, 6), )

    
    index = property(__index.value, __index.set, None, 'An index into the IP-XACT object.')

    _ElementMap.update({
        __index.name() : __index
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_55 (pyxb.binding.basis.complexTypeDefinition):
    """An ordered list of pathSegment elements. When concatenated with a desired separator the elements in this form a HDL path for the parent slice into the referenced view."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 230, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}pathSegment uses Python identifier pathSegment
    __pathSegment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'pathSegment'), 'pathSegment', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_55_httpwww_accellera_orgXMLSchemaIPXACT1685_2014pathSegment', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 232, 6), )

    
    pathSegment = property(__pathSegment.value, __pathSegment.set, None, None)

    _ElementMap.update({
        __pathSegment.name() : __pathSegment
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}simpleAccessHandle with content type ELEMENT_ONLY
class simpleAccessHandle (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}simpleAccessHandle with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'simpleAccessHandle')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 239, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}viewRef uses Python identifier viewRef
    __viewRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), 'viewRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_simpleAccessHandle_httpwww_accellera_orgXMLSchemaIPXACT1685_2014viewRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 241, 5), )

    
    viewRef = property(__viewRef.value, __viewRef.set, None, 'A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}pathSegments uses Python identifier pathSegments
    __pathSegments = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'pathSegments'), 'pathSegments', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_simpleAccessHandle_httpwww_accellera_orgXMLSchemaIPXACT1685_2014pathSegments', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 253, 3), )

    
    pathSegments = property(__pathSegments.value, __pathSegments.set, None, 'An ordered list of pathSegment elements. When concatenated with a desired separator the elements in this form a HDL path for the parent slice into the referenced view.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_simpleAccessHandle_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __viewRef.name() : __viewRef,
        __pathSegments.name() : __pathSegments
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'simpleAccessHandle', simpleAccessHandle)


# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_56 (pyxb.binding.basis.complexTypeDefinition):
    """A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views."""
    _TypeDefinition = pyxb.binding.datatypes.Name
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 245, 6)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.Name
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_56_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_57 (pyxb.binding.basis.complexTypeDefinition):
    """An ordered list of pathSegment elements. When concatenated with a desired separator the elements in this form a HDL path for the parent slice into the referenced view."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 257, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}pathSegment uses Python identifier pathSegment
    __pathSegment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'pathSegment'), 'pathSegment', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_57_httpwww_accellera_orgXMLSchemaIPXACT1685_2014pathSegment', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 259, 6), )

    
    pathSegment = property(__pathSegment.value, __pathSegment.set, None, None)

    _ElementMap.update({
        __pathSegment.name() : __pathSegment
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}slicesType with content type ELEMENT_ONLY
class slicesType (pyxb.binding.basis.complexTypeDefinition):
    """Each slice specifies the HDL path for part of the parent IP-XACT object. The slices must be concatenated to calculate the entire path. If there is only one slice, it is assumed to be the path for the entire IP-XACT object."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'slicesType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 266, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}slice uses Python identifier slice
    __slice = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'slice'), 'slice', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_slicesType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014slice', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 271, 3), )

    
    slice = property(__slice.value, __slice.set, None, 'The HDL path for a slice of the IP-XACT object.')

    _ElementMap.update({
        __slice.name() : __slice
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'slicesType', slicesType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}sliceType with content type ELEMENT_ONLY
class sliceType (pyxb.binding.basis.complexTypeDefinition):
    """Contains the HDL path information for a slice of the IP-XACT object. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'sliceType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 278, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}pathSegments uses Python identifier pathSegments
    __pathSegments = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'pathSegments'), 'pathSegments', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_sliceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014pathSegments', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 283, 3), )

    
    pathSegments = property(__pathSegments.value, __pathSegments.set, None, 'An ordered list of pathSegment elements. When concatenated with a desired separator the elements in this form a HDL path for the parent slice into the referenced view.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}range uses Python identifier range
    __range = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'range'), 'range', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_sliceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014range', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 549, 1), )

    
    range = property(__range.value, __range.set, None, 'Left and right bound of a reference into a vector.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_sliceType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __pathSegments.name() : __pathSegments,
        __range.name() : __range
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'sliceType', sliceType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_58 (pyxb.binding.basis.complexTypeDefinition):
    """An ordered list of pathSegment elements. When concatenated with a desired separator the elements in this form a HDL path for the parent slice into the referenced view."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 287, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}pathSegment uses Python identifier pathSegment
    __pathSegment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'pathSegment'), 'pathSegment', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_58_httpwww_accellera_orgXMLSchemaIPXACT1685_2014pathSegment', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 289, 6), )

    
    pathSegment = property(__pathSegment.value, __pathSegment.set, None, None)

    _ElementMap.update({
        __pathSegment.name() : __pathSegment
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}pathSegmentType with content type ELEMENT_ONLY
class pathSegmentType (pyxb.binding.basis.complexTypeDefinition):
    """Identifies one level of hierarchy in the view specifed by viewNameRef. This is a simple name and optionally some indices into a multi dimensional element."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'pathSegmentType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 301, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}pathSegmentName uses Python identifier pathSegmentName
    __pathSegmentName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'pathSegmentName'), 'pathSegmentName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_pathSegmentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014pathSegmentName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 306, 3), )

    
    pathSegmentName = property(__pathSegmentName.value, __pathSegmentName.set, None, 'One section of a HDL path')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}indices uses Python identifier indices
    __indices = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'indices'), 'indices', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_pathSegmentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014indices', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 311, 3), )

    
    indices = property(__indices.value, __indices.set, None, 'Specifies a multi-dimensional index into pathSegementName')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_pathSegmentType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __pathSegmentName.name() : __pathSegmentName,
        __indices.name() : __indices
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'pathSegmentType', pathSegmentType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}nameValuePairType with content type ELEMENT_ONLY
class nameValuePairType (pyxb.binding.basis.complexTypeDefinition):
    """Name and value type for use in resolvable elements"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'nameValuePairType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 517, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_nameValuePairType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}value uses Python identifier value_
    __value = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'value'), 'value_', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_nameValuePairType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014value', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 590, 1), )

    
    value_ = property(__value.value, __value.set, None, 'The value of the parameter.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_nameValuePairType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 600, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_nameValuePairType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_nameValuePairType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_nameValuePairType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __value.name() : __value,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'nameValuePairType', nameValuePairType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_59 (pyxb.binding.basis.complexTypeDefinition):
    """Left and right ranges of the vector."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 532, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}right uses Python identifier right
    __right = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'right'), 'right', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_59_httpwww_accellera_orgXMLSchemaIPXACT1685_2014right', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 319, 1), )

    
    right = property(__right.value, __right.set, None, 'The optional element right specifies the right boundary.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}left uses Python identifier left
    __left = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'left'), 'left', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_59_httpwww_accellera_orgXMLSchemaIPXACT1685_2014left', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 324, 1), )

    
    left = property(__left.value, __left.set, None, 'The optional element left specifies the left boundary.')

    _ElementMap.update({
        __right.name() : __right,
        __left.name() : __left
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_60 (pyxb.binding.basis.complexTypeDefinition):
    """Vectored information."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 543, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vector uses Python identifier vector
    __vector = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vector'), 'vector', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_60_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vector', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 528, 1), )

    
    vector = property(__vector.value, __vector.set, None, 'Left and right ranges of the vector.')

    _ElementMap.update({
        __vector.name() : __vector
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_61 (pyxb.binding.basis.complexTypeDefinition):
    """Left and right bound of a reference into a vector."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 553, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}right uses Python identifier right
    __right = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'right'), 'right', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_61_httpwww_accellera_orgXMLSchemaIPXACT1685_2014right', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 319, 1), )

    
    right = property(__right.value, __right.set, None, 'The optional element right specifies the right boundary.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}left uses Python identifier left
    __left = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'left'), 'left', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_61_httpwww_accellera_orgXMLSchemaIPXACT1685_2014left', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 324, 1), )

    
    left = property(__left.value, __left.set, None, 'The optional element left specifies the left boundary.')

    _ElementMap.update({
        __right.name() : __right,
        __left.name() : __left
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_62 (pyxb.binding.basis.complexTypeDefinition):
    """Bit range definition."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 564, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}range uses Python identifier range
    __range = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'range'), 'range', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_62_httpwww_accellera_orgXMLSchemaIPXACT1685_2014range', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 549, 1), )

    
    range = property(__range.value, __range.set, None, 'Left and right bound of a reference into a vector.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}indices uses Python identifier indices
    __indices = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'indices'), 'indices', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_62_httpwww_accellera_orgXMLSchemaIPXACT1685_2014indices', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 568, 5), )

    
    indices = property(__indices.value, __indices.set, None, None)

    _ElementMap.update({
        __range.name() : __range,
        __indices.name() : __indices
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}configurableArrays with content type ELEMENT_ONLY
class configurableArrays (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}configurableArrays with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'configurableArrays')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 574, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}array uses Python identifier array
    __array = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'array'), 'array', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_configurableArrays_httpwww_accellera_orgXMLSchemaIPXACT1685_2014array', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 576, 3), )

    
    array = property(__array.value, __array.set, None, 'Specific left and right array bounds.')

    _ElementMap.update({
        __array.name() : __array
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'configurableArrays', configurableArrays)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_63 (pyxb.binding.basis.complexTypeDefinition):
    """Specific left and right array bounds."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 580, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}right uses Python identifier right
    __right = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'right'), 'right', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_63_httpwww_accellera_orgXMLSchemaIPXACT1685_2014right', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 319, 1), )

    
    right = property(__right.value, __right.set, None, 'The optional element right specifies the right boundary.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}left uses Python identifier left
    __left = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'left'), 'left', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_63_httpwww_accellera_orgXMLSchemaIPXACT1685_2014left', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 324, 1), )

    
    left = property(__left.value, __left.set, None, 'The optional element left specifies the left boundary.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_63_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __right.name() : __right,
        __left.name() : __left
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}indicesType with content type ELEMENT_ONLY
class indicesType (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}indicesType with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'indicesType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 629, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}index uses Python identifier index
    __index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'index'), 'index', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_indicesType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014index', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 631, 3), )

    
    index = property(__index.value, __index.set, None, 'An index into an object in the referenced view.')

    _ElementMap.update({
        __index.name() : __index
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'indicesType', indicesType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}componentType with content type ELEMENT_ONLY
class componentType (pyxb.binding.basis.complexTypeDefinition):
    """Component-specific extension to componentType"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'componentType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 58, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}choices uses Python identifier choices
    __choices = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'choices'), 'choices', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014choices', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 95, 1), )

    
    choices = property(__choices.value, __choices.set, None, 'Choices used by elements with an attribute ipxact:choiceRef.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}busInterfaces uses Python identifier busInterfaces
    __busInterfaces = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'busInterfaces'), 'busInterfaces', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014busInterfaces', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 115, 1), )

    
    busInterfaces = property(__busInterfaces.value, __busInterfaces.set, None, 'A list of bus interfaces supported by this component.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}channels uses Python identifier channels
    __channels = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'channels'), 'channels', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014channels', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 171, 1), )

    
    channels = property(__channels.value, __channels.set, None, 'Lists all channel connections between mirror interfaces of this component.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}remapStates uses Python identifier remapStates
    __remapStates = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'remapStates'), 'remapStates', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014remapStates', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 208, 1), )

    
    remapStates = property(__remapStates.value, __remapStates.set, None, 'Contains a list of remap state names and associated port values')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}indirectInterfaces uses Python identifier indirectInterfaces
    __indirectInterfaces = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'indirectInterfaces'), 'indirectInterfaces', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014indirectInterfaces', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 498, 1), )

    
    indirectInterfaces = property(__indirectInterfaces.value, __indirectInterfaces.set, None, 'A list of bus interfaces supported by this component.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}assertions uses Python identifier assertions
    __assertions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'assertions'), 'assertions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014assertions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1), )

    
    assertions = property(__assertions.value, __assertions.set, None, 'List of assertions about allowed parameter values.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}whiteboxElements uses Python identifier whiteboxElements
    __whiteboxElements = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'whiteboxElements'), 'whiteboxElements', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014whiteboxElements', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 78, 3), )

    
    whiteboxElements = property(__whiteboxElements.value, __whiteboxElements.set, None, 'A list of whiteboxElements')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}cpus uses Python identifier cpus
    __cpus = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'cpus'), 'cpus', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014cpus', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 92, 3), )

    
    cpus = property(__cpus.value, __cpus.set, None, "cpu's in the component")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}otherClockDrivers uses Python identifier otherClockDrivers
    __otherClockDrivers = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'otherClockDrivers'), 'otherClockDrivers', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014otherClockDrivers', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 128, 3), )

    
    otherClockDrivers = property(__otherClockDrivers.value, __otherClockDrivers.set, None, 'Defines a set of clock drivers that are not directly associated with an input port of the component.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}resetTypes uses Python identifier resetTypes
    __resetTypes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'resetTypes'), 'resetTypes', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014resetTypes', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 133, 3), )

    
    resetTypes = property(__resetTypes.value, __resetTypes.set, None, 'A list of user defined resetTypes applicable to this component.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileSets uses Python identifier fileSets
    __fileSets = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'fileSets'), 'fileSets', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014fileSets', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 337, 4), )

    
    fileSets = property(__fileSets.value, __fileSets.set, None, 'List of file sets associated with component.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}componentGenerators uses Python identifier componentGenerators
    __componentGenerators = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'componentGenerators'), 'componentGenerators', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014componentGenerators', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 209, 1), )

    
    componentGenerators = property(__componentGenerators.value, __componentGenerators.set, None, 'List of component generators.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendor uses Python identifier vendor
    __vendor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendor'), 'vendor', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendor', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3), )

    
    vendor = property(__vendor.value, __vendor.set, None, 'Name of the vendor who supplies this file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}library uses Python identifier library
    __library = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'library'), 'library', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014library', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3), )

    
    library = property(__library.value, __library.set, None, 'Name of the logical library this element belongs to.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3), )

    
    name = property(__name.value, __name.set, None, 'The name of the object.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}version uses Python identifier version
    __version = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'version'), 'version', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014version', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3), )

    
    version = property(__version.value, __version.set, None, 'Indicates the version of the named element.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressSpaces uses Python identifier addressSpaces
    __addressSpaces = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressSpaces'), 'addressSpaces', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressSpaces', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 446, 1), )

    
    addressSpaces = property(__addressSpaces.value, __addressSpaces.set, None, 'If this component is a bus master, this lists all the address spaces\ndefined by the component.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}memoryMaps uses Python identifier memoryMaps
    __memoryMaps = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'memoryMaps'), 'memoryMaps', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014memoryMaps', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 527, 1), )

    
    memoryMaps = property(__memoryMaps.value, __memoryMaps.set, None, 'Lists all the slave memory maps defined by the component.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}model uses Python identifier model
    __model = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'model'), 'model', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014model', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 327, 1), )

    
    model = property(__model.value, __model.set, None, 'Model information.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __choices.name() : __choices,
        __busInterfaces.name() : __busInterfaces,
        __channels.name() : __channels,
        __remapStates.name() : __remapStates,
        __indirectInterfaces.name() : __indirectInterfaces,
        __assertions.name() : __assertions,
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __description.name() : __description,
        __whiteboxElements.name() : __whiteboxElements,
        __cpus.name() : __cpus,
        __otherClockDrivers.name() : __otherClockDrivers,
        __resetTypes.name() : __resetTypes,
        __fileSets.name() : __fileSets,
        __componentGenerators.name() : __componentGenerators,
        __vendor.name() : __vendor,
        __library.name() : __library,
        __name.name() : __name,
        __version.name() : __version,
        __addressSpaces.name() : __addressSpaces,
        __memoryMaps.name() : __memoryMaps,
        __model.name() : __model
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'componentType', componentType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_64 (pyxb.binding.basis.complexTypeDefinition):
    """A list of whiteboxElements"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 82, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}whiteboxElement uses Python identifier whiteboxElement
    __whiteboxElement = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'whiteboxElement'), 'whiteboxElement', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_64_httpwww_accellera_orgXMLSchemaIPXACT1685_2014whiteboxElement', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 84, 6), )

    
    whiteboxElement = property(__whiteboxElement.value, __whiteboxElement.set, None, 'A whiteboxElement is a useful way to identify elements of a component that can not be identified through other means such as internal signals and non-software accessible registers.')

    _ElementMap.update({
        __whiteboxElement.name() : __whiteboxElement
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_65 (pyxb.binding.basis.complexTypeDefinition):
    """cpu's in the component"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 96, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}cpu uses Python identifier cpu
    __cpu = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'cpu'), 'cpu', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_65_httpwww_accellera_orgXMLSchemaIPXACT1685_2014cpu', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 98, 6), )

    
    cpu = property(__cpu.value, __cpu.set, None, 'Describes a processor in this component.')

    _ElementMap.update({
        __cpu.name() : __cpu
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_66 (pyxb.binding.basis.complexTypeDefinition):
    """Describes a processor in this component."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 102, 7)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_66_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_66_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_66_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_66_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_66_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_66_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressSpaceRef uses Python identifier addressSpaceRef
    __addressSpaceRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressSpaceRef'), 'addressSpaceRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_66_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressSpaceRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 441, 1), )

    
    addressSpaceRef = property(__addressSpaceRef.value, __addressSpaceRef.set, None, 'References the address space.  The name of the address space is kept in its addressSpaceRef attribute.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_66_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __addressSpaceRef.name() : __addressSpaceRef
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_67 (pyxb.binding.basis.complexTypeDefinition):
    """A list of user defined resetTypes applicable to this component."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 137, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}resetType uses Python identifier resetType
    __resetType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'resetType'), 'resetType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_67_httpwww_accellera_orgXMLSchemaIPXACT1685_2014resetType', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 139, 6), )

    
    resetType = property(__resetType.value, __resetType.set, None, 'A user defined reset policy')

    _ElementMap.update({
        __resetType.name() : __resetType
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_68 (pyxb.binding.basis.complexTypeDefinition):
    """A user defined reset policy"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 143, 7)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_68_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_68_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_68_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_68_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_68_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}whiteboxElementType with content type ELEMENT_ONLY
class whiteboxElementType (pyxb.binding.basis.complexTypeDefinition):
    """Defines a white box reference point within the component."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'whiteboxElementType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 317, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_whiteboxElementType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_whiteboxElementType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_whiteboxElementType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_whiteboxElementType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_whiteboxElementType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_whiteboxElementType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}whiteboxType uses Python identifier whiteboxType
    __whiteboxType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'whiteboxType'), 'whiteboxType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_whiteboxElementType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014whiteboxType', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 324, 3), )

    
    whiteboxType = property(__whiteboxType.value, __whiteboxType.set, None, 'Indicates the type of the element. The pin and signal types refer to elements within the HDL description. The register type refers to a register in the memory map. The interface type refers to a group of signals addressed as a single unit.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}driveable uses Python identifier driveable
    __driveable = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'driveable'), 'driveable', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_whiteboxElementType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014driveable', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 329, 3), )

    
    driveable = property(__driveable.value, __driveable.set, None, 'If true, indicates that the white box element can be driven (e.g. have a new value forced into it).')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_whiteboxElementType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __whiteboxType.name() : __whiteboxType,
        __driveable.name() : __driveable
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'whiteboxElementType', whiteboxElementType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}otherClocks with content type ELEMENT_ONLY
class otherClocks (pyxb.binding.basis.complexTypeDefinition):
    """List of clocks associated with the component that are not associated with ports. Set the clockSource attribute on the clockDriver to indicate the source of a clock not associated with a particular component port."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'otherClocks')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 129, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}otherClockDriver uses Python identifier otherClockDriver
    __otherClockDriver = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'otherClockDriver'), 'otherClockDriver', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_otherClocks_httpwww_accellera_orgXMLSchemaIPXACT1685_2014otherClockDriver', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 215, 1), )

    
    otherClockDriver = property(__otherClockDriver.value, __otherClockDriver.set, None, 'Describes a clock not directly associated with an input port. The clockSource attribute can be used on these clocks to indicate the actual clock source (e.g. an output port of a clock generator cell).')

    _ElementMap.update({
        __otherClockDriver.name() : __otherClockDriver
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'otherClocks', otherClocks)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_69 (pyxb.binding.basis.complexTypeDefinition):
    """Defines a constraint indicating how an input is to be driven. The preferred methodology is to specify a library cell in technology independent fashion. The implemention tool should assume that the associated port is driven by the specified cell, or that the drive strength of the input port is indicated by the specified resistance value."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 200, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}cellSpecification uses Python identifier cellSpecification
    __cellSpecification = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'cellSpecification'), 'cellSpecification', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_69_httpwww_accellera_orgXMLSchemaIPXACT1685_2014cellSpecification', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 138, 4), )

    
    cellSpecification = property(__cellSpecification.value, __cellSpecification.set, None, 'Used to provide a generic description of a technology library cell.')

    _ElementMap.update({
        __cellSpecification.name() : __cellSpecification
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_70 (pyxb.binding.basis.complexTypeDefinition):
    """Defines a constraint indicating the type of load on an output port."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 210, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}cellSpecification uses Python identifier cellSpecification
    __cellSpecification = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'cellSpecification'), 'cellSpecification', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_70_httpwww_accellera_orgXMLSchemaIPXACT1685_2014cellSpecification', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 138, 4), )

    
    cellSpecification = property(__cellSpecification.value, __cellSpecification.set, None, 'Used to provide a generic description of a technology library cell.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}count uses Python identifier count
    __count = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'count'), 'count', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_70_httpwww_accellera_orgXMLSchemaIPXACT1685_2014count', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 213, 16), )

    
    count = property(__count.value, __count.set, None, 'Indicates how many loads of the specified cell are connected. If not present, 3 is assumed.')

    _ElementMap.update({
        __cellSpecification.name() : __cellSpecification,
        __count.name() : __count
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_71 (pyxb.binding.basis.complexTypeDefinition):
    """Defines constraints that apply to a component port. If multiple constraintSet elements are used, each must have a unique value for the constraintSetId attribute."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 225, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_71_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 334, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_71_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_71_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}timingConstraint uses Python identifier timingConstraint
    __timingConstraint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'timingConstraint'), 'timingConstraint', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_71_httpwww_accellera_orgXMLSchemaIPXACT1685_2014timingConstraint', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 169, 4), )

    
    timingConstraint = property(__timingConstraint.value, __timingConstraint.set, None, 'Defines a timing constraint for the associated port. The constraint is relative to the clock specified by the clockName attribute. The clockEdge indicates which clock edge the constraint is associated with (default is rising edge). The delayType attribute can be specified to further refine the constraint.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}driveConstraint uses Python identifier driveConstraint
    __driveConstraint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'driveConstraint'), 'driveConstraint', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_71_httpwww_accellera_orgXMLSchemaIPXACT1685_2014driveConstraint', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 196, 4), )

    
    driveConstraint = property(__driveConstraint.value, __driveConstraint.set, None, 'Defines a constraint indicating how an input is to be driven. The preferred methodology is to specify a library cell in technology independent fashion. The implemention tool should assume that the associated port is driven by the specified cell, or that the drive strength of the input port is indicated by the specified resistance value.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}loadConstraint uses Python identifier loadConstraint
    __loadConstraint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'loadConstraint'), 'loadConstraint', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_71_httpwww_accellera_orgXMLSchemaIPXACT1685_2014loadConstraint', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 206, 4), )

    
    loadConstraint = property(__loadConstraint.value, __loadConstraint.set, None, 'Defines a constraint indicating the type of load on an output port.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vector uses Python identifier vector
    __vector = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vector'), 'vector', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_71_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vector', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 228, 16), )

    
    vector = property(__vector.value, __vector.set, None, 'The optional element vector specify the bits of a vector for which the constraints apply. The vaules of left and right must be within the range of the port. If the vector is not specified then the constraints apply to all the bits of the port.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_71_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute constraintSetId uses Python identifier constraintSetId
    __constraintSetId = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'constraintSetId'), 'constraintSetId', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_71_constraintSetId', pyxb.binding.datatypes.NMTOKEN, unicode_default='default')
    __constraintSetId._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 251, 12)
    __constraintSetId._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 251, 12)
    
    constraintSetId = property(__constraintSetId.value, __constraintSetId.set, None, 'Indicates a name for this set of constraints. Constraints are tied to a view using this name in the constraintSetRef element.')

    _ElementMap.update({
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __timingConstraint.name() : __timingConstraint,
        __driveConstraint.name() : __driveConstraint,
        __loadConstraint.name() : __loadConstraint,
        __vector.name() : __vector
    })
    _AttributeMap.update({
        __id.name() : __id,
        __constraintSetId.name() : __constraintSetId
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_72 (pyxb.binding.basis.complexTypeDefinition):
    """The optional element vector specify the bits of a vector for which the constraints apply. The vaules of left and right must be within the range of the port. If the vector is not specified then the constraints apply to all the bits of the port."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 232, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}left uses Python identifier left
    __left = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'left'), 'left', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_72_httpwww_accellera_orgXMLSchemaIPXACT1685_2014left', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 234, 28), )

    
    left = property(__left.value, __left.set, None, 'The optional elements left and right can be used to select a bit-slice of a vector. ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}right uses Python identifier right
    __right = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'right'), 'right', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_72_httpwww_accellera_orgXMLSchemaIPXACT1685_2014right', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 239, 28), )

    
    right = property(__right.value, __right.set, None, 'The optional elements left and right can be used to select a bit-slice of a vector. ')

    _ElementMap.update({
        __left.name() : __left,
        __right.name() : __right
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_73 (pyxb.binding.basis.complexTypeDefinition):
    """List of constraintSet elements for a component port."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 263, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}constraintSet uses Python identifier constraintSet
    __constraintSet = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'constraintSet'), 'constraintSet', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_73_httpwww_accellera_orgXMLSchemaIPXACT1685_2014constraintSet', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 221, 4), )

    
    constraintSet = property(__constraintSet.value, __constraintSet.set, None, 'Defines constraints that apply to a component port. If multiple constraintSet elements are used, each must have a unique value for the constraintSetId attribute.')

    _ElementMap.update({
        __constraintSet.name() : __constraintSet
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_74 (pyxb.binding.basis.complexTypeDefinition):
    """A reference to a set of port constraints."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 273, 7)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_74_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}localName uses Python identifier localName
    __localName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'localName'), 'localName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_74_httpwww_accellera_orgXMLSchemaIPXACT1685_2014localName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 275, 12), )

    
    localName = property(__localName.value, __localName.set, None, None)

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_74_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __isPresent.name() : __isPresent,
        __localName.name() : __localName
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractionDefPortConstraintsType with content type ELEMENT_ONLY
class abstractionDefPortConstraintsType (pyxb.binding.basis.complexTypeDefinition):
    """Defines constraints that apply to a wire type port in an abstraction definition. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'abstractionDefPortConstraintsType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 281, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}timingConstraint uses Python identifier timingConstraint
    __timingConstraint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'timingConstraint'), 'timingConstraint', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractionDefPortConstraintsType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014timingConstraint', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 169, 4), )

    
    timingConstraint = property(__timingConstraint.value, __timingConstraint.set, None, 'Defines a timing constraint for the associated port. The constraint is relative to the clock specified by the clockName attribute. The clockEdge indicates which clock edge the constraint is associated with (default is rising edge). The delayType attribute can be specified to further refine the constraint.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}driveConstraint uses Python identifier driveConstraint
    __driveConstraint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'driveConstraint'), 'driveConstraint', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractionDefPortConstraintsType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014driveConstraint', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 196, 4), )

    
    driveConstraint = property(__driveConstraint.value, __driveConstraint.set, None, 'Defines a constraint indicating how an input is to be driven. The preferred methodology is to specify a library cell in technology independent fashion. The implemention tool should assume that the associated port is driven by the specified cell, or that the drive strength of the input port is indicated by the specified resistance value.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}loadConstraint uses Python identifier loadConstraint
    __loadConstraint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'loadConstraint'), 'loadConstraint', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractionDefPortConstraintsType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014loadConstraint', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 206, 4), )

    
    loadConstraint = property(__loadConstraint.value, __loadConstraint.set, None, 'Defines a constraint indicating the type of load on an output port.')

    _ElementMap.update({
        __timingConstraint.name() : __timingConstraint,
        __driveConstraint.name() : __driveConstraint,
        __loadConstraint.name() : __loadConstraint
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'abstractionDefPortConstraintsType', abstractionDefPortConstraintsType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_75 (pyxb.binding.basis.complexTypeDefinition):
    """Root element for a platform design."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 59, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}assertions uses Python identifier assertions
    __assertions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'assertions'), 'assertions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_75_httpwww_accellera_orgXMLSchemaIPXACT1685_2014assertions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1), )

    
    assertions = property(__assertions.value, __assertions.set, None, 'List of assertions about allowed parameter values.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_75_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_75_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_75_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendor uses Python identifier vendor
    __vendor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendor'), 'vendor', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_75_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendor', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3), )

    
    vendor = property(__vendor.value, __vendor.set, None, 'Name of the vendor who supplies this file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}library uses Python identifier library
    __library = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'library'), 'library', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_75_httpwww_accellera_orgXMLSchemaIPXACT1685_2014library', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3), )

    
    library = property(__library.value, __library.set, None, 'Name of the logical library this element belongs to.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_75_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3), )

    
    name = property(__name.value, __name.set, None, 'The name of the object.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}version uses Python identifier version
    __version = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'version'), 'version', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_75_httpwww_accellera_orgXMLSchemaIPXACT1685_2014version', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3), )

    
    version = property(__version.value, __version.set, None, 'Indicates the version of the named element.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}componentInstances uses Python identifier componentInstances
    __componentInstances = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'componentInstances'), 'componentInstances', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_75_httpwww_accellera_orgXMLSchemaIPXACT1685_2014componentInstances', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 148, 1), )

    
    componentInstances = property(__componentInstances.value, __componentInstances.set, None, 'Sub instances of internal components.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}adHocConnections uses Python identifier adHocConnections
    __adHocConnections = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'adHocConnections'), 'adHocConnections', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_75_httpwww_accellera_orgXMLSchemaIPXACT1685_2014adHocConnections', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 211, 1), )

    
    adHocConnections = property(__adHocConnections.value, __adHocConnections.set, None, 'Defines the set of ad-hoc connections in a design. An ad-hoc connection represents a connection between two component pins which were not connected as a result of interface connections (i.e.the pin to pin connection was made explicitly and is represented explicitly).')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interconnections uses Python identifier interconnections
    __interconnections = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'interconnections'), 'interconnections', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_75_httpwww_accellera_orgXMLSchemaIPXACT1685_2014interconnections', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 298, 1), )

    
    interconnections = property(__interconnections.value, __interconnections.set, None, 'Connections between internal sub components.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_75_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __assertions.name() : __assertions,
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __description.name() : __description,
        __vendor.name() : __vendor,
        __library.name() : __library,
        __name.name() : __name,
        __version.name() : __version,
        __componentInstances.name() : __componentInstances,
        __adHocConnections.name() : __adHocConnections,
        __interconnections.name() : __interconnections
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_76 (pyxb.binding.basis.complexTypeDefinition):
    """Top level element for describing the current configuration of a design. Does not describe instance parameterization"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 59, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}assertions uses Python identifier assertions
    __assertions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'assertions'), 'assertions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_76_httpwww_accellera_orgXMLSchemaIPXACT1685_2014assertions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1), )

    
    assertions = property(__assertions.value, __assertions.set, None, 'List of assertions about allowed parameter values.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_76_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_76_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_76_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}designRef uses Python identifier designRef
    __designRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'designRef'), 'designRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_76_httpwww_accellera_orgXMLSchemaIPXACT1685_2014designRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 62, 4), )

    
    designRef = property(__designRef.value, __designRef.set, None, 'The design to which this configuration applies')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorChainConfiguration uses Python identifier generatorChainConfiguration
    __generatorChainConfiguration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'generatorChainConfiguration'), 'generatorChainConfiguration', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_76_httpwww_accellera_orgXMLSchemaIPXACT1685_2014generatorChainConfiguration', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 67, 4), )

    
    generatorChainConfiguration = property(__generatorChainConfiguration.value, __generatorChainConfiguration.set, None, 'Contains the configurable information associated with a generatorChain and its generators. Note that configurable information for generators associated with components is stored in the design file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interconnectionConfiguration uses Python identifier interconnectionConfiguration
    __interconnectionConfiguration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'interconnectionConfiguration'), 'interconnectionConfiguration', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_76_httpwww_accellera_orgXMLSchemaIPXACT1685_2014interconnectionConfiguration', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 72, 4), )

    
    interconnectionConfiguration = property(__interconnectionConfiguration.value, __interconnectionConfiguration.set, None, 'Contains the information about the abstractors required to cross between two interfaces at with different abstractionDefs.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}viewConfiguration uses Python identifier viewConfiguration
    __viewConfiguration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'viewConfiguration'), 'viewConfiguration', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_76_httpwww_accellera_orgXMLSchemaIPXACT1685_2014viewConfiguration', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 145, 4), )

    
    viewConfiguration = property(__viewConfiguration.value, __viewConfiguration.set, None, 'Contains the active views for each instance in the design')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendor uses Python identifier vendor
    __vendor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendor'), 'vendor', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_76_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendor', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3), )

    
    vendor = property(__vendor.value, __vendor.set, None, 'Name of the vendor who supplies this file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}library uses Python identifier library
    __library = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'library'), 'library', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_76_httpwww_accellera_orgXMLSchemaIPXACT1685_2014library', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3), )

    
    library = property(__library.value, __library.set, None, 'Name of the logical library this element belongs to.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_76_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3), )

    
    name = property(__name.value, __name.set, None, 'The name of the object.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}version uses Python identifier version
    __version = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'version'), 'version', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_76_httpwww_accellera_orgXMLSchemaIPXACT1685_2014version', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3), )

    
    version = property(__version.value, __version.set, None, 'Indicates the version of the named element.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_76_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __assertions.name() : __assertions,
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __description.name() : __description,
        __designRef.name() : __designRef,
        __generatorChainConfiguration.name() : __generatorChainConfiguration,
        __interconnectionConfiguration.name() : __interconnectionConfiguration,
        __viewConfiguration.name() : __viewConfiguration,
        __vendor.name() : __vendor,
        __library.name() : __library,
        __name.name() : __name,
        __version.name() : __version
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_77 (pyxb.binding.basis.complexTypeDefinition):
    """Contains the information about the abstractors required to cross between two interfaces at with different abstractionDefs."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 76, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_77_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interconnectionRef uses Python identifier interconnectionRef
    __interconnectionRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'interconnectionRef'), 'interconnectionRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_77_httpwww_accellera_orgXMLSchemaIPXACT1685_2014interconnectionRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 79, 7), )

    
    interconnectionRef = property(__interconnectionRef.value, __interconnectionRef.set, None, 'Reference to the interconnection name, monitor interconnection name or possibly a hierConnection interfaceName in a design file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractorInstances uses Python identifier abstractorInstances
    __abstractorInstances = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'abstractorInstances'), 'abstractorInstances', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_77_httpwww_accellera_orgXMLSchemaIPXACT1685_2014abstractorInstances', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 84, 7), )

    
    abstractorInstances = property(__abstractorInstances.value, __abstractorInstances.set, None, "List of abstractor-instances for this interconnection. Multiple abstractor-instances elements may be present for a 1-to-many (broadcast) interconnection. In that case, the optional interfaceRef elements must reference non-overlapping interfaces from the 'many' side of the interconnection.")

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_77_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __isPresent.name() : __isPresent,
        __interconnectionRef.name() : __interconnectionRef,
        __abstractorInstances.name() : __abstractorInstances
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_78 (pyxb.binding.basis.complexTypeDefinition):
    """List of abstractor-instances for this interconnection. Multiple abstractor-instances elements may be present for a 1-to-many (broadcast) interconnection. In that case, the optional interfaceRef elements must reference non-overlapping interfaces from the 'many' side of the interconnection."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 88, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_78_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interfaceRef uses Python identifier interfaceRef
    __interfaceRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'interfaceRef'), 'interfaceRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_78_httpwww_accellera_orgXMLSchemaIPXACT1685_2014interfaceRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 91, 10), )

    
    interfaceRef = property(__interfaceRef.value, __interfaceRef.set, None, 'Defines the broadcast endpoint to which this chain of abstractors applies.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractorInstance uses Python identifier abstractorInstance
    __abstractorInstance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'abstractorInstance'), 'abstractorInstance', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_78_httpwww_accellera_orgXMLSchemaIPXACT1685_2014abstractorInstance', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 111, 10), )

    
    abstractorInstance = property(__abstractorInstance.value, __abstractorInstance.set, None, 'Element to hold a the abstractor reference, the configuration and viewName. If multiple elements are present then the order is the order in which the abstractors should be chained together.')

    _ElementMap.update({
        __isPresent.name() : __isPresent,
        __interfaceRef.name() : __interfaceRef,
        __abstractorInstance.name() : __abstractorInstance
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_79 (pyxb.binding.basis.complexTypeDefinition):
    """Defines the broadcast endpoint to which this chain of abstractors applies."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 95, 11)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_79_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Attribute componentRef uses Python identifier componentRef
    __componentRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'componentRef'), 'componentRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_79_componentRef', pyxb.binding.datatypes.Name, required=True)
    __componentRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 99, 12)
    __componentRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 99, 12)
    
    componentRef = property(__componentRef.value, __componentRef.set, None, 'Reference to a component instance nane.')

    
    # Attribute busRef uses Python identifier busRef
    __busRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'busRef'), 'busRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_79_busRef', pyxb.binding.datatypes.Name, required=True)
    __busRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 104, 12)
    __busRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 104, 12)
    
    busRef = property(__busRef.value, __busRef.set, None, 'Reference to a component bus interface name.')

    _ElementMap.update({
        __isPresent.name() : __isPresent
    })
    _AttributeMap.update({
        __componentRef.name() : __componentRef,
        __busRef.name() : __busRef
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_80 (pyxb.binding.basis.complexTypeDefinition):
    """Element to hold a the abstractor reference, the configuration and viewName. If multiple elements are present then the order is the order in which the abstractors should be chained together."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 115, 11)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_80_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_80_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}instanceName uses Python identifier instanceName
    __instanceName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'instanceName'), 'instanceName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_80_httpwww_accellera_orgXMLSchemaIPXACT1685_2014instanceName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 117, 13), )

    
    instanceName = property(__instanceName.value, __instanceName.set, None, 'Instance name for the abstractor')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractorRef uses Python identifier abstractorRef
    __abstractorRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'abstractorRef'), 'abstractorRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_80_httpwww_accellera_orgXMLSchemaIPXACT1685_2014abstractorRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 124, 13), )

    
    abstractorRef = property(__abstractorRef.value, __abstractorRef.set, None, 'Abstractor reference')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}viewName uses Python identifier viewName
    __viewName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'viewName'), 'viewName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_80_httpwww_accellera_orgXMLSchemaIPXACT1685_2014viewName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 129, 13), )

    
    viewName = property(__viewName.value, __viewName.set, None, 'The name of the active view for this abstractor instance.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_80_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __displayName.name() : __displayName,
        __description.name() : __description,
        __instanceName.name() : __instanceName,
        __abstractorRef.name() : __abstractorRef,
        __viewName.name() : __viewName
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_81 (pyxb.binding.basis.complexTypeDefinition):
    """Contains the active views for each instance in the design"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 149, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_81_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}view uses Python identifier view
    __view = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'view'), 'view', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_81_httpwww_accellera_orgXMLSchemaIPXACT1685_2014view', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 153, 7), )

    
    view = property(__view.value, __view.set, None, 'The selected view for the instance.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}instanceName uses Python identifier instanceName
    __instanceName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'instanceName'), 'instanceName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_81_httpwww_accellera_orgXMLSchemaIPXACT1685_2014instanceName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 123, 1), )

    
    instanceName = property(__instanceName.value, __instanceName.set, None, 'An instance name assigned to subcomponent instances and contained channels, that is unique within the parent component.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_81_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __isPresent.name() : __isPresent,
        __view.name() : __view,
        __instanceName.name() : __instanceName
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_82 (pyxb.binding.basis.complexTypeDefinition):
    """The selected view for the instance."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 157, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}configurableElementValues uses Python identifier configurableElementValues
    __configurableElementValues = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'configurableElementValues'), 'configurableElementValues', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_82_httpwww_accellera_orgXMLSchemaIPXACT1685_2014configurableElementValues', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 92, 1), )

    
    configurableElementValues = property(__configurableElementValues.value, __configurableElementValues.set, None, 'All configuration information for a contained component, generator, generator chain or abstractor instance.')

    
    # Attribute viewRef uses Python identifier viewRef
    __viewRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'viewRef'), 'viewRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_82_viewRef', pyxb.binding.datatypes.NMTOKEN, required=True)
    __viewRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 165, 9)
    __viewRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 165, 9)
    
    viewRef = property(__viewRef.value, __viewRef.set, None, None)

    _ElementMap.update({
        __configurableElementValues.name() : __configurableElementValues
    })
    _AttributeMap.update({
        __viewRef.name() : __viewRef
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_83 (pyxb.binding.basis.complexTypeDefinition):
    """IP-XACT reference to a file or directory."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 57, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 59, 16), )

    
    name = property(__name.value, __name.set, None, 'Path to the file or directory. If this path is a relative path, then it is relative to the containing XML file. ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isStructural uses Python identifier isStructural
    __isStructural = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isStructural'), 'isStructural', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isStructural', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 66, 15), )

    
    isStructural = property(__isStructural.value, __isStructural.set, None, 'Indicates that the current file is purely structural.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isIncludeFile uses Python identifier isIncludeFile
    __isIncludeFile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isIncludeFile'), 'isIncludeFile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isIncludeFile', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 71, 16), )

    
    isIncludeFile = property(__isIncludeFile.value, __isIncludeFile.set, None, 'Indicate that the file is include file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}logicalName uses Python identifier logicalName
    __logicalName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'logicalName'), 'logicalName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_httpwww_accellera_orgXMLSchemaIPXACT1685_2014logicalName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 87, 16), )

    
    logicalName = property(__logicalName.value, __logicalName.set, None, 'Logical name for this file or directory e.g. VHDL library name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}exportedName uses Python identifier exportedName
    __exportedName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'exportedName'), 'exportedName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_httpwww_accellera_orgXMLSchemaIPXACT1685_2014exportedName', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 103, 16), )

    
    exportedName = property(__exportedName.value, __exportedName.set, None, 'Defines exported names that can be accessed externally, e.g. exported function names from a C source file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}buildCommand uses Python identifier buildCommand
    __buildCommand = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'buildCommand'), 'buildCommand', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_httpwww_accellera_orgXMLSchemaIPXACT1685_2014buildCommand', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 115, 16), )

    
    buildCommand = property(__buildCommand.value, __buildCommand.set, None, 'Command and flags used to build derived files from the sourceName files. If this element is present, the command and/or flags used to to build the file will override or augment any default builders at a higher level.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}define uses Python identifier define
    __define = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'define'), 'define', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_httpwww_accellera_orgXMLSchemaIPXACT1685_2014define', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 156, 16), )

    
    define = property(__define.value, __define.set, None, 'Specifies define symbols that are used in the source file.  The ipxact:name element gives the name to be defined and the text content of the ipxact:value element holds the value.  This element supports full configurability.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}imageType uses Python identifier imageType
    __imageType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'imageType'), 'imageType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_httpwww_accellera_orgXMLSchemaIPXACT1685_2014imageType', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 161, 16), )

    
    imageType = property(__imageType.value, __imageType.set, None, 'Relates the current file to a certain executable image type in the design.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 173, 16), )

    
    description = property(__description.value, __description.set, None, 'String for describing this file to users')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}dependency uses Python identifier dependency
    __dependency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'dependency'), 'dependency', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_httpwww_accellera_orgXMLSchemaIPXACT1685_2014dependency', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 325, 4), )

    
    dependency = property(__dependency.value, __dependency.set, None, 'Specifies a location on which  files or fileSets may be dependent. Typically, this would be a directory that would contain included files.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileType uses Python identifier fileType
    __fileType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'fileType'), 'fileType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_httpwww_accellera_orgXMLSchemaIPXACT1685_2014fileType', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/fileType.xsd', 95, 1), )

    
    fileType = property(__fileType.value, __fileType.set, None, 'Enumerated file types known by IP-XACT.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute fileId uses Python identifier fileId
    __fileId = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'fileId'), 'fileId', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_83_fileId', pyxb.binding.datatypes.token)
    __fileId._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 180, 12)
    __fileId._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 180, 12)
    
    fileId = property(__fileId.value, __fileId.set, None, 'Unique ID for this file, referenced in fileSet/function/fileRef')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __isPresent.name() : __isPresent,
        __name.name() : __name,
        __isStructural.name() : __isStructural,
        __isIncludeFile.name() : __isIncludeFile,
        __logicalName.name() : __logicalName,
        __exportedName.name() : __exportedName,
        __buildCommand.name() : __buildCommand,
        __define.name() : __define,
        __imageType.name() : __imageType,
        __description.name() : __description,
        __dependency.name() : __dependency,
        __fileType.name() : __fileType
    })
    _AttributeMap.update({
        __id.name() : __id,
        __fileId.name() : __fileId
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_84 (pyxb.binding.basis.complexTypeDefinition):
    """Indicate that the file is include file."""
    _TypeDefinition = pyxb.binding.datatypes.boolean
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 75, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.boolean
    
    # Attribute externalDeclarations uses Python identifier externalDeclarations
    __externalDeclarations = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'externalDeclarations'), 'externalDeclarations', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_84_externalDeclarations', pyxb.binding.datatypes.boolean, unicode_default='false')
    __externalDeclarations._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 78, 32)
    __externalDeclarations._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 78, 32)
    
    externalDeclarations = property(__externalDeclarations.value, __externalDeclarations.set, None, 'the File contains some declarations that are needed in top file')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __externalDeclarations.name() : __externalDeclarations
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_85 (pyxb.binding.basis.complexTypeDefinition):
    """Logical name for this file or directory e.g. VHDL library name."""
    _TypeDefinition = pyxb.binding.datatypes.Name
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 91, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.Name
    
    # Attribute default uses Python identifier default
    __default = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'default'), 'default', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_85_default', pyxb.binding.datatypes.boolean, unicode_default='false')
    __default._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 94, 32)
    __default._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 94, 32)
    
    default = property(__default.value, __default.set, None, 'The logical name shall only be used as a default and another process may override this name.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __default.name() : __default
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_86 (pyxb.binding.basis.complexTypeDefinition):
    """Defines exported names that can be accessed externally, e.g. exported function names from a C source file."""
    _TypeDefinition = pyxb.binding.datatypes.Name
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 107, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.Name
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_86_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_87 (pyxb.binding.basis.complexTypeDefinition):
    """Command and flags used to build derived files from the sourceName files. If this element is present, the command and/or flags used to to build the file will override or augment any default builders at a higher level."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 119, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}command uses Python identifier command
    __command = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'command'), 'command', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_87_httpwww_accellera_orgXMLSchemaIPXACT1685_2014command', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 121, 28), )

    
    command = property(__command.value, __command.set, None, 'Command used to build this file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}flags uses Python identifier flags
    __flags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'flags'), 'flags', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_87_httpwww_accellera_orgXMLSchemaIPXACT1685_2014flags', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 126, 28), )

    
    flags = property(__flags.value, __flags.set, None, 'Flags given to the build command when building this file. If the optional attribute "append" is "true", this string will be appended to any existing flags, otherwise these flags will replace any existing default flags.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}replaceDefaultFlags uses Python identifier replaceDefaultFlags
    __replaceDefaultFlags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'replaceDefaultFlags'), 'replaceDefaultFlags', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_87_httpwww_accellera_orgXMLSchemaIPXACT1685_2014replaceDefaultFlags', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 142, 28), )

    
    replaceDefaultFlags = property(__replaceDefaultFlags.value, __replaceDefaultFlags.set, None, 'If true, the value of the sibling element "flags" should replace any default flags specified at a more global level. If this is true and the sibling element "flags" is empty or missing, this has the effect of clearing any default flags.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}targetName uses Python identifier targetName
    __targetName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'targetName'), 'targetName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_87_httpwww_accellera_orgXMLSchemaIPXACT1685_2014targetName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 147, 28), )

    
    targetName = property(__targetName.value, __targetName.set, None, 'Pathname to the file that is derived (built) from the source file.')

    _ElementMap.update({
        __command.name() : __command,
        __flags.name() : __flags,
        __replaceDefaultFlags.name() : __replaceDefaultFlags,
        __targetName.name() : __targetName
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_88 (pyxb.binding.basis.complexTypeDefinition):
    """Relates the current file to a certain executable image type in the design."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 165, 18)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_88_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_89 (pyxb.binding.basis.complexTypeDefinition):
    """Specifies an executable software image to be loaded into a processors address space. The format of the image is not specified. It could, for example, be an ELF loadfile, or it could be raw binary or ascii hex data for loading directly into a memory model instance."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 198, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_89_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_89_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_89_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_89_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_89_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}languageTools uses Python identifier languageTools
    __languageTools = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'languageTools'), 'languageTools', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_89_httpwww_accellera_orgXMLSchemaIPXACT1685_2014languageTools', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 206, 16), )

    
    languageTools = property(__languageTools.value, __languageTools.set, None, 'Default commands and flags for software language tools needed to build the executable image.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileSetRefGroup uses Python identifier fileSetRefGroup
    __fileSetRefGroup = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'fileSetRefGroup'), 'fileSetRefGroup', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_89_httpwww_accellera_orgXMLSchemaIPXACT1685_2014fileSetRefGroup', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 257, 16), )

    
    fileSetRefGroup = property(__fileSetRefGroup.value, __fileSetRefGroup.set, None, 'Contains a group of file set references that indicates the set of file sets complying with the tool set of the current executable image.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_89_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute imageId uses Python identifier imageId
    __imageId = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'imageId'), 'imageId', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_89_imageId', pyxb.binding.datatypes.token, required=True)
    __imageId._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 269, 12)
    __imageId._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 269, 12)
    
    imageId = property(__imageId.value, __imageId.set, None, 'Unique ID for the executableImage, referenced in fileSet/function/fileRef')

    
    # Attribute imageType uses Python identifier imageType
    __imageType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'imageType'), 'imageType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_89_imageType', pyxb.binding.datatypes.Name)
    __imageType._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 274, 12)
    __imageType._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 274, 12)
    
    imageType = property(__imageType.value, __imageType.set, None, 'Open element to describe the type of image. The contents is model and/or generator specific.')

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __languageTools.name() : __languageTools,
        __fileSetRefGroup.name() : __fileSetRefGroup
    })
    _AttributeMap.update({
        __id.name() : __id,
        __imageId.name() : __imageId,
        __imageType.name() : __imageType
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_90 (pyxb.binding.basis.complexTypeDefinition):
    """Default commands and flags for software language tools needed to build the executable image."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 210, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileBuilder uses Python identifier fileBuilder
    __fileBuilder = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'fileBuilder'), 'fileBuilder', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_90_httpwww_accellera_orgXMLSchemaIPXACT1685_2014fileBuilder', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 212, 28), )

    
    fileBuilder = property(__fileBuilder.value, __fileBuilder.set, None, 'A generic placeholder for any file builder like compilers and assemblers.  It contains the file types to which the command should be applied, and the flags to be used with that command.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}linker uses Python identifier linker
    __linker = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'linker'), 'linker', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_90_httpwww_accellera_orgXMLSchemaIPXACT1685_2014linker', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 245, 30), )

    
    linker = property(__linker.value, __linker.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}linkerFlags uses Python identifier linkerFlags
    __linkerFlags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'linkerFlags'), 'linkerFlags', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_90_httpwww_accellera_orgXMLSchemaIPXACT1685_2014linkerFlags', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 248, 34), )

    
    linkerFlags = property(__linkerFlags.value, __linkerFlags.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}linkerCommandFile uses Python identifier linkerCommandFile
    __linkerCommandFile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'linkerCommandFile'), 'linkerCommandFile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_90_httpwww_accellera_orgXMLSchemaIPXACT1685_2014linkerCommandFile', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 282, 4), )

    
    linkerCommandFile = property(__linkerCommandFile.value, __linkerCommandFile.set, None, 'Specifies a linker command file.')

    _ElementMap.update({
        __fileBuilder.name() : __fileBuilder,
        __linker.name() : __linker,
        __linkerFlags.name() : __linkerFlags,
        __linkerCommandFile.name() : __linkerCommandFile
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_91 (pyxb.binding.basis.complexTypeDefinition):
    """A generic placeholder for any file builder like compilers and assemblers.  It contains the file types to which the command should be applied, and the flags to be used with that command.  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 216, 32)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_91_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}command uses Python identifier command
    __command = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'command'), 'command', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_91_httpwww_accellera_orgXMLSchemaIPXACT1685_2014command', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 219, 40), )

    
    command = property(__command.value, __command.set, None, 'Default command used to build files of the specified fileType. ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}flags uses Python identifier flags
    __flags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'flags'), 'flags', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_91_httpwww_accellera_orgXMLSchemaIPXACT1685_2014flags', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 224, 40), )

    
    flags = property(__flags.value, __flags.set, None, 'Flags given to the build command when building files of this type.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}replaceDefaultFlags uses Python identifier replaceDefaultFlags
    __replaceDefaultFlags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'replaceDefaultFlags'), 'replaceDefaultFlags', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_91_httpwww_accellera_orgXMLSchemaIPXACT1685_2014replaceDefaultFlags', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 229, 40), )

    
    replaceDefaultFlags = property(__replaceDefaultFlags.value, __replaceDefaultFlags.set, None, 'If true, replace any default flags value with the value in the sibling flags element. Otherwise, append the contents of the sibling flags element to any default flags value.\n\nIf the value is true and the "flags" element is empty or missing, this will have the result of clearing any default flags value.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileType uses Python identifier fileType
    __fileType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'fileType'), 'fileType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_91_httpwww_accellera_orgXMLSchemaIPXACT1685_2014fileType', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/fileType.xsd', 95, 1), )

    
    fileType = property(__fileType.value, __fileType.set, None, 'Enumerated file types known by IP-XACT.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_91_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __command.name() : __command,
        __flags.name() : __flags,
        __replaceDefaultFlags.name() : __replaceDefaultFlags,
        __fileType.name() : __fileType
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_92 (pyxb.binding.basis.complexTypeDefinition):
    """Contains a group of file set references that indicates the set of file sets complying with the tool set of the current executable image."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 261, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileSetRef uses Python identifier fileSetRef
    __fileSetRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'fileSetRef'), 'fileSetRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_92_httpwww_accellera_orgXMLSchemaIPXACT1685_2014fileSetRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 309, 4), )

    
    fileSetRef = property(__fileSetRef.value, __fileSetRef.set, None, 'A reference to a fileSet.')

    _ElementMap.update({
        __fileSetRef.name() : __fileSetRef
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_93 (pyxb.binding.basis.complexTypeDefinition):
    """Specifies a linker command file."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 286, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_93_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_93_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 288, 16), )

    
    name = property(__name.value, __name.set, None, 'Linker command file name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}commandLineSwitch uses Python identifier commandLineSwitch
    __commandLineSwitch = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'commandLineSwitch'), 'commandLineSwitch', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_93_httpwww_accellera_orgXMLSchemaIPXACT1685_2014commandLineSwitch', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 293, 16), )

    
    commandLineSwitch = property(__commandLineSwitch.value, __commandLineSwitch.set, None, 'The command line switch to specify the linker command file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}enable uses Python identifier enable
    __enable = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'enable'), 'enable', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_93_httpwww_accellera_orgXMLSchemaIPXACT1685_2014enable', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 298, 16), )

    
    enable = property(__enable.value, __enable.set, None, 'Specifies whether to generate and enable the linker command file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorRef uses Python identifier generatorRef
    __generatorRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'generatorRef'), 'generatorRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_93_httpwww_accellera_orgXMLSchemaIPXACT1685_2014generatorRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 491, 4), )

    
    generatorRef = property(__generatorRef.value, __generatorRef.set, None, 'A reference to a generator element.')

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __commandLineSwitch.name() : __commandLineSwitch,
        __enable.name() : __enable,
        __generatorRef.name() : __generatorRef
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_94 (pyxb.binding.basis.complexTypeDefinition):
    """A reference to a fileSet."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 313, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_94_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}localName uses Python identifier localName
    __localName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'localName'), 'localName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_94_httpwww_accellera_orgXMLSchemaIPXACT1685_2014localName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 315, 16), )

    
    localName = property(__localName.value, __localName.set, None, 'Refers to a fileSet defined within this description.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_94_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __isPresent.name() : __isPresent,
        __localName.name() : __localName
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_95 (pyxb.binding.basis.complexTypeDefinition):
    """List of file sets associated with component."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 341, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileSet uses Python identifier fileSet
    __fileSet = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'fileSet'), 'fileSet', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_95_httpwww_accellera_orgXMLSchemaIPXACT1685_2014fileSet', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 189, 4), )

    
    fileSet = property(__fileSet.value, __fileSet.set, None, 'This element specifies a list of unique pathnames to files and directories. It may also include build instructions for the files. If compilation order is important, e.g. for VHDL files, the files have to be provided in compilation order.')

    _ElementMap.update({
        __fileSet.name() : __fileSet
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileBuilderType with content type ELEMENT_ONLY
class fileBuilderType (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileBuilderType with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'fileBuilderType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 347, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}command uses Python identifier command
    __command = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'command'), 'command', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileBuilderType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014command', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 350, 12), )

    
    command = property(__command.value, __command.set, None, 'Default command used to build files of the specified fileType. ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}flags uses Python identifier flags
    __flags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'flags'), 'flags', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileBuilderType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014flags', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 355, 12), )

    
    flags = property(__flags.value, __flags.set, None, 'Flags given to the build command when building files of this type.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}replaceDefaultFlags uses Python identifier replaceDefaultFlags
    __replaceDefaultFlags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'replaceDefaultFlags'), 'replaceDefaultFlags', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileBuilderType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014replaceDefaultFlags', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 360, 12), )

    
    replaceDefaultFlags = property(__replaceDefaultFlags.value, __replaceDefaultFlags.set, None, 'If true, replace any default flags value with the value in the sibling flags element. Otherwise, append the contents of the sibling flags element to any default flags value.\n\nIf the value is true and the "flags" element is empty or missing, this will have the result of clearing any default flags value.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileType uses Python identifier fileType
    __fileType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'fileType'), 'fileType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileBuilderType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014fileType', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/fileType.xsd', 95, 1), )

    
    fileType = property(__fileType.value, __fileType.set, None, 'Enumerated file types known by IP-XACT.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileBuilderType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __command.name() : __command,
        __flags.name() : __flags,
        __replaceDefaultFlags.name() : __replaceDefaultFlags,
        __fileType.name() : __fileType
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'fileBuilderType', fileBuilderType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileSetType with content type ELEMENT_ONLY
class fileSetType (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileSetType with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'fileSetType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 378, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileSetType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileSetType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileSetType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileSetType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}file uses Python identifier file
    __file = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'file'), 'file', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileSetType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014file', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 53, 4), )

    
    file = property(__file.value, __file.set, None, 'IP-XACT reference to a file or directory.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}dependency uses Python identifier dependency
    __dependency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'dependency'), 'dependency', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileSetType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014dependency', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 325, 4), )

    
    dependency = property(__dependency.value, __dependency.set, None, 'Specifies a location on which  files or fileSets may be dependent. Typically, this would be a directory that would contain included files.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'group'), 'group', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileSetType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014group', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 381, 12), )

    
    group = property(__group.value, __group.set, None, 'Identifies this filleSet as belonging to a particular group or having a particular purpose. Examples might be "diagnostics", "boot", "application", "interrupt", "deviceDriver", etc.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}defaultFileBuilder uses Python identifier defaultFileBuilder
    __defaultFileBuilder = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'defaultFileBuilder'), 'defaultFileBuilder', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileSetType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014defaultFileBuilder', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 394, 12), )

    
    defaultFileBuilder = property(__defaultFileBuilder.value, __defaultFileBuilder.set, None, 'Default command and flags used to build derived files from the sourceName files in this file set.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}function uses Python identifier function
    __function = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'function'), 'function', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileSetType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014function', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 400, 12), )

    
    function = property(__function.value, __function.set, None, 'Generator information if this file set describes a function. For example, this file set may describe diagnostics for which the DE can generate a diagnostics driver.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fileSetType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __file.name() : __file,
        __dependency.name() : __dependency,
        __group.name() : __group,
        __defaultFileBuilder.name() : __defaultFileBuilder,
        __function.name() : __function
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'fileSetType', fileSetType)


# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_96 (pyxb.binding.basis.complexTypeDefinition):
    """Identifies this filleSet as belonging to a particular group or having a particular purpose. Examples might be "diagnostics", "boot", "application", "interrupt", "deviceDriver", etc."""
    _TypeDefinition = pyxb.binding.datatypes.Name
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 385, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.Name
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_96_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_97 (pyxb.binding.basis.complexTypeDefinition):
    """Generator information if this file set describes a function. For example, this file set may describe diagnostics for which the DE can generate a diagnostics driver."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 404, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}entryPoint uses Python identifier entryPoint
    __entryPoint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'entryPoint'), 'entryPoint', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_97_httpwww_accellera_orgXMLSchemaIPXACT1685_2014entryPoint', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 406, 24), )

    
    entryPoint = property(__entryPoint.value, __entryPoint.set, None, 'Optional name for the function.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileRef uses Python identifier fileRef
    __fileRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'fileRef'), 'fileRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_97_httpwww_accellera_orgXMLSchemaIPXACT1685_2014fileRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 411, 24), )

    
    fileRef = property(__fileRef.value, __fileRef.set, None, 'A reference to the file that contains the entry point function.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}returnType uses Python identifier returnType
    __returnType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'returnType'), 'returnType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_97_httpwww_accellera_orgXMLSchemaIPXACT1685_2014returnType', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 416, 24), )

    
    returnType = property(__returnType.value, __returnType.set, None, 'Function return type. Possible values are void and int.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}argument uses Python identifier argument
    __argument = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'argument'), 'argument', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_97_httpwww_accellera_orgXMLSchemaIPXACT1685_2014argument', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 421, 24), )

    
    argument = property(__argument.value, __argument.set, None, 'Arguments passed in when the function is called. Arguments are passed in order.\n\nThis is an extension of the name-value pair which includes the data type in the ipxact:dataType attribute.  The argument name is in the ipxact:name element and its value is in the ipxact:value element.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}disabled uses Python identifier disabled
    __disabled = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'disabled'), 'disabled', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_97_httpwww_accellera_orgXMLSchemaIPXACT1685_2014disabled', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 439, 24), )

    
    disabled = property(__disabled.value, __disabled.set, None, 'Specifies if the SW function is enabled. If not present the function is always enabled.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}sourceFile uses Python identifier sourceFile
    __sourceFile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'sourceFile'), 'sourceFile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_97_httpwww_accellera_orgXMLSchemaIPXACT1685_2014sourceFile', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 444, 24), )

    
    sourceFile = property(__sourceFile.value, __sourceFile.set, None, 'Location information for the source file of this function.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_97_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute replicate uses Python identifier replicate
    __replicate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'replicate'), 'replicate', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_97_replicate', pyxb.binding.datatypes.boolean, unicode_default='false')
    __replicate._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 462, 20)
    __replicate._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 462, 20)
    
    replicate = property(__replicate.value, __replicate.set, None, 'If true directs the generator to compile a separate object module for each instance of the component in the design. If false (default) the function will be called with different arguments for each instance.')

    _ElementMap.update({
        __entryPoint.name() : __entryPoint,
        __fileRef.name() : __fileRef,
        __returnType.name() : __returnType,
        __argument.name() : __argument,
        __disabled.name() : __disabled,
        __sourceFile.name() : __sourceFile
    })
    _AttributeMap.update({
        __id.name() : __id,
        __replicate.name() : __replicate
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_98 (pyxb.binding.basis.complexTypeDefinition):
    """Location information for the source file of this function."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 448, 28)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}sourceName uses Python identifier sourceName
    __sourceName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'sourceName'), 'sourceName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_98_httpwww_accellera_orgXMLSchemaIPXACT1685_2014sourceName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 450, 36), )

    
    sourceName = property(__sourceName.value, __sourceName.set, None, 'Source file for the boot load.  Relative names are searched for in the project directory and the source of the component directory.\n    ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileType uses Python identifier fileType
    __fileType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'fileType'), 'fileType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_98_httpwww_accellera_orgXMLSchemaIPXACT1685_2014fileType', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/fileType.xsd', 95, 1), )

    
    fileType = property(__fileType.value, __fileType.set, None, 'Enumerated file types known by IP-XACT.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_98_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __sourceName.name() : __sourceName,
        __fileType.name() : __fileType
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_99 (pyxb.binding.basis.complexTypeDefinition):
    """A reference to a generator element."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 495, 6)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_99_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}ipxactURI with content type SIMPLE
class ipxactURI (pyxb.binding.basis.complexTypeDefinition):
    """IP-XACT URI, like a standard xs:anyURI except that it can contain environment variables in the ${ } form, to be replaced by their value to provide the underlying URI"""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ipxactURI')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 504, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ipxactURI', ipxactURI)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_100 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 55, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}choices uses Python identifier choices
    __choices = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'choices'), 'choices', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_accellera_orgXMLSchemaIPXACT1685_2014choices', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 95, 1), )

    
    choices = property(__choices.value, __choices.set, None, 'Choices used by elements with an attribute ipxact:choiceRef.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}assertions uses Python identifier assertions
    __assertions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'assertions'), 'assertions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_accellera_orgXMLSchemaIPXACT1685_2014assertions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1), )

    
    assertions = property(__assertions.value, __assertions.set, None, 'List of assertions about allowed parameter values.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorChainSelector uses Python identifier generatorChainSelector
    __generatorChainSelector = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'generatorChainSelector'), 'generatorChainSelector', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_accellera_orgXMLSchemaIPXACT1685_2014generatorChainSelector', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 59, 5), )

    
    generatorChainSelector = property(__generatorChainSelector.value, __generatorChainSelector.set, None, 'Select other generator chain files for inclusion into this chain. The boolean attribute "unique" (default false) specifies that only a single generator is valid in this context. If more that one generator is selected based on the selection criteria, DE will prompt the user to resolve to a single generator.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}componentGeneratorSelector uses Python identifier componentGeneratorSelector
    __componentGeneratorSelector = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'componentGeneratorSelector'), 'componentGeneratorSelector', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_accellera_orgXMLSchemaIPXACT1685_2014componentGeneratorSelector', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 80, 5), )

    
    componentGeneratorSelector = property(__componentGeneratorSelector.value, __componentGeneratorSelector.set, None, 'Selects generators declared in components of the current design for inclusion into this generator chain.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}chainGroup uses Python identifier chainGroup
    __chainGroup = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'chainGroup'), 'chainGroup', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_accellera_orgXMLSchemaIPXACT1685_2014chainGroup', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 87, 4), )

    
    chainGroup = property(__chainGroup.value, __chainGroup.set, None, 'Identifies this generator chain as belonging to the named group. This is used by other generator chains to select this chain for programmatic inclusion.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generator uses Python identifier generator
    __generator = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'generator'), 'generator', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_accellera_orgXMLSchemaIPXACT1685_2014generator', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 114, 1), )

    
    generator = property(__generator.value, __generator.set, None, 'Specifies a set of generators.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendor uses Python identifier vendor
    __vendor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendor'), 'vendor', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendor', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3), )

    
    vendor = property(__vendor.value, __vendor.set, None, 'Name of the vendor who supplies this file.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}library uses Python identifier library
    __library = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'library'), 'library', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_accellera_orgXMLSchemaIPXACT1685_2014library', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3), )

    
    library = property(__library.value, __library.set, None, 'Name of the logical library this element belongs to.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3), )

    
    name = property(__name.value, __name.set, None, 'The name of the object.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}version uses Python identifier version
    __version = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'version'), 'version', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_accellera_orgXMLSchemaIPXACT1685_2014version', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3), )

    
    version = property(__version.value, __version.set, None, 'Indicates the version of the named element.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute hidden uses Python identifier hidden
    __hidden = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'hidden'), 'hidden', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_100_hidden', pyxb.binding.datatypes.boolean, unicode_default='false')
    __hidden._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 106, 3)
    __hidden._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 106, 3)
    
    hidden = property(__hidden.value, __hidden.set, None, 'If this attribute is true then the generator should not be presented to the user, it may be part of a chain and has no useful meaning when invoked standalone.')

    _ElementMap.update({
        __choices.name() : __choices,
        __assertions.name() : __assertions,
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __generatorChainSelector.name() : __generatorChainSelector,
        __componentGeneratorSelector.name() : __componentGeneratorSelector,
        __chainGroup.name() : __chainGroup,
        __generator.name() : __generator,
        __vendor.name() : __vendor,
        __library.name() : __library,
        __name.name() : __name,
        __version.name() : __version
    })
    _AttributeMap.update({
        __id.name() : __id,
        __hidden.name() : __hidden
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_101 (pyxb.binding.basis.complexTypeDefinition):
    """Select other generator chain files for inclusion into this chain. The boolean attribute "unique" (default false) specifies that only a single generator is valid in this context. If more that one generator is selected based on the selection criteria, DE will prompt the user to resolve to a single generator."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 63, 6)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorChainRef uses Python identifier generatorChainRef
    __generatorChainRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'generatorChainRef'), 'generatorChainRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_101_httpwww_accellera_orgXMLSchemaIPXACT1685_2014generatorChainRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 66, 8), )

    
    generatorChainRef = property(__generatorChainRef.value, __generatorChainRef.set, None, 'Select another generator chain using the unique identifier of this generator chain.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}groupSelector uses Python identifier groupSelector
    __groupSelector = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'groupSelector'), 'groupSelector', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_101_httpwww_accellera_orgXMLSchemaIPXACT1685_2014groupSelector', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 134, 1), )

    
    groupSelector = property(__groupSelector.value, __groupSelector.set, None, 'Specifies a set of group names used to select subsequent generators. The attribute "multipleGroupOperator" specifies the OR or AND selection operator if there is more than one group name (default=OR).')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_101_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute unique uses Python identifier unique
    __unique = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'unique'), 'unique', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_101_unique', pyxb.binding.datatypes.boolean, unicode_default='false')
    __unique._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 72, 7)
    __unique._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 72, 7)
    
    unique = property(__unique.value, __unique.set, None, 'Specifies that only a single generator is valid in this context. If more that one generator is selcted based on the selection criteria, DE will prompt the user to resolve to a single generator.')

    _ElementMap.update({
        __generatorChainRef.name() : __generatorChainRef,
        __groupSelector.name() : __groupSelector
    })
    _AttributeMap.update({
        __id.name() : __id,
        __unique.name() : __unique
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_102 (pyxb.binding.basis.complexTypeDefinition):
    """Identifies this generator chain as belonging to the named group. This is used by other generator chains to select this chain for programmatic inclusion."""
    _TypeDefinition = pyxb.binding.datatypes.Name
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 91, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.Name
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_102_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_103 (pyxb.binding.basis.complexTypeDefinition):
    """Specifies a generator group name or a generator chain group name to be selected for inclusion in the generator chain."""
    _TypeDefinition = pyxb.binding.datatypes.Name
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 144, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.Name
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_103_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_104 (pyxb.binding.basis.complexTypeDefinition):
    """An identifier to specify the generator group. This is used by generator chains for selecting which generators to run."""
    _TypeDefinition = pyxb.binding.datatypes.Name
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 180, 6)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.Name
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_104_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorSelectorType with content type ELEMENT_ONLY
class generatorSelectorType (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorSelectorType with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'generatorSelectorType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 203, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}groupSelector uses Python identifier groupSelector
    __groupSelector = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'groupSelector'), 'groupSelector', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_generatorSelectorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014groupSelector', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 134, 1), )

    
    groupSelector = property(__groupSelector.value, __groupSelector.set, None, 'Specifies a set of group names used to select subsequent generators. The attribute "multipleGroupOperator" specifies the OR or AND selection operator if there is more than one group name (default=OR).')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_generatorSelectorType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __groupSelector.name() : __groupSelector
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'generatorSelectorType', generatorSelectorType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_105 (pyxb.binding.basis.complexTypeDefinition):
    """List of component generators."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 213, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}componentGenerator uses Python identifier componentGenerator
    __componentGenerator = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'componentGenerator'), 'componentGenerator', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_105_httpwww_accellera_orgXMLSchemaIPXACT1685_2014componentGenerator', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 124, 1), )

    
    componentGenerator = property(__componentGenerator.value, __componentGenerator.set, None, 'Specifies a set of component generators. The scope attribute applies to component generators and specifies whether the generator should be run for each instance of the entity (or module) or just once for all instances of the entity.')

    _ElementMap.update({
        __componentGenerator.name() : __componentGenerator
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_106 (pyxb.binding.basis.complexTypeDefinition):
    """List of abstractor generators."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 223, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractorGenerator uses Python identifier abstractorGenerator
    __abstractorGenerator = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'abstractorGenerator'), 'abstractorGenerator', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_106_httpwww_accellera_orgXMLSchemaIPXACT1685_2014abstractorGenerator', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 129, 1), )

    
    abstractorGenerator = property(__abstractorGenerator.value, __abstractorGenerator.set, None, 'Specifies a set of abstractor generators. The scope attribute applies to abstractor generators and specifies whether the generator should be run for each instance of the entity (or module) or just once for all instances of the entity.')

    _ElementMap.update({
        __abstractorGenerator.name() : __abstractorGenerator
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType with content type ELEMENT_ONLY
class generatorType (pyxb.binding.basis.complexTypeDefinition):
    """Types of generators"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'generatorType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 242, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_generatorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_generatorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_generatorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_generatorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_generatorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}phase uses Python identifier phase
    __phase = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'phase'), 'phase', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_generatorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014phase', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 167, 1), )

    
    phase = property(__phase.value, __phase.set, None, 'This is an non-negative floating point number that is used to sequence when a generator is run. The generators are run in order starting with zero. There may be multiple generators with the same phase number. In this case, the order should not matter with respect to other generators at the same phase. If no phase number is given the generator will be considered in the "last" phase and these generators will be run in the order in which they are encountered while processing generator elements.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}apiType uses Python identifier apiType
    __apiType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'apiType'), 'apiType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_generatorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014apiType', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 250, 3), )

    
    apiType = property(__apiType.value, __apiType.set, None, 'Indicates the type of API used by the generator. Valid value are TGI_2009, TGI_2014_BASE, TGI_2014_EXTENDED, and none. If this element is not present, TGI_2014_BASE is assumed. The type TGI_2009 indicates a generator using the 1685-2009 version of the TGI API. This is not part of the 1685-2014 version of the standard and may not be supported by Design Environments.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}transportMethods uses Python identifier transportMethods
    __transportMethods = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'transportMethods'), 'transportMethods', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_generatorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014transportMethods', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 262, 3), )

    
    transportMethods = property(__transportMethods.value, __transportMethods.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorExe uses Python identifier generatorExe
    __generatorExe = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'generatorExe'), 'generatorExe', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_generatorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014generatorExe', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 281, 3), )

    
    generatorExe = property(__generatorExe.value, __generatorExe.set, None, 'The pathname to the executable file that implements the generator')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_generatorType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute hidden uses Python identifier hidden
    __hidden = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'hidden'), 'hidden', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_generatorType_hidden', pyxb.binding.datatypes.boolean, unicode_default='false')
    __hidden._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 288, 2)
    __hidden._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 288, 2)
    
    hidden = property(__hidden.value, __hidden.set, None, 'If this attribute is true then the generator should not be presented to the user, it may be part of a chain and has no useful meaning when invoked standalone.')

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __phase.name() : __phase,
        __apiType.name() : __apiType,
        __transportMethods.name() : __transportMethods,
        __generatorExe.name() : __generatorExe
    })
    _AttributeMap.update({
        __id.name() : __id,
        __hidden.name() : __hidden
    })
Namespace.addCategoryObject('typeBinding', 'generatorType', generatorType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_107 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 263, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}transportMethod uses Python identifier transportMethod
    __transportMethod = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'transportMethod'), 'transportMethod', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_107_httpwww_accellera_orgXMLSchemaIPXACT1685_2014transportMethod', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 265, 6), )

    
    transportMethod = property(__transportMethod.value, __transportMethod.set, None, "Defines a SOAP transport protocol other than HTTP which is supported by this generator. The only other currently supported protocol is 'file'.")

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_107_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __transportMethod.name() : __transportMethod
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}libraryRefType with content type EMPTY
class libraryRefType (pyxb.binding.basis.complexTypeDefinition):
    """Base IP-XACT document reference type. Contains vendor, library, name and version attributes."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'libraryRefType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 95, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute vendor uses Python identifier vendor
    __vendor = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vendor'), 'vendor', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_libraryRefType_vendor', pyxb.binding.datatypes.Name, required=True)
    __vendor._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 90, 2)
    __vendor._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 90, 2)
    
    vendor = property(__vendor.value, __vendor.set, None, None)

    
    # Attribute library uses Python identifier library
    __library = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'library'), 'library', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_libraryRefType_library', pyxb.binding.datatypes.Name, required=True)
    __library._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 91, 2)
    __library._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 91, 2)
    
    library = property(__library.value, __library.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_libraryRefType_name', pyxb.binding.datatypes.NMTOKEN, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 92, 2)
    __name._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 92, 2)
    
    name = property(__name.value, __name.set, None, None)

    
    # Attribute version uses Python identifier version
    __version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'version'), 'version', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_libraryRefType_version', pyxb.binding.datatypes.NMTOKEN, required=True)
    __version._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 93, 2)
    __version._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 93, 2)
    
    version = property(__version.value, __version.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __vendor.name() : __vendor,
        __library.name() : __library,
        __name.name() : __name,
        __version.name() : __version
    })
Namespace.addCategoryObject('typeBinding', 'libraryRefType', libraryRefType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}configurableLibraryRefType with content type ELEMENT_ONLY
class configurableLibraryRefType (pyxb.binding.basis.complexTypeDefinition):
    """Base IP-XACT document reference type for configurable top-level objects. Contains vendor, library, name and version attributes along with configurable element values."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'configurableLibraryRefType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 105, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}configurableElementValues uses Python identifier configurableElementValues
    __configurableElementValues = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'configurableElementValues'), 'configurableElementValues', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_configurableLibraryRefType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014configurableElementValues', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 92, 1), )

    
    configurableElementValues = property(__configurableElementValues.value, __configurableElementValues.set, None, 'All configuration information for a contained component, generator, generator chain or abstractor instance.')

    
    # Attribute vendor uses Python identifier vendor
    __vendor = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vendor'), 'vendor', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_configurableLibraryRefType_vendor', pyxb.binding.datatypes.Name, required=True)
    __vendor._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 90, 2)
    __vendor._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 90, 2)
    
    vendor = property(__vendor.value, __vendor.set, None, None)

    
    # Attribute library uses Python identifier library
    __library = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'library'), 'library', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_configurableLibraryRefType_library', pyxb.binding.datatypes.Name, required=True)
    __library._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 91, 2)
    __library._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 91, 2)
    
    library = property(__library.value, __library.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_configurableLibraryRefType_name', pyxb.binding.datatypes.NMTOKEN, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 92, 2)
    __name._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 92, 2)
    
    name = property(__name.value, __name.set, None, None)

    
    # Attribute version uses Python identifier version
    __version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'version'), 'version', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_configurableLibraryRefType_version', pyxb.binding.datatypes.NMTOKEN, required=True)
    __version._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 93, 2)
    __version._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 93, 2)
    
    version = property(__version.value, __version.set, None, None)

    _ElementMap.update({
        __configurableElementValues.name() : __configurableElementValues
    })
    _AttributeMap.update({
        __vendor.name() : __vendor,
        __library.name() : __library,
        __name.name() : __name,
        __version.name() : __version
    })
Namespace.addCategoryObject('typeBinding', 'configurableLibraryRefType', configurableLibraryRefType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_108 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 113, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandle uses Python identifier accessHandle
    __accessHandle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), 'accessHandle', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_108_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandle', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 115, 6), )

    
    accessHandle = property(__accessHandle.value, __accessHandle.set, None, None)

    _ElementMap.update({
        __accessHandle.name() : __accessHandle
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_109 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 136, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandle uses Python identifier accessHandle
    __accessHandle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), 'accessHandle', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_109_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandle', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 138, 6), )

    
    accessHandle = property(__accessHandle.value, __accessHandle.set, None, None)

    _ElementMap.update({
        __accessHandle.name() : __accessHandle
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressBlockType with content type ELEMENT_ONLY
class addressBlockType (pyxb.binding.basis.complexTypeDefinition):
    """Top level address block that specify an address"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'addressBlockType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 152, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandles uses Python identifier accessHandles
    __accessHandles = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), 'accessHandles', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandles', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 158, 3), )

    
    accessHandles = property(__accessHandles.value, __accessHandles.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}volatile uses Python identifier volatile
    __volatile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'volatile'), 'volatile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014volatile', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), )

    
    volatile = property(__volatile.value, __volatile.set, None, 'Indicates whether the data is volatile.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}access uses Python identifier access
    __access = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'access'), 'access', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014access', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1), )

    
    access = property(__access.value, __access.set, None, "Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}baseAddress uses Python identifier baseAddress
    __baseAddress = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'baseAddress'), 'baseAddress', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014baseAddress', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 558, 1), )

    
    baseAddress = property(__baseAddress.value, __baseAddress.set, None, 'Base of an address block, bank, subspace map or address space. Expressed as the number of addressable units from the containing memoryMap or localMemoryMap.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}range uses Python identifier range
    __range = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'range'), 'range', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014range', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 659, 3), )

    
    range = property(__range.value, __range.set, None, 'The address range of an address block.  Expressed as the number of addressable units accessible to the block. The range and the width are related by the following formulas:\n\t\t\t\t\tnumber_of_bits_in_block = ipxact:addressUnitBits * ipxact:range\n\t\t\t\t\tnumber_of_rows_in_block = number_of_bits_in_block / ipxact:width\n\t\t\t\t\t')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}width uses Python identifier width
    __width = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'width'), 'width', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014width', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 667, 3), )

    
    width = property(__width.value, __width.set, None, 'The bit width of a row in the address block. The range and the width are related by the following formulas:\n\t\t\t\t\tnumber_of_bits_in_block = ipxact:addressUnitBits * ipxact:range\n\t\t\t\t\tnumber_of_rows_in_block = number_of_bits_in_block / ipxact:width\n\t\t\t\t\t')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}usage uses Python identifier usage
    __usage = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'usage'), 'usage', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014usage', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3), )

    
    usage = property(__usage.value, __usage.set, None, "Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}register uses Python identifier register
    __register = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'register'), 'register', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014register', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 703, 3), )

    
    register = property(__register.value, __register.set, None, 'A single register')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}registerFile uses Python identifier registerFile
    __registerFile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'registerFile'), 'registerFile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014registerFile', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 984, 1), )

    
    registerFile = property(__registerFile.value, __registerFile.set, None, 'A structure of registers and register files')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}typeIdentifier uses Python identifier typeIdentifier
    __typeIdentifier = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier'), 'typeIdentifier', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014typeIdentifier', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1068, 3), )

    
    typeIdentifier = property(__typeIdentifier.value, __typeIdentifier.set, None, 'Identifier name used to indicate that multiple addressBlock elements contain the exact same information except for the elements in the addressBlockInstanceGroup.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBlockType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __accessHandles.name() : __accessHandles,
        __volatile.name() : __volatile,
        __access.name() : __access,
        __baseAddress.name() : __baseAddress,
        __range.name() : __range,
        __width.name() : __width,
        __usage.name() : __usage,
        __register.name() : __register,
        __registerFile.name() : __registerFile,
        __typeIdentifier.name() : __typeIdentifier
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'addressBlockType', addressBlockType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_110 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 159, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandle uses Python identifier accessHandle
    __accessHandle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), 'accessHandle', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_110_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandle', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 161, 6), )

    
    accessHandle = property(__accessHandle.value, __accessHandle.set, None, None)

    _ElementMap.update({
        __accessHandle.name() : __accessHandle
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addrSpaceRefType with content type ELEMENT_ONLY
class addrSpaceRefType (pyxb.binding.basis.complexTypeDefinition):
    """Base type for an element which references an address space.  Reference is kept in an attribute rather than the text value, so that the type may be extended with child elements if necessary."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'addrSpaceRefType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 172, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addrSpaceRefType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addrSpaceRefType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute addressSpaceRef uses Python identifier addressSpaceRef
    __addressSpaceRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'addressSpaceRef'), 'addressSpaceRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addrSpaceRefType_addressSpaceRef', pyxb.binding.datatypes.Name, required=True)
    __addressSpaceRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 179, 2)
    __addressSpaceRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 179, 2)
    
    addressSpaceRef = property(__addressSpaceRef.value, __addressSpaceRef.set, None, 'A reference to a unique address space.')

    _ElementMap.update({
        __isPresent.name() : __isPresent
    })
    _AttributeMap.update({
        __id.name() : __id,
        __addressSpaceRef.name() : __addressSpaceRef
    })
Namespace.addCategoryObject('typeBinding', 'addrSpaceRefType', addrSpaceRefType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}memoryMapRefType with content type EMPTY
class memoryMapRefType (pyxb.binding.basis.complexTypeDefinition):
    """Base type for an element which references an memory map.  Reference is kept in an attribute rather than the text value, so that the type may be extended with child elements if necessary."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'memoryMapRefType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 186, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute memoryMapRef uses Python identifier memoryMapRef
    __memoryMapRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'memoryMapRef'), 'memoryMapRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryMapRefType_memoryMapRef', pyxb.binding.datatypes.Name, required=True)
    __memoryMapRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 190, 2)
    __memoryMapRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 190, 2)
    
    memoryMapRef = property(__memoryMapRef.value, __memoryMapRef.set, None, 'A reference to a unique memory map.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __memoryMapRef.name() : __memoryMapRef
    })
Namespace.addCategoryObject('typeBinding', 'memoryMapRefType', memoryMapRefType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_111 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 203, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandle uses Python identifier accessHandle
    __accessHandle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), 'accessHandle', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_111_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandle', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 205, 6), )

    
    accessHandle = property(__accessHandle.value, __accessHandle.set, None, None)

    _ElementMap.update({
        __accessHandle.name() : __accessHandle
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_112 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 221, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandle uses Python identifier accessHandle
    __accessHandle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), 'accessHandle', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_112_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandle', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 223, 6), )

    
    accessHandle = property(__accessHandle.value, __accessHandle.set, None, None)

    _ElementMap.update({
        __accessHandle.name() : __accessHandle
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bankedBlockType with content type ELEMENT_ONLY
class bankedBlockType (pyxb.binding.basis.complexTypeDefinition):
    """Address blocks inside a bank do not specify address."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'bankedBlockType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 232, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandles uses Python identifier accessHandles
    __accessHandles = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), 'accessHandles', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandles', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 238, 3), )

    
    accessHandles = property(__accessHandles.value, __accessHandles.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}volatile uses Python identifier volatile
    __volatile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'volatile'), 'volatile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014volatile', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), )

    
    volatile = property(__volatile.value, __volatile.set, None, 'Indicates whether the data is volatile.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}access uses Python identifier access
    __access = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'access'), 'access', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014access', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1), )

    
    access = property(__access.value, __access.set, None, "Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}range uses Python identifier range
    __range = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'range'), 'range', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014range', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 659, 3), )

    
    range = property(__range.value, __range.set, None, 'The address range of an address block.  Expressed as the number of addressable units accessible to the block. The range and the width are related by the following formulas:\n\t\t\t\t\tnumber_of_bits_in_block = ipxact:addressUnitBits * ipxact:range\n\t\t\t\t\tnumber_of_rows_in_block = number_of_bits_in_block / ipxact:width\n\t\t\t\t\t')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}width uses Python identifier width
    __width = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'width'), 'width', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014width', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 667, 3), )

    
    width = property(__width.value, __width.set, None, 'The bit width of a row in the address block. The range and the width are related by the following formulas:\n\t\t\t\t\tnumber_of_bits_in_block = ipxact:addressUnitBits * ipxact:range\n\t\t\t\t\tnumber_of_rows_in_block = number_of_bits_in_block / ipxact:width\n\t\t\t\t\t')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}usage uses Python identifier usage
    __usage = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'usage'), 'usage', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014usage', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3), )

    
    usage = property(__usage.value, __usage.set, None, "Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}register uses Python identifier register
    __register = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'register'), 'register', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014register', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 703, 3), )

    
    register = property(__register.value, __register.set, None, 'A single register')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}registerFile uses Python identifier registerFile
    __registerFile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'registerFile'), 'registerFile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014registerFile', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 984, 1), )

    
    registerFile = property(__registerFile.value, __registerFile.set, None, 'A structure of registers and register files')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBlockType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __accessHandles.name() : __accessHandles,
        __volatile.name() : __volatile,
        __access.name() : __access,
        __range.name() : __range,
        __width.name() : __width,
        __usage.name() : __usage,
        __register.name() : __register,
        __registerFile.name() : __registerFile
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'bankedBlockType', bankedBlockType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_113 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 239, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandle uses Python identifier accessHandle
    __accessHandle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), 'accessHandle', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_113_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandle', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 241, 6), )

    
    accessHandle = property(__accessHandle.value, __accessHandle.set, None, None)

    _ElementMap.update({
        __accessHandle.name() : __accessHandle
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bankedSubspaceType with content type ELEMENT_ONLY
class bankedSubspaceType (pyxb.binding.basis.complexTypeDefinition):
    """Subspace references inside banks do not specify an address."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'bankedSubspaceType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 252, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedSubspaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedSubspaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedSubspaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 334, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedSubspaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedSubspaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedSubspaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedSubspaceType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute masterRef uses Python identifier masterRef
    __masterRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'masterRef'), 'masterRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedSubspaceType_masterRef', pyxb.binding.datatypes.Name, required=True)
    __masterRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 266, 2)
    __masterRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 266, 2)
    
    masterRef = property(__masterRef.value, __masterRef.set, None, 'For subspaceMap elements, this attribute identifies the master that contains the address space to be mapped.')

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent
    })
    _AttributeMap.update({
        __id.name() : __id,
        __masterRef.name() : __masterRef
    })
Namespace.addCategoryObject('typeBinding', 'bankedSubspaceType', bankedSubspaceType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fieldType with content type ELEMENT_ONLY
class fieldType (pyxb.binding.basis.complexTypeDefinition):
    """A field within a register"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'fieldType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 273, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandles uses Python identifier accessHandles
    __accessHandles = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), 'accessHandles', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandles', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 279, 3), )

    
    accessHandles = property(__accessHandles.value, __accessHandles.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bitOffset uses Python identifier bitOffset
    __bitOffset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'bitOffset'), 'bitOffset', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014bitOffset', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 287, 3), )

    
    bitOffset = property(__bitOffset.value, __bitOffset.set, None, "Offset of this field's bit 0 from bit 0 of the register.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}resets uses Python identifier resets
    __resets = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'resets'), 'resets', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014resets', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 292, 3), )

    
    resets = property(__resets.value, __resets.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}volatile uses Python identifier volatile
    __volatile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'volatile'), 'volatile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014volatile', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), )

    
    volatile = property(__volatile.value, __volatile.set, None, 'Indicates whether the data is volatile.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}access uses Python identifier access
    __access = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'access'), 'access', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014access', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1), )

    
    access = property(__access.value, __access.set, None, "Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}enumeratedValues uses Python identifier enumeratedValues
    __enumeratedValues = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'enumeratedValues'), 'enumeratedValues', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014enumeratedValues', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 815, 1), )

    
    enumeratedValues = property(__enumeratedValues.value, __enumeratedValues.set, None, 'Enumerates specific values that can be assigned to the bit field.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}modifiedWriteValue uses Python identifier modifiedWriteValue
    __modifiedWriteValue = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'modifiedWriteValue'), 'modifiedWriteValue', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014modifiedWriteValue', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 895, 3), )

    
    modifiedWriteValue = property(__modifiedWriteValue.value, __modifiedWriteValue.set, None, "If present this element describes the modification of field data caused by a write operation. 'oneToClear' means that in a bitwise fashion each write data bit of a one will clear the corresponding bit in the field. 'oneToSet' means that in a bitwise fashion each write data bit of a one will set the corresponding bit in the field.  'oneToToggle' means that in a bitwise fashion each write data bit of a one will toggle the corresponding bit in the field. 'zeroToClear' means that in a bitwise fashion each write data bit of a zero will clear the corresponding bit in the field. 'zeroToSet' means that in a bitwise fashion each write data bit of a zero will set the corresponding bit in the field. 'zeroToToggle' means that in a bitwise fashion each write data bit of a zero will toggle the corresponding bit in the field. 'clear' means any write to this field clears the field. 'set' means any write to the field sets the field. 'modify' means any write to this field may modify that data. If this element is not present the write operation data is written.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}writeValueConstraint uses Python identifier writeValueConstraint
    __writeValueConstraint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'writeValueConstraint'), 'writeValueConstraint', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014writeValueConstraint', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 907, 3), )

    
    writeValueConstraint = property(__writeValueConstraint.value, __writeValueConstraint.set, None, 'The legal values that may be written to a field. If not specified the legal values are not specified.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}readAction uses Python identifier readAction
    __readAction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'readAction'), 'readAction', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014readAction', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 912, 3), )

    
    readAction = property(__readAction.value, __readAction.set, None, "A list of possible actions for a read to set the field after the read. 'clear' means that after a read the field is cleared. 'set' means that after a read the field is set. 'modify' means after a read the field is modified. If not present the field value is not modified after a read.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}testable uses Python identifier testable
    __testable = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'testable'), 'testable', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014testable', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 924, 3), )

    
    testable = property(__testable.value, __testable.set, None, 'Can the field be tested with an automated register test routine. The presumed value is true if not specified.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}reserved uses Python identifier reserved
    __reserved = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'reserved'), 'reserved', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014reserved', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 948, 3), )

    
    reserved = property(__reserved.value, __reserved.set, None, "Indicates that the field should be documented as reserved. The presumed value is 'false' if not present.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}typeIdentifier uses Python identifier typeIdentifier
    __typeIdentifier = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier'), 'typeIdentifier', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014typeIdentifier', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1032, 3), )

    
    typeIdentifier = property(__typeIdentifier.value, __typeIdentifier.set, None, 'Identifier name used to indicate that multiple field elements contain the exact same information for the elements in the fieldDefinitionGroup.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bitWidth uses Python identifier bitWidth
    __bitWidth = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'bitWidth'), 'bitWidth', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014bitWidth', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1037, 3), )

    
    bitWidth = property(__bitWidth.value, __bitWidth.set, None, 'Width of the field in bits.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute fieldID uses Python identifier fieldID
    __fieldID = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'fieldID'), 'fieldID', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_fieldType_fieldID', pyxb.binding.datatypes.Name)
    __fieldID._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 308, 3)
    __fieldID._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 308, 3)
    
    fieldID = property(__fieldID.value, __fieldID.set, None, 'A unique identifier within a component for a field.')

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __accessHandles.name() : __accessHandles,
        __bitOffset.name() : __bitOffset,
        __resets.name() : __resets,
        __volatile.name() : __volatile,
        __access.name() : __access,
        __enumeratedValues.name() : __enumeratedValues,
        __modifiedWriteValue.name() : __modifiedWriteValue,
        __writeValueConstraint.name() : __writeValueConstraint,
        __readAction.name() : __readAction,
        __testable.name() : __testable,
        __reserved.name() : __reserved,
        __typeIdentifier.name() : __typeIdentifier,
        __bitWidth.name() : __bitWidth
    })
    _AttributeMap.update({
        __id.name() : __id,
        __fieldID.name() : __fieldID
    })
Namespace.addCategoryObject('typeBinding', 'fieldType', fieldType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_114 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 280, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandle uses Python identifier accessHandle
    __accessHandle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), 'accessHandle', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_114_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandle', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 282, 6), )

    
    accessHandle = property(__accessHandle.value, __accessHandle.set, None, None)

    _ElementMap.update({
        __accessHandle.name() : __accessHandle
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_115 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 293, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}reset uses Python identifier reset_
    __reset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'reset'), 'reset_', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_115_httpwww_accellera_orgXMLSchemaIPXACT1685_2014reset', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1133, 1), )

    
    reset_ = property(__reset.value, __reset.set, None, 'Register value at reset.')

    _ElementMap.update({
        __reset.name() : __reset
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}memoryMapType with content type ELEMENT_ONLY
class memoryMapType (pyxb.binding.basis.complexTypeDefinition):
    """Map of address space blocks on slave slave bus interface."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'memoryMapType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 328, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}subspaceMap uses Python identifier subspaceMap
    __subspaceMap = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'subspaceMap'), 'subspaceMap', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014subspaceMap', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 321, 3), )

    
    subspaceMap = property(__subspaceMap.value, __subspaceMap.set, None, 'Maps in an address subspace from across a bus bridge.  Its masterRef attribute refers by name to the master bus interface on the other side of the bridge.  It must match the masterRef attribute of a bridge element on the slave interface, and that bridge element must be designated as opaque.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}memoryRemap uses Python identifier memoryRemap
    __memoryRemap = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'memoryRemap'), 'memoryRemap', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014memoryRemap', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 336, 3), )

    
    memoryRemap = property(__memoryRemap.value, __memoryRemap.set, None, 'Additional memory map elements that are dependent on the component state.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}shared uses Python identifier shared
    __shared = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'shared'), 'shared', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014shared', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 346, 3), )

    
    shared = property(__shared.value, __shared.set, None, "When the value is 'yes', the contents of the memoryMap are shared by all the references to this memoryMap, when the value is 'no' the contents of the memoryMap is not shared and when the value is 'undefined' (default) the sharing of the memoryMap is undefined.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressBlock uses Python identifier addressBlock
    __addressBlock = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), 'addressBlock', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressBlock', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 432, 1), )

    
    addressBlock = property(__addressBlock.value, __addressBlock.set, None, 'This is a single contiguous block of memory inside a memory map.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bank uses Python identifier bank
    __bank = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'bank'), 'bank', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014bank', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 549, 1), )

    
    bank = property(__bank.value, __bank.set, None, "Represents a bank of memory made up of address blocks or other banks.  It has a bankAlignment attribute indicating whether its blocks are aligned in 'parallel' (occupying adjacent bit fields) or 'serial' (occupying contiguous addresses). Its child blocks do not contain addresses or bit offsets.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressUnitBits uses Python identifier addressUnitBits
    __addressUnitBits = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressUnitBits'), 'addressUnitBits', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressUnitBits', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 563, 1), )

    
    addressUnitBits = property(__addressUnitBits.value, __addressUnitBits.set, None, 'The number of data bits in an addressable unit. The default is byte addressable (8 bits).')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryMapType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __subspaceMap.name() : __subspaceMap,
        __memoryRemap.name() : __memoryRemap,
        __shared.name() : __shared,
        __addressBlock.name() : __addressBlock,
        __bank.name() : __bank,
        __addressUnitBits.name() : __addressUnitBits
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'memoryMapType', memoryMapType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}memoryRemapType with content type ELEMENT_ONLY
class memoryRemapType (pyxb.binding.basis.complexTypeDefinition):
    """Map of address space blocks on a slave bus interface in a specific remap state."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'memoryRemapType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 355, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryRemapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryRemapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryRemapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryRemapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}subspaceMap uses Python identifier subspaceMap
    __subspaceMap = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'subspaceMap'), 'subspaceMap', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryRemapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014subspaceMap', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 321, 3), )

    
    subspaceMap = property(__subspaceMap.value, __subspaceMap.set, None, 'Maps in an address subspace from across a bus bridge.  Its masterRef attribute refers by name to the master bus interface on the other side of the bridge.  It must match the masterRef attribute of a bridge element on the slave interface, and that bridge element must be designated as opaque.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressBlock uses Python identifier addressBlock
    __addressBlock = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), 'addressBlock', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryRemapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressBlock', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 432, 1), )

    
    addressBlock = property(__addressBlock.value, __addressBlock.set, None, 'This is a single contiguous block of memory inside a memory map.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bank uses Python identifier bank
    __bank = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'bank'), 'bank', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryRemapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014bank', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 549, 1), )

    
    bank = property(__bank.value, __bank.set, None, "Represents a bank of memory made up of address blocks or other banks.  It has a bankAlignment attribute indicating whether its blocks are aligned in 'parallel' (occupying adjacent bit fields) or 'serial' (occupying contiguous addresses). Its child blocks do not contain addresses or bit offsets.")

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryRemapType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute state uses Python identifier state
    __state = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'state'), 'state', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_memoryRemapType_state', pyxb.binding.datatypes.Name, required=True)
    __state._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 364, 2)
    __state._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 364, 2)
    
    state = property(__state.value, __state.set, None, 'State of the component in which the memory map is active.')

    _ElementMap.update({
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __subspaceMap.name() : __subspaceMap,
        __addressBlock.name() : __addressBlock,
        __bank.name() : __bank
    })
    _AttributeMap.update({
        __id.name() : __id,
        __state.name() : __state
    })
Namespace.addCategoryObject('typeBinding', 'memoryRemapType', memoryRemapType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}localMemoryMapType with content type ELEMENT_ONLY
class localMemoryMapType (pyxb.binding.basis.complexTypeDefinition):
    """Map of address space blocks on the local memory map of a master bus interface."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'localMemoryMapType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 371, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localMemoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localMemoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localMemoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localMemoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bank uses Python identifier bank
    __bank = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'bank'), 'bank', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localMemoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014bank', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 380, 7), )

    
    bank = property(__bank.value, __bank.set, None, "Represents a bank of memory made up of address blocks or other banks.  It has a bankAlignment attribute indicating whether its blocks are aligned in 'parallel' (occupying adjacent bit fields) or 'serial' (occupying contiguous addresses). Its child blocks do not contain addresses or bit offsets.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressBlock uses Python identifier addressBlock
    __addressBlock = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), 'addressBlock', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localMemoryMapType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressBlock', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 432, 1), )

    
    addressBlock = property(__addressBlock.value, __addressBlock.set, None, 'This is a single contiguous block of memory inside a memory map.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localMemoryMapType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __bank.name() : __bank,
        __addressBlock.name() : __addressBlock
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'localMemoryMapType', localMemoryMapType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}subspaceRefType with content type ELEMENT_ONLY
class subspaceRefType (pyxb.binding.basis.complexTypeDefinition):
    """Address subspace type.  Its subspaceReference attribute references the subspace from which the dimensions are taken."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'subspaceRefType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 393, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_subspaceRefType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_subspaceRefType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_subspaceRefType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_subspaceRefType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_subspaceRefType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_subspaceRefType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}baseAddress uses Python identifier baseAddress
    __baseAddress = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'baseAddress'), 'baseAddress', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_subspaceRefType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014baseAddress', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 558, 1), )

    
    baseAddress = property(__baseAddress.value, __baseAddress.set, None, 'Base of an address block, bank, subspace map or address space. Expressed as the number of addressable units from the containing memoryMap or localMemoryMap.')

    
    # Attribute masterRef uses Python identifier masterRef
    __masterRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'masterRef'), 'masterRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_subspaceRefType_masterRef', pyxb.binding.datatypes.Name, required=True)
    __masterRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 411, 2)
    __masterRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 411, 2)
    
    masterRef = property(__masterRef.value, __masterRef.set, None, 'For subspaceMap elements, this attribute identifies the master that contains the address space to be mapped.')

    
    # Attribute segmentRef uses Python identifier segmentRef
    __segmentRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'segmentRef'), 'segmentRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_subspaceRefType_segmentRef', pyxb.binding.datatypes.Name)
    __segmentRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 416, 2)
    __segmentRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 416, 2)
    
    segmentRef = property(__segmentRef.value, __segmentRef.set, None, 'Refernce to a segment of the addressSpace of the masterRef attribute.')

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __baseAddress.name() : __baseAddress
    })
    _AttributeMap.update({
        __masterRef.name() : __masterRef,
        __segmentRef.name() : __segmentRef
    })
Namespace.addCategoryObject('typeBinding', 'subspaceRefType', subspaceRefType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_116 (pyxb.binding.basis.complexTypeDefinition):
    """If this component is a bus master, this lists all the address spaces
defined by the component."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 451, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressSpace uses Python identifier addressSpace
    __addressSpace = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressSpace'), 'addressSpace', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_116_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressSpace', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 453, 4), )

    
    addressSpace = property(__addressSpace.value, __addressSpace.set, None, 'This defines a logical space, referenced by a bus master.')

    _ElementMap.update({
        __addressSpace.name() : __addressSpace
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_117 (pyxb.binding.basis.complexTypeDefinition):
    """This defines a logical space, referenced by a bus master."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 457, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_117_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_117_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_117_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_117_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_117_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_117_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}executableImage uses Python identifier executableImage
    __executableImage = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'executableImage'), 'executableImage', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_117_httpwww_accellera_orgXMLSchemaIPXACT1685_2014executableImage', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 194, 4), )

    
    executableImage = property(__executableImage.value, __executableImage.set, None, 'Specifies an executable software image to be loaded into a processors address space. The format of the image is not specified. It could, for example, be an ELF loadfile, or it could be raw binary or ascii hex data for loading directly into a memory model instance.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}segments uses Python identifier segments
    __segments = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'segments'), 'segments', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_117_httpwww_accellera_orgXMLSchemaIPXACT1685_2014segments', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 462, 7), )

    
    segments = property(__segments.value, __segments.set, None, 'Address segments withing an addressSpace ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}localMemoryMap uses Python identifier localMemoryMap
    __localMemoryMap = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'localMemoryMap'), 'localMemoryMap', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_117_httpwww_accellera_orgXMLSchemaIPXACT1685_2014localMemoryMap', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 496, 7), )

    
    localMemoryMap = property(__localMemoryMap.value, __localMemoryMap.set, None, 'Provides the local memory map of an address space.  Blocks in this memory map are accessable to master interfaces on this component that reference this address space.   They are not accessable to any external master interface.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressUnitBits uses Python identifier addressUnitBits
    __addressUnitBits = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressUnitBits'), 'addressUnitBits', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_117_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressUnitBits', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 563, 1), )

    
    addressUnitBits = property(__addressUnitBits.value, __addressUnitBits.set, None, 'The number of data bits in an addressable unit. The default is byte addressable (8 bits).')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}range uses Python identifier range
    __range = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'range'), 'range', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_117_httpwww_accellera_orgXMLSchemaIPXACT1685_2014range', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 659, 3), )

    
    range = property(__range.value, __range.set, None, 'The address range of an address block.  Expressed as the number of addressable units accessible to the block. The range and the width are related by the following formulas:\n\t\t\t\t\tnumber_of_bits_in_block = ipxact:addressUnitBits * ipxact:range\n\t\t\t\t\tnumber_of_rows_in_block = number_of_bits_in_block / ipxact:width\n\t\t\t\t\t')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}width uses Python identifier width
    __width = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'width'), 'width', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_117_httpwww_accellera_orgXMLSchemaIPXACT1685_2014width', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 667, 3), )

    
    width = property(__width.value, __width.set, None, 'The bit width of a row in the address block. The range and the width are related by the following formulas:\n\t\t\t\t\tnumber_of_bits_in_block = ipxact:addressUnitBits * ipxact:range\n\t\t\t\t\tnumber_of_rows_in_block = number_of_bits_in_block / ipxact:width\n\t\t\t\t\t')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_117_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __executableImage.name() : __executableImage,
        __segments.name() : __segments,
        __localMemoryMap.name() : __localMemoryMap,
        __addressUnitBits.name() : __addressUnitBits,
        __range.name() : __range,
        __width.name() : __width
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_118 (pyxb.binding.basis.complexTypeDefinition):
    """Address segments withing an addressSpace """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 466, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}segment uses Python identifier segment
    __segment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'segment'), 'segment', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_118_httpwww_accellera_orgXMLSchemaIPXACT1685_2014segment', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 468, 10), )

    
    segment = property(__segment.value, __segment.set, None, 'Address segment withing an addressSpace ')

    _ElementMap.update({
        __segment.name() : __segment
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_119 (pyxb.binding.basis.complexTypeDefinition):
    """Address segment withing an addressSpace """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 472, 11)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_119_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_119_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_119_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_119_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_119_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressOffset uses Python identifier addressOffset
    __addressOffset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressOffset'), 'addressOffset', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_119_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressOffset', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 476, 13), )

    
    addressOffset = property(__addressOffset.value, __addressOffset.set, None, 'Address offset of the segment within the containing address space.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}range uses Python identifier range
    __range = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'range'), 'range', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_119_httpwww_accellera_orgXMLSchemaIPXACT1685_2014range', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 481, 13), )

    
    range = property(__range.value, __range.set, None, 'The address range of asegment.  Expressed as the number of addressable units accessible to the segment. \t\t\t\t')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_119_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __addressOffset.name() : __addressOffset,
        __range.name() : __range
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_120 (pyxb.binding.basis.complexTypeDefinition):
    """Lists all the slave memory maps defined by the component."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 531, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}memoryMap uses Python identifier memoryMap
    __memoryMap = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'memoryMap'), 'memoryMap', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_120_httpwww_accellera_orgXMLSchemaIPXACT1685_2014memoryMap', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 533, 4), )

    
    memoryMap = property(__memoryMap.value, __memoryMap.set, None, "The set of address blocks a bus slave contributes to the bus' address space.")

    _ElementMap.update({
        __memoryMap.name() : __memoryMap
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_121 (pyxb.binding.basis.complexTypeDefinition):
    """A single register"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 707, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}volatile uses Python identifier volatile
    __volatile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'volatile'), 'volatile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014volatile', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), )

    
    volatile = property(__volatile.value, __volatile.set, None, 'Indicates whether the data is volatile.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}access uses Python identifier access
    __access = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'access'), 'access', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014access', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1), )

    
    access = property(__access.value, __access.set, None, "Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandles uses Python identifier accessHandles
    __accessHandles = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), 'accessHandles', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandles', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 710, 6), )

    
    accessHandles = property(__accessHandles.value, __accessHandles.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}dim uses Python identifier dim
    __dim = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'dim'), 'dim', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014dim', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 718, 6), )

    
    dim = property(__dim.value, __dim.set, None, 'Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressOffset uses Python identifier addressOffset
    __addressOffset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressOffset'), 'addressOffset', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressOffset', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 730, 6), )

    
    addressOffset = property(__addressOffset.value, __addressOffset.set, None, "Offset from the address block's baseAddress or the containing register file's addressOffset, expressed as the number of addressUnitBits from the containing memoryMap or localMemoryMap.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}alternateRegisters uses Python identifier alternateRegisters
    __alternateRegisters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'alternateRegisters'), 'alternateRegisters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014alternateRegisters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 754, 1), )

    
    alternateRegisters = property(__alternateRegisters.value, __alternateRegisters.set, None, 'Alternate definitions for the current register')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}typeIdentifier uses Python identifier typeIdentifier
    __typeIdentifier = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier'), 'typeIdentifier', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014typeIdentifier', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1083, 3), )

    
    typeIdentifier = property(__typeIdentifier.value, __typeIdentifier.set, None, 'Identifier name used to indicate that multiple register elements contain the exact same information for the elements in the registerDefinitionGroup.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}size uses Python identifier size
    __size = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'size'), 'size', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014size', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1088, 3), )

    
    size = property(__size.value, __size.set, None, 'Width of the register in bits.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}field uses Python identifier field
    __field = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'field'), 'field', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_accellera_orgXMLSchemaIPXACT1685_2014field', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1096, 4), )

    
    field = property(__field.value, __field.set, None, 'Describes individual bit fields within the register.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_121_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __volatile.name() : __volatile,
        __access.name() : __access,
        __accessHandles.name() : __accessHandles,
        __dim.name() : __dim,
        __addressOffset.name() : __addressOffset,
        __alternateRegisters.name() : __alternateRegisters,
        __typeIdentifier.name() : __typeIdentifier,
        __size.name() : __size,
        __field.name() : __field
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_122 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 711, 7)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandle uses Python identifier accessHandle
    __accessHandle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), 'accessHandle', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_122_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandle', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 713, 9), )

    
    accessHandle = property(__accessHandle.value, __accessHandle.set, None, None)

    _ElementMap.update({
        __accessHandle.name() : __accessHandle
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_123 (pyxb.binding.basis.complexTypeDefinition):
    """Alternate definitions for the current register"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 758, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}alternateRegister uses Python identifier alternateRegister
    __alternateRegister = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'alternateRegister'), 'alternateRegister', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_123_httpwww_accellera_orgXMLSchemaIPXACT1685_2014alternateRegister', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 760, 4), )

    
    alternateRegister = property(__alternateRegister.value, __alternateRegister.set, None, 'Alternate definition for the current register')

    _ElementMap.update({
        __alternateRegister.name() : __alternateRegister
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_124 (pyxb.binding.basis.complexTypeDefinition):
    """Alternate definition for the current register"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 764, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_124_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_124_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_124_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_124_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_124_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_124_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}volatile uses Python identifier volatile
    __volatile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'volatile'), 'volatile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_124_httpwww_accellera_orgXMLSchemaIPXACT1685_2014volatile', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), )

    
    volatile = property(__volatile.value, __volatile.set, None, 'Indicates whether the data is volatile.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}access uses Python identifier access
    __access = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'access'), 'access', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_124_httpwww_accellera_orgXMLSchemaIPXACT1685_2014access', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1), )

    
    access = property(__access.value, __access.set, None, "Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandles uses Python identifier accessHandles
    __accessHandles = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), 'accessHandles', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_124_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandles', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 767, 7), )

    
    accessHandles = property(__accessHandles.value, __accessHandles.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}alternateGroups uses Python identifier alternateGroups
    __alternateGroups = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'alternateGroups'), 'alternateGroups', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_124_httpwww_accellera_orgXMLSchemaIPXACT1685_2014alternateGroups', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 775, 7), )

    
    alternateGroups = property(__alternateGroups.value, __alternateGroups.set, None, 'Defines a list of grouping names that this register description belongs.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}typeIdentifier uses Python identifier typeIdentifier
    __typeIdentifier = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier'), 'typeIdentifier', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_124_httpwww_accellera_orgXMLSchemaIPXACT1685_2014typeIdentifier', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1113, 3), )

    
    typeIdentifier = property(__typeIdentifier.value, __typeIdentifier.set, None, 'Identifier name used to indicate that multiple register elements contain the exact same information for the elements in the alternateRegisterDefinitionGroup.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}field uses Python identifier field
    __field = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'field'), 'field', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_124_httpwww_accellera_orgXMLSchemaIPXACT1685_2014field', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1121, 4), )

    
    field = property(__field.value, __field.set, None, 'Describes individual bit fields within the register.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_124_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __volatile.name() : __volatile,
        __access.name() : __access,
        __accessHandles.name() : __accessHandles,
        __alternateGroups.name() : __alternateGroups,
        __typeIdentifier.name() : __typeIdentifier,
        __field.name() : __field
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_125 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 768, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandle uses Python identifier accessHandle
    __accessHandle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), 'accessHandle', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_125_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandle', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 770, 10), )

    
    accessHandle = property(__accessHandle.value, __accessHandle.set, None, None)

    _ElementMap.update({
        __accessHandle.name() : __accessHandle
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_126 (pyxb.binding.basis.complexTypeDefinition):
    """Defines a list of grouping names that this register description belongs."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 779, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}alternateGroup uses Python identifier alternateGroup
    __alternateGroup = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'alternateGroup'), 'alternateGroup', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_126_httpwww_accellera_orgXMLSchemaIPXACT1685_2014alternateGroup', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 781, 10), )

    
    alternateGroup = property(__alternateGroup.value, __alternateGroup.set, None, 'Defines a grouping name that this register description belongs.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_126_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __alternateGroup.name() : __alternateGroup
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_127 (pyxb.binding.basis.complexTypeDefinition):
    """Defines a grouping name that this register description belongs."""
    _TypeDefinition = pyxb.binding.datatypes.Name
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 785, 11)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.Name
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_127_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_128 (pyxb.binding.basis.complexTypeDefinition):
    """Enumerates specific values that can be assigned to the bit field."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 819, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}enumeratedValue uses Python identifier enumeratedValue
    __enumeratedValue = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'enumeratedValue'), 'enumeratedValue', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_128_httpwww_accellera_orgXMLSchemaIPXACT1685_2014enumeratedValue', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 821, 4), )

    
    enumeratedValue = property(__enumeratedValue.value, __enumeratedValue.set, None, 'Enumerates specific values that can be assigned to the bit field. The name of this enumerated value. This may be used as a token in generating code.')

    _ElementMap.update({
        __enumeratedValue.name() : __enumeratedValue
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}valueMaskConfigType with content type EMPTY
class valueMaskConfigType (pyxb.binding.basis.complexTypeDefinition):
    """This type is used to specify a value and optional mask that are configurable"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'valueMaskConfigType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 857, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'valueMaskConfigType', valueMaskConfigType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}writeValueConstraintType with content type ELEMENT_ONLY
class writeValueConstraintType (pyxb.binding.basis.complexTypeDefinition):
    """A constraint on the values that can be written to this field. Absence of this element implies that any value that fits can be written to it."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'writeValueConstraintType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 955, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}writeAsRead uses Python identifier writeAsRead
    __writeAsRead = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'writeAsRead'), 'writeAsRead', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_writeValueConstraintType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014writeAsRead', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 960, 3), )

    
    writeAsRead = property(__writeAsRead.value, __writeAsRead.set, None, 'writeAsRead indicates that only a value immediately read before a write is a legal value to be written.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}useEnumeratedValues uses Python identifier useEnumeratedValues
    __useEnumeratedValues = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'useEnumeratedValues'), 'useEnumeratedValues', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_writeValueConstraintType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014useEnumeratedValues', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 965, 3), )

    
    useEnumeratedValues = property(__useEnumeratedValues.value, __useEnumeratedValues.set, None, 'useEnumeratedValues indicates that only write enumeration value shall be legal values to be written.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'minimum'), 'minimum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_writeValueConstraintType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014minimum', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 971, 4), )

    
    minimum = property(__minimum.value, __minimum.set, None, 'The minimum legal value that may be written to a field')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'maximum'), 'maximum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_writeValueConstraintType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014maximum', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 976, 4), )

    
    maximum = property(__maximum.value, __maximum.set, None, 'The maximum legal value that may be written to a field')

    _ElementMap.update({
        __writeAsRead.name() : __writeAsRead,
        __useEnumeratedValues.name() : __useEnumeratedValues,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'writeValueConstraintType', writeValueConstraintType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_129 (pyxb.binding.basis.complexTypeDefinition):
    """A structure of registers and register files"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 988, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_129_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_129_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_129_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_129_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_129_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_129_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}register uses Python identifier register
    __register = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'register'), 'register', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_129_httpwww_accellera_orgXMLSchemaIPXACT1685_2014register', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 703, 3), )

    
    register = property(__register.value, __register.set, None, 'A single register')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}registerFile uses Python identifier registerFile
    __registerFile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'registerFile'), 'registerFile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_129_httpwww_accellera_orgXMLSchemaIPXACT1685_2014registerFile', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 984, 1), )

    
    registerFile = property(__registerFile.value, __registerFile.set, None, 'A structure of registers and register files')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandles uses Python identifier accessHandles
    __accessHandles = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), 'accessHandles', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_129_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandles', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 991, 4), )

    
    accessHandles = property(__accessHandles.value, __accessHandles.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}dim uses Python identifier dim
    __dim = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'dim'), 'dim', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_129_httpwww_accellera_orgXMLSchemaIPXACT1685_2014dim', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 999, 4), )

    
    dim = property(__dim.value, __dim.set, None, 'Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressOffset uses Python identifier addressOffset
    __addressOffset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressOffset'), 'addressOffset', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_129_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressOffset', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1011, 4), )

    
    addressOffset = property(__addressOffset.value, __addressOffset.set, None, "Offset from the address block's baseAddress or the containing register file's addressOffset, expressed as the number of addressUnitBits from the containing memoryMap or localMemoryMap.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}typeIdentifier uses Python identifier typeIdentifier
    __typeIdentifier = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier'), 'typeIdentifier', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_129_httpwww_accellera_orgXMLSchemaIPXACT1685_2014typeIdentifier', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1050, 3), )

    
    typeIdentifier = property(__typeIdentifier.value, __typeIdentifier.set, None, 'Identifier name used to indicate that multiple registerFile elements contain the exact same information except for the elements in the registerFileInstanceGroup.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}range uses Python identifier range
    __range = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'range'), 'range', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_129_httpwww_accellera_orgXMLSchemaIPXACT1685_2014range', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1055, 3), )

    
    range = property(__range.value, __range.set, None, 'The range of a register file.  Expressed as the number of addressable units accessible to the block. Specified in units of addressUnitBits.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_129_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __register.name() : __register,
        __registerFile.name() : __registerFile,
        __accessHandles.name() : __accessHandles,
        __dim.name() : __dim,
        __addressOffset.name() : __addressOffset,
        __typeIdentifier.name() : __typeIdentifier,
        __range.name() : __range
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_130 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 992, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandle uses Python identifier accessHandle
    __accessHandle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), 'accessHandle', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_130_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandle', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 994, 7), )

    
    accessHandle = property(__accessHandle.value, __accessHandle.set, None, None)

    _ElementMap.update({
        __accessHandle.name() : __accessHandle
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_131 (pyxb.binding.basis.complexTypeDefinition):
    """Register value at reset."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1137, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}value uses Python identifier value_
    __value = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'value'), 'value_', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_131_httpwww_accellera_orgXMLSchemaIPXACT1685_2014value', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1139, 4), )

    
    value_ = property(__value.value, __value.set, None, 'The value itself.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}mask uses Python identifier mask
    __mask = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'mask'), 'mask', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_131_httpwww_accellera_orgXMLSchemaIPXACT1685_2014mask', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1144, 4), )

    
    mask = property(__mask.value, __mask.set, None, 'Mask to be anded with the value before comparing to the reset value.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_131_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute resetTypeRef uses Python identifier resetTypeRef
    __resetTypeRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'resetTypeRef'), 'resetTypeRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_131_resetTypeRef', pyxb.binding.datatypes.Name)
    __resetTypeRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1150, 3)
    __resetTypeRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1150, 3)
    
    resetTypeRef = property(__resetTypeRef.value, __resetTypeRef.set, None, 'Reference to a user defined resetType. Assumed to be HARD if not present.')

    _ElementMap.update({
        __value.name() : __value,
        __mask.name() : __mask
    })
    _AttributeMap.update({
        __id.name() : __id,
        __resetTypeRef.name() : __resetTypeRef
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}designInstantiationType with content type ELEMENT_ONLY
class designInstantiationType (pyxb.binding.basis.complexTypeDefinition):
    """Design instantiation type."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'designInstantiationType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 59, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_designInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_designInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_designInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_designInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}designRef uses Python identifier designRef
    __designRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'designRef'), 'designRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_designInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014designRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 65, 3), )

    
    designRef = property(__designRef.value, __designRef.set, None, 'References an IP-XACT design document (by VLNV) that provides a design for the component.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_designInstantiationType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __designRef.name() : __designRef
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'designInstantiationType', designInstantiationType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}designConfigurationInstantiationType with content type ELEMENT_ONLY
class designConfigurationInstantiationType (pyxb.binding.basis.complexTypeDefinition):
    """Design configuration instantiation type."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'designConfigurationInstantiationType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 74, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_designConfigurationInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_designConfigurationInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_designConfigurationInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_designConfigurationInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_designConfigurationInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}language uses Python identifier language
    __language = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'language'), 'language', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_designConfigurationInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014language', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 80, 3), )

    
    language = property(__language.value, __language.set, None, ' The hardware description language used such as "verilog" or "vhdl". If the attribute "strict" is "true", this value must match the language being generated for the design.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}designConfigurationRef uses Python identifier designConfigurationRef
    __designConfigurationRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'designConfigurationRef'), 'designConfigurationRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_designConfigurationInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014designConfigurationRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 85, 3), )

    
    designConfigurationRef = property(__designConfigurationRef.value, __designConfigurationRef.set, None, "References an IP-XACT design configuration document (by VLNV) that provides a configuration for the component's design.")

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_designConfigurationInstantiationType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __language.name() : __language,
        __designConfigurationRef.name() : __designConfigurationRef
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'designConfigurationInstantiationType', designConfigurationInstantiationType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}componentInstantiationType with content type ELEMENT_ONLY
class componentInstantiationType (pyxb.binding.basis.complexTypeDefinition):
    """Component instantiation type"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'componentInstantiationType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 95, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}constraintSetRef uses Python identifier constraintSetRef
    __constraintSetRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'constraintSetRef'), 'constraintSetRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014constraintSetRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 269, 4), )

    
    constraintSetRef = property(__constraintSetRef.value, __constraintSetRef.set, None, 'A reference to a set of port constraints.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileSetRef uses Python identifier fileSetRef
    __fileSetRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'fileSetRef'), 'fileSetRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014fileSetRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 309, 4), )

    
    fileSetRef = property(__fileSetRef.value, __fileSetRef.set, None, 'A reference to a fileSet.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isVirtual uses Python identifier isVirtual
    __isVirtual = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isVirtual'), 'isVirtual', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isVirtual', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 101, 3), )

    
    isVirtual = property(__isVirtual.value, __isVirtual.set, None, 'When true, indicates that this component should not be netlisted.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}language uses Python identifier language
    __language = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'language'), 'language', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014language', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 106, 3), )

    
    language = property(__language.value, __language.set, None, ' The hardware description language used such as "verilog" or "vhdl". If the attribute "strict" is "true", this value must match the language being generated for the design.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}libraryName uses Python identifier libraryName
    __libraryName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'libraryName'), 'libraryName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014libraryName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 111, 3), )

    
    libraryName = property(__libraryName.value, __libraryName.set, None, 'A string specifying the library name in which the model should be compiled. If the libraryName element is not present then its value defaults to \u201cwork\u201d.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}packageName uses Python identifier packageName
    __packageName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'packageName'), 'packageName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014packageName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 116, 3), )

    
    packageName = property(__packageName.value, __packageName.set, None, 'A string describing the VHDL package containing the interface of the model. If the packageName element is not present then its value defaults to the component VLNV name concatenated with postfix \u201c_cmp_pkg\u201d which stands for component package.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}moduleName uses Python identifier moduleName
    __moduleName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'moduleName'), 'moduleName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014moduleName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 121, 3), )

    
    moduleName = property(__moduleName.value, __moduleName.set, None, 'A string describing the Verilog, SystemVerilog, or SystemC module name or the VHDL entity name. If the moduleName is not present then its value defaults to the component VLNV name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}architectureName uses Python identifier architectureName
    __architectureName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'architectureName'), 'architectureName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014architectureName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 126, 3), )

    
    architectureName = property(__architectureName.value, __architectureName.set, None, 'A string describing the VHDL architecture name. If the architectureName element is not present then its value defaults to \u201crtl\u201d.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}configurationName uses Python identifier configurationName
    __configurationName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'configurationName'), 'configurationName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014configurationName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 131, 3), )

    
    configurationName = property(__configurationName.value, __configurationName.set, None, 'A string describing the Verilog, SystemVerilog, or VHDL configuration name. If the configurationName element is not present then its value defaults to the design configuration VLNV name of the design configuration associated with the active hierarchical view or, if there is no active hierarchical view, to the component VLNV name concatenated with postfix \u201c_rtl_cfg\u201d.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}moduleParameters uses Python identifier moduleParameters
    __moduleParameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'moduleParameters'), 'moduleParameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014moduleParameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 136, 3), )

    
    moduleParameters = property(__moduleParameters.value, __moduleParameters.set, None, 'Model parameter name value pairs container')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}defaultFileBuilder uses Python identifier defaultFileBuilder
    __defaultFileBuilder = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'defaultFileBuilder'), 'defaultFileBuilder', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014defaultFileBuilder', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 151, 3), )

    
    defaultFileBuilder = property(__defaultFileBuilder.value, __defaultFileBuilder.set, None, 'Default command and flags used to build derived files from the sourceName files in the referenced file sets.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}whiteboxElementRefs uses Python identifier whiteboxElementRefs
    __whiteboxElementRefs = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'whiteboxElementRefs'), 'whiteboxElementRefs', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014whiteboxElementRefs', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 158, 3), )

    
    whiteboxElementRefs = property(__whiteboxElementRefs.value, __whiteboxElementRefs.set, None, ' Container for white box element references.  ')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_componentInstantiationType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __constraintSetRef.name() : __constraintSetRef,
        __fileSetRef.name() : __fileSetRef,
        __isVirtual.name() : __isVirtual,
        __language.name() : __language,
        __libraryName.name() : __libraryName,
        __packageName.name() : __packageName,
        __moduleName.name() : __moduleName,
        __architectureName.name() : __architectureName,
        __configurationName.name() : __configurationName,
        __moduleParameters.name() : __moduleParameters,
        __defaultFileBuilder.name() : __defaultFileBuilder,
        __whiteboxElementRefs.name() : __whiteboxElementRefs
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'componentInstantiationType', componentInstantiationType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_132 (pyxb.binding.basis.complexTypeDefinition):
    """Model parameter name value pairs container"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 140, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}moduleParameter uses Python identifier moduleParameter
    __moduleParameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'moduleParameter'), 'moduleParameter', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_132_httpwww_accellera_orgXMLSchemaIPXACT1685_2014moduleParameter', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 142, 6), )

    
    moduleParameter = property(__moduleParameter.value, __moduleParameter.set, None, 'A module parameter name value pair. The name is given in an attribute. The value is the element value. The dataType (applicable to high level modeling) is given in the dataType attribute. For hardware based models, the name should be identical to the RTL (VHDL generic or Verilog parameter). The usageType attribute indicates how the model parameter is to be used.\n\t\t\t\t\t\t\t\t\t\t')

    _ElementMap.update({
        __moduleParameter.name() : __moduleParameter
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_133 (pyxb.binding.basis.complexTypeDefinition):
    """ Container for white box element references.  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 162, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}whiteboxElementRef uses Python identifier whiteboxElementRef
    __whiteboxElementRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'whiteboxElementRef'), 'whiteboxElementRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_133_httpwww_accellera_orgXMLSchemaIPXACT1685_2014whiteboxElementRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 164, 6), )

    
    whiteboxElementRef = property(__whiteboxElementRef.value, __whiteboxElementRef.set, None, ' Reference to a white box element which is visible within this view.  ')

    _ElementMap.update({
        __whiteboxElementRef.name() : __whiteboxElementRef
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}modelType with content type ELEMENT_ONLY
class modelType (pyxb.binding.basis.complexTypeDefinition):
    """Model information.
			"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'modelType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 196, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}views uses Python identifier views
    __views = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'views'), 'views', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_modelType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014views', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 202, 3), )

    
    views = property(__views.value, __views.set, None, 'Views container')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}instantiations uses Python identifier instantiations
    __instantiations = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'instantiations'), 'instantiations', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_modelType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014instantiations', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 237, 3), )

    
    instantiations = property(__instantiations.value, __instantiations.set, None, 'Instantiations container')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}ports uses Python identifier ports
    __ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'ports'), 'ports', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_modelType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014ports', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 251, 3), )

    
    ports = property(__ports.value, __ports.set, None, 'Port container')

    _ElementMap.update({
        __views.name() : __views,
        __instantiations.name() : __instantiations,
        __ports.name() : __ports
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'modelType', modelType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_134 (pyxb.binding.basis.complexTypeDefinition):
    """Views container"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 206, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}view uses Python identifier view
    __view = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'view'), 'view', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_134_httpwww_accellera_orgXMLSchemaIPXACT1685_2014view', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 208, 6), )

    
    view = property(__view.value, __view.set, None, 'Single view of a component')

    _ElementMap.update({
        __view.name() : __view
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_135 (pyxb.binding.basis.complexTypeDefinition):
    """Single view of a component"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 212, 7)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_135_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_135_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_135_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_135_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}envIdentifier uses Python identifier envIdentifier
    __envIdentifier = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'envIdentifier'), 'envIdentifier', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_135_httpwww_accellera_orgXMLSchemaIPXACT1685_2014envIdentifier', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 216, 9), )

    
    envIdentifier = property(__envIdentifier.value, __envIdentifier.set, None, ' Defines the hardware environment in which this view applies. The format of the string is language:tool:vendor_extension, with each piece being optional. The language must be one of the types from ipxact:fileType. The tool values are defined by the Accellera Systems Initiative, and include generic values "*Simulation" and "*Synthesis" to imply any tool of the indicated type. Having more than one envIdentifier indicates that the view applies to multiple environments.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}componentInstantiationRef uses Python identifier componentInstantiationRef
    __componentInstantiationRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'componentInstantiationRef'), 'componentInstantiationRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_135_httpwww_accellera_orgXMLSchemaIPXACT1685_2014componentInstantiationRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 228, 9), )

    
    componentInstantiationRef = property(__componentInstantiationRef.value, __componentInstantiationRef.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}designInstantiationRef uses Python identifier designInstantiationRef
    __designInstantiationRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'designInstantiationRef'), 'designInstantiationRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_135_httpwww_accellera_orgXMLSchemaIPXACT1685_2014designInstantiationRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 229, 9), )

    
    designInstantiationRef = property(__designInstantiationRef.value, __designInstantiationRef.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}designConfigurationInstantiationRef uses Python identifier designConfigurationInstantiationRef
    __designConfigurationInstantiationRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'designConfigurationInstantiationRef'), 'designConfigurationInstantiationRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_135_httpwww_accellera_orgXMLSchemaIPXACT1685_2014designConfigurationInstantiationRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 230, 9), )

    
    designConfigurationInstantiationRef = property(__designConfigurationInstantiationRef.value, __designConfigurationInstantiationRef.set, None, None)

    _ElementMap.update({
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __envIdentifier.name() : __envIdentifier,
        __componentInstantiationRef.name() : __componentInstantiationRef,
        __designInstantiationRef.name() : __designInstantiationRef,
        __designConfigurationInstantiationRef.name() : __designConfigurationInstantiationRef
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_136 (pyxb.binding.basis.complexTypeDefinition):
    """Instantiations container"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 241, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}componentInstantiation uses Python identifier componentInstantiation
    __componentInstantiation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'componentInstantiation'), 'componentInstantiation', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_136_httpwww_accellera_orgXMLSchemaIPXACT1685_2014componentInstantiation', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 179, 3), )

    
    componentInstantiation = property(__componentInstantiation.value, __componentInstantiation.set, None, 'Component Instantiation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}designInstantiation uses Python identifier designInstantiation
    __designInstantiation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'designInstantiation'), 'designInstantiation', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_136_httpwww_accellera_orgXMLSchemaIPXACT1685_2014designInstantiation', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 184, 3), )

    
    designInstantiation = property(__designInstantiation.value, __designInstantiation.set, None, 'Design Instantiation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}designConfigurationInstantiation uses Python identifier designConfigurationInstantiation
    __designConfigurationInstantiation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'designConfigurationInstantiation'), 'designConfigurationInstantiation', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_136_httpwww_accellera_orgXMLSchemaIPXACT1685_2014designConfigurationInstantiation', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 189, 3), )

    
    designConfigurationInstantiation = property(__designConfigurationInstantiation.value, __designConfigurationInstantiation.set, None, 'Design Configuration Instantiation')

    _ElementMap.update({
        __componentInstantiation.name() : __componentInstantiation,
        __designInstantiation.name() : __designInstantiation,
        __designConfigurationInstantiation.name() : __designConfigurationInstantiation
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_137 (pyxb.binding.basis.complexTypeDefinition):
    """Port container"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 255, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}port uses Python identifier port
    __port = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'port'), 'port', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_137_httpwww_accellera_orgXMLSchemaIPXACT1685_2014port', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 452, 1), )

    
    port = property(__port.value, __port.set, None, 'Describes port characteristics.')

    _ElementMap.update({
        __port.name() : __port
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractorModelType with content type ELEMENT_ONLY
class abstractorModelType (pyxb.binding.basis.complexTypeDefinition):
    """Model information for an abstractor."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'abstractorModelType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 263, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}views uses Python identifier views
    __views = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'views'), 'views', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorModelType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014views', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 268, 3), )

    
    views = property(__views.value, __views.set, None, 'Views container')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}instantiations uses Python identifier instantiations
    __instantiations = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'instantiations'), 'instantiations', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorModelType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014instantiations', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 301, 3), )

    
    instantiations = property(__instantiations.value, __instantiations.set, None, 'Instantiations container')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}ports uses Python identifier ports
    __ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'ports'), 'ports', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_abstractorModelType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014ports', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 315, 3), )

    
    ports = property(__ports.value, __ports.set, None, 'Port container')

    _ElementMap.update({
        __views.name() : __views,
        __instantiations.name() : __instantiations,
        __ports.name() : __ports
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'abstractorModelType', abstractorModelType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_138 (pyxb.binding.basis.complexTypeDefinition):
    """Views container"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 272, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}view uses Python identifier view
    __view = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'view'), 'view', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_138_httpwww_accellera_orgXMLSchemaIPXACT1685_2014view', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 274, 6), )

    
    view = property(__view.value, __view.set, None, 'Single view of an abstracto')

    _ElementMap.update({
        __view.name() : __view
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_139 (pyxb.binding.basis.complexTypeDefinition):
    """Single view of an abstracto"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 278, 7)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_139_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_139_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_139_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_139_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}envIdentifier uses Python identifier envIdentifier
    __envIdentifier = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'envIdentifier'), 'envIdentifier', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_139_httpwww_accellera_orgXMLSchemaIPXACT1685_2014envIdentifier', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 282, 9), )

    
    envIdentifier = property(__envIdentifier.value, __envIdentifier.set, None, ' Defines the hardware environment in which this view applies. The format of the string is language:tool:vendor_extension, with each piece being optional. The language must be one of the types from ipxact:fileType. The tool values are defined by the Accellera Systems Initiative, and include generic values "*Simulation" and "*Synthesis" to imply any tool of the indicated type. Having more than one envIdentifier indicates that the view applies to multiple environments.  ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}componentInstantiationRef uses Python identifier componentInstantiationRef
    __componentInstantiationRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'componentInstantiationRef'), 'componentInstantiationRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_139_httpwww_accellera_orgXMLSchemaIPXACT1685_2014componentInstantiationRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 294, 9), )

    
    componentInstantiationRef = property(__componentInstantiationRef.value, __componentInstantiationRef.set, None, None)

    _ElementMap.update({
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __envIdentifier.name() : __envIdentifier,
        __componentInstantiationRef.name() : __componentInstantiationRef
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_140 (pyxb.binding.basis.complexTypeDefinition):
    """Instantiations container"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 305, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}componentInstantiation uses Python identifier componentInstantiation
    __componentInstantiation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'componentInstantiation'), 'componentInstantiation', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_140_httpwww_accellera_orgXMLSchemaIPXACT1685_2014componentInstantiation', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 307, 6), )

    
    componentInstantiation = property(__componentInstantiation.value, __componentInstantiation.set, None, 'Component Instantiation')

    _ElementMap.update({
        __componentInstantiation.name() : __componentInstantiation
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_141 (pyxb.binding.basis.complexTypeDefinition):
    """Port container"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 319, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}port uses Python identifier port
    __port = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'port'), 'port', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_141_httpwww_accellera_orgXMLSchemaIPXACT1685_2014port', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 321, 6), )

    
    port = property(__port.value, __port.set, None, None)

    _ElementMap.update({
        __port.name() : __port
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}whiteboxElementRefType with content type ELEMENT_ONLY
class whiteboxElementRefType (pyxb.binding.basis.complexTypeDefinition):
    """ Reference to a whiteboxElement within a view. The 'name' attribute must refer to a whiteboxElement defined within this component.  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'whiteboxElementRefType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 360, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_whiteboxElementRefType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}location uses Python identifier location
    __location = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'location'), 'location', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_whiteboxElementRefType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014location', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 366, 3), )

    
    location = property(__location.value, __location.set, None, 'The contents of each location element can be used to specified one location (HDL Path) through the referenced whiteBoxElement is accessible.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_whiteboxElementRefType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_whiteboxElementRefType_name', pyxb.binding.datatypes.Name, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 372, 2)
    __name._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 372, 2)
    
    name = property(__name.value, __name.set, None, 'Reference to a whiteboxElement defined within this component.  ')

    _ElementMap.update({
        __isPresent.name() : __isPresent,
        __location.name() : __location
    })
    _AttributeMap.update({
        __id.name() : __id,
        __name.name() : __name
    })
Namespace.addCategoryObject('typeBinding', 'whiteboxElementRefType', whiteboxElementRefType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}languageType with content type SIMPLE
class languageType (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}languageType with content type SIMPLE"""
    _TypeDefinition = pyxb.binding.datatypes.token
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'languageType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 379, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.token
    
    # Attribute strict uses Python identifier strict
    __strict = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'strict'), 'strict', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_languageType_strict', pyxb.binding.datatypes.boolean, unicode_default='false')
    __strict._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 382, 4)
    __strict._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 382, 4)
    
    strict = property(__strict.value, __strict.set, None, "A value of 'true' indicates that this value must match the language being generated for the design.")

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __strict.name() : __strict
    })
Namespace.addCategoryObject('typeBinding', 'languageType', languageType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portType with content type ELEMENT_ONLY
class portType (pyxb.binding.basis.complexTypeDefinition):
    """A port description, giving a name and an access type for high level ports. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'portType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 66, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 362, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}wire uses Python identifier wire
    __wire = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'wire'), 'wire', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014wire', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 77, 4), )

    
    wire = property(__wire.value, __wire.set, None, 'Defines a port whose type resolves to simple bits.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}transactional uses Python identifier transactional
    __transactional = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'transactional'), 'transactional', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014transactional', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 82, 4), )

    
    transactional = property(__transactional.value, __transactional.set, None, 'Defines a port that implements or uses a service that can be implemented with functions or methods.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}access uses Python identifier access
    __access = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'access'), 'access', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014access', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 89, 3), )

    
    access = property(__access.value, __access.set, None, 'Port access characteristics.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}arrays uses Python identifier arrays
    __arrays = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'arrays'), 'arrays', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014arrays', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 567, 1), )

    
    arrays = property(__arrays.value, __arrays.set, None, None)

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __wire.name() : __wire,
        __transactional.name() : __transactional,
        __access.name() : __access,
        __arrays.name() : __arrays
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'portType', portType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_142 (pyxb.binding.basis.complexTypeDefinition):
    """defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 161, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}protocolType uses Python identifier protocolType
    __protocolType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'protocolType'), 'protocolType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_142_httpwww_accellera_orgXMLSchemaIPXACT1685_2014protocolType', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 163, 4), )

    
    protocolType = property(__protocolType.value, __protocolType.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}payload uses Python identifier payload
    __payload = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'payload'), 'payload', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_142_httpwww_accellera_orgXMLSchemaIPXACT1685_2014payload', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 214, 1), )

    
    payload = property(__payload.value, __payload.set, None, 'defines the structure of data transported by this port')

    _ElementMap.update({
        __protocolType.name() : __protocolType,
        __payload.name() : __payload
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_143 (pyxb.binding.basis.complexTypeDefinition):
    """defines the structure of data transported by this port"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 218, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_143_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_143_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 220, 4), )

    
    name = property(__name.value, __name.set, None, 'Defines the name of the payload. For example: TLM2 or TLM1')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}type uses Python identifier type
    __type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'type'), 'type', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_143_httpwww_accellera_orgXMLSchemaIPXACT1685_2014type', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 225, 4), )

    
    type = property(__type.value, __type.set, None, 'Defines the type of the payload. ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}extension uses Python identifier extension
    __extension = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'extension'), 'extension', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_143_httpwww_accellera_orgXMLSchemaIPXACT1685_2014extension', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 236, 4), )

    
    extension = property(__extension.value, __extension.set, None, 'Defines the name of the payload extension. If attribute is not specified, it is by default optional.')

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __type.name() : __type,
        __extension.name() : __extension
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_144 (pyxb.binding.basis.complexTypeDefinition):
    """Defines the name of the payload extension. If attribute is not specified, it is by default optional."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 240, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute mandatory uses Python identifier mandatory
    __mandatory = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'mandatory'), 'mandatory', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_144_mandatory', pyxb.binding.datatypes.boolean, unicode_default='false')
    __mandatory._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 243, 8)
    __mandatory._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 243, 8)
    
    mandatory = property(__mandatory.value, __mandatory.set, None, 'True if the payload extension is mandatory.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __mandatory.name() : __mandatory
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_145 (pyxb.binding.basis.complexTypeDefinition):
    """list of port type parameters (e.g. template or constructor parameters for a systemC port or socket)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 260, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}typeParameter uses Python identifier typeParameter
    __typeParameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'typeParameter'), 'typeParameter', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_145_httpwww_accellera_orgXMLSchemaIPXACT1685_2014typeParameter', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 267, 1), )

    
    typeParameter = property(__typeParameter.value, __typeParameter.set, None, 'A typed parameter name value pair. The optional attribute dataType defines the type of the value and the usageType attribute indicates how the parameter is to be used.\n\t\t\t')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}serviceTypeDef uses Python identifier serviceTypeDef
    __serviceTypeDef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'serviceTypeDef'), 'serviceTypeDef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_145_httpwww_accellera_orgXMLSchemaIPXACT1685_2014serviceTypeDef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 324, 1), )

    
    serviceTypeDef = property(__serviceTypeDef.value, __serviceTypeDef.set, None, 'Definition of a single service type defintion')

    _ElementMap.update({
        __typeParameter.name() : __typeParameter,
        __serviceTypeDef.name() : __serviceTypeDef
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_146 (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a single transactional type defintion"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 277, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}typeParameters uses Python identifier typeParameters
    __typeParameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'typeParameters'), 'typeParameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_146_httpwww_accellera_orgXMLSchemaIPXACT1685_2014typeParameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 256, 1), )

    
    typeParameters = property(__typeParameters.value, __typeParameters.set, None, 'list of port type parameters (e.g. template or constructor parameters for a systemC port or socket)')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}typeName uses Python identifier typeName
    __typeName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'typeName'), 'typeName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_146_httpwww_accellera_orgXMLSchemaIPXACT1685_2014typeName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 279, 4), )

    
    typeName = property(__typeName.value, __typeName.set, None, 'The name of the port type. Can be any predefined type such sc_port or sc_export in SystemC or any user-defined type such as tlm_port.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}typeDefinition uses Python identifier typeDefinition
    __typeDefinition = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'typeDefinition'), 'typeDefinition', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_146_httpwww_accellera_orgXMLSchemaIPXACT1685_2014typeDefinition', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 295, 4), )

    
    typeDefinition = property(__typeDefinition.value, __typeDefinition.set, None, 'Where the definition of the type is contained. For SystemC and SystemVerilog it is the include file containing the type definition.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}viewRef uses Python identifier viewRef
    __viewRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), 'viewRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_146_httpwww_accellera_orgXMLSchemaIPXACT1685_2014viewRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 308, 4), )

    
    viewRef = property(__viewRef.value, __viewRef.set, None, 'A reference to a view name in the file for which this type applies.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_146_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __typeParameters.name() : __typeParameters,
        __typeName.name() : __typeName,
        __typeDefinition.name() : __typeDefinition,
        __viewRef.name() : __viewRef
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_147 (pyxb.binding.basis.complexTypeDefinition):
    """The name of the port type. Can be any predefined type such sc_port or sc_export in SystemC or any user-defined type such as tlm_port."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 283, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute exact uses Python identifier exact
    __exact = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'exact'), 'exact', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_147_exact', pyxb.binding.datatypes.boolean, unicode_default='true')
    __exact._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 286, 8)
    __exact._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 286, 8)
    
    exact = property(__exact.value, __exact.set, None, 'When false, defines that the type is an abstract type that may not be related to an existing type in the language of the referenced view.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __exact.name() : __exact
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_148 (pyxb.binding.basis.complexTypeDefinition):
    """Where the definition of the type is contained. For SystemC and SystemVerilog it is the include file containing the type definition."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 299, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_148_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_149 (pyxb.binding.basis.complexTypeDefinition):
    """A reference to a view name in the file for which this type applies."""
    _TypeDefinition = pyxb.binding.datatypes.NMTOKEN
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 312, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.NMTOKEN
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_149_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_150 (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a single service type defintion"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 328, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}typeParameters uses Python identifier typeParameters
    __typeParameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'typeParameters'), 'typeParameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_150_httpwww_accellera_orgXMLSchemaIPXACT1685_2014typeParameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 256, 1), )

    
    typeParameters = property(__typeParameters.value, __typeParameters.set, None, 'list of port type parameters (e.g. template or constructor parameters for a systemC port or socket)')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}typeName uses Python identifier typeName
    __typeName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'typeName'), 'typeName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_150_httpwww_accellera_orgXMLSchemaIPXACT1685_2014typeName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 330, 4), )

    
    typeName = property(__typeName.value, __typeName.set, None, 'The name of the service type. Can be any predefined type such as booean or integer or any user-defined type such as addr_type or data_type.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}typeDefinition uses Python identifier typeDefinition
    __typeDefinition = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'typeDefinition'), 'typeDefinition', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_150_httpwww_accellera_orgXMLSchemaIPXACT1685_2014typeDefinition', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 347, 4), )

    
    typeDefinition = property(__typeDefinition.value, __typeDefinition.set, None, 'Where the definition of the type is contained if the type if not part of the language. For SystemC and SystemVerilog it is the include file containing the type definition.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_150_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __typeParameters.name() : __typeParameters,
        __typeName.name() : __typeName,
        __typeDefinition.name() : __typeDefinition
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_151 (pyxb.binding.basis.complexTypeDefinition):
    """The name of the service type. Can be any predefined type such as booean or integer or any user-defined type such as addr_type or data_type."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 334, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute implicit uses Python identifier implicit
    __implicit = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'implicit'), 'implicit', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_151_implicit', pyxb.binding.datatypes.boolean, unicode_default='false')
    __implicit._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 337, 8)
    __implicit._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 337, 8)
    
    implicit = property(__implicit.value, __implicit.set, None, 'Defines that the typeName supplied for this service is implicit and a netlister should not declare this service in\na language specific top-level netlist ')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __implicit.name() : __implicit
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_152 (pyxb.binding.basis.complexTypeDefinition):
    """Where the definition of the type is contained if the type if not part of the language. For SystemC and SystemVerilog it is the include file containing the type definition."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 351, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_152_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_153 (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a single wire type defintion that can relate to multiple views."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 368, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}typeName uses Python identifier typeName
    __typeName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'typeName'), 'typeName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_153_httpwww_accellera_orgXMLSchemaIPXACT1685_2014typeName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 370, 4), )

    
    typeName = property(__typeName.value, __typeName.set, None, 'The name of the logic type. Examples could be std_logic, std_ulogic, std_logic_vector, sc_logic, ...')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}typeDefinition uses Python identifier typeDefinition
    __typeDefinition = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'typeDefinition'), 'typeDefinition', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_153_httpwww_accellera_orgXMLSchemaIPXACT1685_2014typeDefinition', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 386, 4), )

    
    typeDefinition = property(__typeDefinition.value, __typeDefinition.set, None, 'Where the definition of the type is contained. For std_logic, this is contained in IEEE.std_logic_1164.all. For sc_logic, this is contained in systemc.h. For VHDL this is the library and package as defined by the "used" statement. For SystemC and SystemVerilog it is the include file required. For verilog this is not needed.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}viewRef uses Python identifier viewRef
    __viewRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), 'viewRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_153_httpwww_accellera_orgXMLSchemaIPXACT1685_2014viewRef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 398, 4), )

    
    viewRef = property(__viewRef.value, __viewRef.set, None, 'A reference to a view name in the file for which this type applies.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_153_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __typeName.name() : __typeName,
        __typeDefinition.name() : __typeDefinition,
        __viewRef.name() : __viewRef
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_154 (pyxb.binding.basis.complexTypeDefinition):
    """The name of the logic type. Examples could be std_logic, std_ulogic, std_logic_vector, sc_logic, ..."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 374, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute constrained uses Python identifier constrained
    __constrained = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'constrained'), 'constrained', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_154_constrained', pyxb.binding.datatypes.boolean, unicode_default='false')
    __constrained._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 377, 8)
    __constrained._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 377, 8)
    
    constrained = property(__constrained.value, __constrained.set, None, 'Defines that the type for the port has constrainted the number of bits in the vector')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __constrained.name() : __constrained
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_155 (pyxb.binding.basis.complexTypeDefinition):
    """Where the definition of the type is contained. For std_logic, this is contained in IEEE.std_logic_1164.all. For sc_logic, this is contained in systemc.h. For VHDL this is the library and package as defined by the "used" statement. For SystemC and SystemVerilog it is the include file required. For verilog this is not needed."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 390, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_155_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_156 (pyxb.binding.basis.complexTypeDefinition):
    """A reference to a view name in the file for which this type applies."""
    _TypeDefinition = pyxb.binding.datatypes.NMTOKEN
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 402, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.NMTOKEN
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_156_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_157 (pyxb.binding.basis.complexTypeDefinition):
    """The group of type definitions. If no match to a viewName is found then the default language types are to be used. See the User Guide for these default types."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 418, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}serviceTypeDef uses Python identifier serviceTypeDef
    __serviceTypeDef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'serviceTypeDef'), 'serviceTypeDef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_157_httpwww_accellera_orgXMLSchemaIPXACT1685_2014serviceTypeDef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 324, 1), )

    
    serviceTypeDef = property(__serviceTypeDef.value, __serviceTypeDef.set, None, 'Definition of a single service type defintion')

    _ElementMap.update({
        __serviceTypeDef.name() : __serviceTypeDef
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_158 (pyxb.binding.basis.complexTypeDefinition):
    """The group of wire type definitions. If no match to a viewName is found then the default language types are to be used. See the User Guide for these default types."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 428, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}wireTypeDef uses Python identifier wireTypeDef
    __wireTypeDef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'wireTypeDef'), 'wireTypeDef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_158_httpwww_accellera_orgXMLSchemaIPXACT1685_2014wireTypeDef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 364, 1), )

    
    wireTypeDef = property(__wireTypeDef.value, __wireTypeDef.set, None, 'Definition of a single wire type defintion that can relate to multiple views.')

    _ElementMap.update({
        __wireTypeDef.name() : __wireTypeDef
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_159 (pyxb.binding.basis.complexTypeDefinition):
    """The group of transactional type definitions. If no match to a viewName is found then the default language types are to be used. See the User Guide for these default types."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 442, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}transTypeDef uses Python identifier transTypeDef
    __transTypeDef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'transTypeDef'), 'transTypeDef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_159_httpwww_accellera_orgXMLSchemaIPXACT1685_2014transTypeDef', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 273, 1), )

    
    transTypeDef = property(__transTypeDef.value, __transTypeDef.set, None, 'Definition of a single transactional type defintion')

    _ElementMap.update({
        __transTypeDef.name() : __transTypeDef
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portWireType with content type ELEMENT_ONLY
class portWireType (pyxb.binding.basis.complexTypeDefinition):
    """Wire port type for a component."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'portWireType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 457, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vectors uses Python identifier vectors
    __vectors = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vectors'), 'vectors', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portWireType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vectors', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 539, 1), )

    
    vectors = property(__vectors.value, __vectors.set, None, 'Vectored information.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}constraintSets uses Python identifier constraintSets
    __constraintSets = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'constraintSets'), 'constraintSets', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portWireType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014constraintSets', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 259, 4), )

    
    constraintSets = property(__constraintSets.value, __constraintSets.set, None, 'List of constraintSet elements for a component port.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}wireTypeDefs uses Python identifier wireTypeDefs
    __wireTypeDefs = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'wireTypeDefs'), 'wireTypeDefs', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portWireType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014wireTypeDefs', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 424, 1), )

    
    wireTypeDefs = property(__wireTypeDefs.value, __wireTypeDefs.set, None, 'The group of wire type definitions. If no match to a viewName is found then the default language types are to be used. See the User Guide for these default types.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}direction uses Python identifier direction
    __direction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'direction'), 'direction', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portWireType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014direction', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 462, 3), )

    
    direction = property(__direction.value, __direction.set, None, "The direction of a wire style port. The basic directions for a port are 'in' for input ports, 'out' for output port and 'inout' for bidirectional and tristate ports. \nA value of 'phantom' is also allowed and define a port that exist on the IP-XACT component but not on the HDL model.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}drivers uses Python identifier drivers
    __drivers = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'drivers'), 'drivers', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portWireType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014drivers', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 135, 1), )

    
    drivers = property(__drivers.value, __drivers.set, None, 'Container for wire port driver elements.')

    
    # Attribute allLogicalDirectionsAllowed uses Python identifier allLogicalDirectionsAllowed
    __allLogicalDirectionsAllowed = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'allLogicalDirectionsAllowed'), 'allLogicalDirectionsAllowed', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portWireType_allLogicalDirectionsAllowed', pyxb.binding.datatypes.boolean, unicode_default='false')
    __allLogicalDirectionsAllowed._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 473, 2)
    __allLogicalDirectionsAllowed._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 473, 2)
    
    allLogicalDirectionsAllowed = property(__allLogicalDirectionsAllowed.value, __allLogicalDirectionsAllowed.set, None, 'True if logical ports with different directions from the physical port direction may be mapped onto this port. Forbidden for phantom ports, which always allow logical ports with all direction value to be mapped onto the physical port. Also ignored for inout ports, since any logical port maybe mapped to a physical inout port.            \t')

    _ElementMap.update({
        __vectors.name() : __vectors,
        __constraintSets.name() : __constraintSets,
        __wireTypeDefs.name() : __wireTypeDefs,
        __direction.name() : __direction,
        __drivers.name() : __drivers
    })
    _AttributeMap.update({
        __allLogicalDirectionsAllowed.name() : __allLogicalDirectionsAllowed
    })
Namespace.addCategoryObject('typeBinding', 'portWireType', portWireType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portTransactionalType with content type ELEMENT_ONLY
class portTransactionalType (pyxb.binding.basis.complexTypeDefinition):
    """Transactional port type."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'portTransactionalType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 479, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}initiative uses Python identifier initiative
    __initiative = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'initiative'), 'initiative', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portTransactionalType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014initiative', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 147, 1), )

    
    initiative = property(__initiative.value, __initiative.set, None, 'If this element is present, the type of access is restricted to the specified value.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}busWidth uses Python identifier busWidth
    __busWidth = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'busWidth'), 'busWidth', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portTransactionalType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014busWidth', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 152, 1), )

    
    busWidth = property(__busWidth.value, __busWidth.set, None, 'defines the bus size in bits. This can be the result of an expression.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}protocol uses Python identifier protocol
    __protocol = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'protocol'), 'protocol', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portTransactionalType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014protocol', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 157, 1), )

    
    protocol = property(__protocol.value, __protocol.set, None, 'defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}kind uses Python identifier kind
    __kind = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'kind'), 'kind', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portTransactionalType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014kind', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 191, 1), )

    
    kind = property(__kind.value, __kind.set, None, 'Defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}transTypeDefs uses Python identifier transTypeDefs
    __transTypeDefs = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'transTypeDefs'), 'transTypeDefs', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portTransactionalType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014transTypeDefs', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 438, 1), )

    
    transTypeDefs = property(__transTypeDefs.value, __transTypeDefs.set, None, 'The group of transactional type definitions. If no match to a viewName is found then the default language types are to be used. See the User Guide for these default types.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}connection uses Python identifier connection
    __connection = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'connection'), 'connection', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portTransactionalType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014connection', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 509, 3), )

    
    connection = property(__connection.value, __connection.set, None, 'Bounds number of legal connections.')

    
    # Attribute allLogicalInitiativesAllowed uses Python identifier allLogicalInitiativesAllowed
    __allLogicalInitiativesAllowed = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'allLogicalInitiativesAllowed'), 'allLogicalInitiativesAllowed', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portTransactionalType_allLogicalInitiativesAllowed', pyxb.binding.datatypes.boolean, unicode_default='false')
    __allLogicalInitiativesAllowed._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 529, 2)
    __allLogicalInitiativesAllowed._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 529, 2)
    
    allLogicalInitiativesAllowed = property(__allLogicalInitiativesAllowed.value, __allLogicalInitiativesAllowed.set, None, 'True if logical ports with different initiatives from the physical port initiative may be mapped onto this port. Forbidden for phantom ports, which always allow logical ports with all initiatives value to be mapped onto the physical port. Also ignored for "both" ports, since any logical port may be mapped to a physical "both" port.\n\t\t\t\t')

    _ElementMap.update({
        __initiative.name() : __initiative,
        __busWidth.name() : __busWidth,
        __protocol.name() : __protocol,
        __kind.name() : __kind,
        __transTypeDefs.name() : __transTypeDefs,
        __connection.name() : __connection
    })
    _AttributeMap.update({
        __allLogicalInitiativesAllowed.name() : __allLogicalInitiativesAllowed
    })
Namespace.addCategoryObject('typeBinding', 'portTransactionalType', portTransactionalType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_160 (pyxb.binding.basis.complexTypeDefinition):
    """Bounds number of legal connections."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 513, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}maxConnections uses Python identifier maxConnections
    __maxConnections = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'maxConnections'), 'maxConnections', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_160_httpwww_accellera_orgXMLSchemaIPXACT1685_2014maxConnections', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 515, 6), )

    
    maxConnections = property(__maxConnections.value, __maxConnections.set, None, 'Indicates the maximum number of connections this port supports. If this element is not present or set to 0 it implies an unbounded number of allowed connections.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}minConnections uses Python identifier minConnections
    __minConnections = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'minConnections'), 'minConnections', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_160_httpwww_accellera_orgXMLSchemaIPXACT1685_2014minConnections', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 520, 6), )

    
    minConnections = property(__minConnections.value, __minConnections.set, None, 'Indicates the minimum number of connections this port supports. If this element is not present, the minimum number of allowed connections is 1.')

    _ElementMap.update({
        __maxConnections.name() : __maxConnections,
        __minConnections.name() : __minConnections
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portAccessType with content type ELEMENT_ONLY
class portAccessType_ (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portAccessType with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'portAccessType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 551, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portAccessType uses Python identifier portAccessType
    __portAccessType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'portAccessType'), 'portAccessType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portAccessType__httpwww_accellera_orgXMLSchemaIPXACT1685_2014portAccessType', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 209, 1), )

    
    portAccessType = property(__portAccessType.value, __portAccessType.set, None, "Indicates how a netlister accesses a port. 'ref' means accessed by reference (default) and 'ptr' means accessed by pointer.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandles uses Python identifier accessHandles
    __accessHandles = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), 'accessHandles', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portAccessType__httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandles', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 558, 3), )

    
    accessHandles = property(__accessHandles.value, __accessHandles.set, None, None)

    _ElementMap.update({
        __portAccessType.name() : __portAccessType,
        __accessHandles.name() : __accessHandles
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'portAccessType', portAccessType_)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_161 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 559, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandle uses Python identifier accessHandle
    __accessHandle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), 'accessHandle', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_161_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandle', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 561, 6), )

    
    accessHandle = property(__accessHandle.value, __accessHandle.set, None, None)

    _ElementMap.update({
        __accessHandle.name() : __accessHandle
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_162 (pyxb.binding.basis.complexTypeDefinition):
    """Describes a driven one-shot port."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 79, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}singleShotOffset uses Python identifier singleShotOffset
    __singleShotOffset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'singleShotOffset'), 'singleShotOffset', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_162_httpwww_accellera_orgXMLSchemaIPXACT1685_2014singleShotOffset', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 81, 4), )

    
    singleShotOffset = property(__singleShotOffset.value, __singleShotOffset.set, None, 'Time in nanoseconds until start of one-shot.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}singleShotValue uses Python identifier singleShotValue
    __singleShotValue = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'singleShotValue'), 'singleShotValue', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_162_httpwww_accellera_orgXMLSchemaIPXACT1685_2014singleShotValue', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 86, 4), )

    
    singleShotValue = property(__singleShotValue.value, __singleShotValue.set, None, 'Value of port after first  edge of one-shot.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}singleShotDuration uses Python identifier singleShotDuration
    __singleShotDuration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'singleShotDuration'), 'singleShotDuration', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_162_httpwww_accellera_orgXMLSchemaIPXACT1685_2014singleShotDuration', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 91, 4), )

    
    singleShotDuration = property(__singleShotDuration.value, __singleShotDuration.set, None, 'Duration in nanoseconds of the one shot.')

    _ElementMap.update({
        __singleShotOffset.name() : __singleShotOffset,
        __singleShotValue.name() : __singleShotValue,
        __singleShotDuration.name() : __singleShotDuration
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}driverType with content type ELEMENT_ONLY
class driverType (pyxb.binding.basis.complexTypeDefinition):
    """Wire port driver type."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'driverType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 122, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}range uses Python identifier range
    __range = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'range'), 'range', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_driverType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014range', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 549, 1), )

    
    range = property(__range.value, __range.set, None, 'Left and right bound of a reference into a vector.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}defaultValue uses Python identifier defaultValue
    __defaultValue = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'defaultValue'), 'defaultValue', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_driverType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014defaultValue', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 54, 1), )

    
    defaultValue = property(__defaultValue.value, __defaultValue.set, None, 'Default value for a wire port.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockDriver uses Python identifier clockDriver
    __clockDriver = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'clockDriver'), 'clockDriver', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_driverType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014clockDriver', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 59, 1), )

    
    clockDriver = property(__clockDriver.value, __clockDriver.set, None, 'Describes a driven clock port. ')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}singleShotDriver uses Python identifier singleShotDriver
    __singleShotDriver = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'singleShotDriver'), 'singleShotDriver', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_driverType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014singleShotDriver', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 75, 1), )

    
    singleShotDriver = property(__singleShotDriver.value, __singleShotDriver.set, None, 'Describes a driven one-shot port.')

    _ElementMap.update({
        __range.name() : __range,
        __defaultValue.name() : __defaultValue,
        __clockDriver.name() : __clockDriver,
        __singleShotDriver.name() : __singleShotDriver
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'driverType', driverType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_163 (pyxb.binding.basis.complexTypeDefinition):
    """Container for wire port driver elements."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 139, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}driver uses Python identifier driver
    __driver = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'driver'), 'driver', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_163_httpwww_accellera_orgXMLSchemaIPXACT1685_2014driver', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 149, 1), )

    
    driver = property(__driver.value, __driver.set, None, 'Wire port driver element.')

    _ElementMap.update({
        __driver.name() : __driver
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockDriverType with content type ELEMENT_ONLY
class clockDriverType (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockDriverType with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'clockDriverType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 169, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockPeriod uses Python identifier clockPeriod
    __clockPeriod = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'clockPeriod'), 'clockPeriod', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_clockDriverType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014clockPeriod', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 171, 3), )

    
    clockPeriod = property(__clockPeriod.value, __clockPeriod.set, None, 'Clock period in units defined by the units attribute. Default is nanoseconds.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockPulseOffset uses Python identifier clockPulseOffset
    __clockPulseOffset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'clockPulseOffset'), 'clockPulseOffset', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_clockDriverType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014clockPulseOffset', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 183, 3), )

    
    clockPulseOffset = property(__clockPulseOffset.value, __clockPulseOffset.set, None, 'Time until first pulse. Units are defined by the units attribute. Default is nanoseconds.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockPulseValue uses Python identifier clockPulseValue
    __clockPulseValue = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'clockPulseValue'), 'clockPulseValue', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_clockDriverType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014clockPulseValue', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 195, 3), )

    
    clockPulseValue = property(__clockPulseValue.value, __clockPulseValue.set, None, 'Value of port after first clock edge.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockPulseDuration uses Python identifier clockPulseDuration
    __clockPulseDuration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'clockPulseDuration'), 'clockPulseDuration', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_clockDriverType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014clockPulseDuration', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 200, 3), )

    
    clockPulseDuration = property(__clockPulseDuration.value, __clockPulseDuration.set, None, 'Duration of first state in cycle. Units are defined by the units attribute. Default is nanoseconds.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_clockDriverType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __clockPeriod.name() : __clockPeriod,
        __clockPulseOffset.name() : __clockPulseOffset,
        __clockPulseValue.name() : __clockPulseValue,
        __clockPulseDuration.name() : __clockPulseDuration
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'clockDriverType', clockDriverType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_164 (pyxb.binding.basis.complexTypeDefinition):
    """All configuration information for a contained component, generator, generator chain or abstractor instance."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 96, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}configurableElementValue uses Python identifier configurableElementValue
    __configurableElementValue = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'configurableElementValue'), 'configurableElementValue', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_164_httpwww_accellera_orgXMLSchemaIPXACT1685_2014configurableElementValue', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 106, 1), )

    
    configurableElementValue = property(__configurableElementValue.value, __configurableElementValue.set, None, 'Describes the content of a configurable element. The required referenceId attribute refers to the ID attribute of the configurable element.')

    _ElementMap.update({
        __configurableElementValue.name() : __configurableElementValue
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_165 (pyxb.binding.basis.complexTypeDefinition):
    """Component instance element.  The instance name is contained in the unique-value instanceName attribute."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 132, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_165_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_165_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_165_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_165_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}instanceName uses Python identifier instanceName
    __instanceName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'instanceName'), 'instanceName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_165_httpwww_accellera_orgXMLSchemaIPXACT1685_2014instanceName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 123, 1), )

    
    instanceName = property(__instanceName.value, __instanceName.set, None, 'An instance name assigned to subcomponent instances and contained channels, that is unique within the parent component.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}componentRef uses Python identifier componentRef
    __componentRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'componentRef'), 'componentRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_165_httpwww_accellera_orgXMLSchemaIPXACT1685_2014componentRef', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 138, 4), )

    
    componentRef = property(__componentRef.value, __componentRef.set, None, 'References a component to be found in an external library.  The four attributes define the VLNV of the referenced element.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_165_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __instanceName.name() : __instanceName,
        __componentRef.name() : __componentRef
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_166 (pyxb.binding.basis.complexTypeDefinition):
    """Sub instances of internal components."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 152, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}componentInstance uses Python identifier componentInstance
    __componentInstance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'componentInstance'), 'componentInstance', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_166_httpwww_accellera_orgXMLSchemaIPXACT1685_2014componentInstance', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 128, 1), )

    
    componentInstance = property(__componentInstance.value, __componentInstance.set, None, 'Component instance element.  The instance name is contained in the unique-value instanceName attribute.')

    _ElementMap.update({
        __componentInstance.name() : __componentInstance
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_167 (pyxb.binding.basis.complexTypeDefinition):
    """Represents an ad-hoc connection between component ports."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 162, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_167_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_167_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 362, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_167_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_167_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_167_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}tiedValue uses Python identifier tiedValue
    __tiedValue = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'tiedValue'), 'tiedValue', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_167_httpwww_accellera_orgXMLSchemaIPXACT1685_2014tiedValue', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 166, 4), )

    
    tiedValue = property(__tiedValue.value, __tiedValue.set, None, 'The logic value of this connection. The value can be an unsigned longint expression or open or default. Only valid for ports of style wire.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portReferences uses Python identifier portReferences
    __portReferences = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'portReferences'), 'portReferences', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_167_httpwww_accellera_orgXMLSchemaIPXACT1685_2014portReferences', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 171, 4), )

    
    portReferences = property(__portReferences.value, __portReferences.set, None, 'Liist of internal and external port references involved in the adhocConnection')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_167_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __tiedValue.name() : __tiedValue,
        __portReferences.name() : __portReferences
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_168 (pyxb.binding.basis.complexTypeDefinition):
    """Liist of internal and external port references involved in the adhocConnection"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 175, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}internalPortReference uses Python identifier internalPortReference
    __internalPortReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'internalPortReference'), 'internalPortReference', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_168_httpwww_accellera_orgXMLSchemaIPXACT1685_2014internalPortReference', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 178, 8), )

    
    internalPortReference = property(__internalPortReference.value, __internalPortReference.set, None, 'Defines a reference to a port on a component contained within the design.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}externalPortReference uses Python identifier externalPortReference
    __externalPortReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'externalPortReference'), 'externalPortReference', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_168_httpwww_accellera_orgXMLSchemaIPXACT1685_2014externalPortReference', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 359, 1), )

    
    externalPortReference = property(__externalPortReference.value, __externalPortReference.set, None, None)

    _ElementMap.update({
        __internalPortReference.name() : __internalPortReference,
        __externalPortReference.name() : __externalPortReference
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_169 (pyxb.binding.basis.complexTypeDefinition):
    """Defines the set of ad-hoc connections in a design. An ad-hoc connection represents a connection between two component pins which were not connected as a result of interface connections (i.e.the pin to pin connection was made explicitly and is represented explicitly)."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 215, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}adHocConnection uses Python identifier adHocConnection
    __adHocConnection = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'adHocConnection'), 'adHocConnection', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_169_httpwww_accellera_orgXMLSchemaIPXACT1685_2014adHocConnection', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 158, 1), )

    
    adHocConnection = property(__adHocConnection.value, __adHocConnection.set, None, 'Represents an ad-hoc connection between component ports.')

    _ElementMap.update({
        __adHocConnection.name() : __adHocConnection
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_170 (pyxb.binding.basis.complexTypeDefinition):
    """Describes a connection between two active (not monitor) busInterfaces."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 225, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_170_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_170_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_170_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_170_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_170_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}hierInterface uses Python identifier hierInterface
    __hierInterface = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'hierInterface'), 'hierInterface', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_170_httpwww_accellera_orgXMLSchemaIPXACT1685_2014hierInterface', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 239, 6), )

    
    hierInterface = property(__hierInterface.value, __hierInterface.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}activeInterface uses Python identifier activeInterface
    __activeInterface = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'activeInterface'), 'activeInterface', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_170_httpwww_accellera_orgXMLSchemaIPXACT1685_2014activeInterface', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 373, 1), )

    
    activeInterface = property(__activeInterface.value, __activeInterface.set, None, None)

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_170_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __hierInterface.name() : __hierInterface,
        __activeInterface.name() : __activeInterface
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_171 (pyxb.binding.basis.complexTypeDefinition):
    """Describes a connection from the interface of one component to any number of monitor interfaces in the design.

An active interface can be connected to unlimited number of monitor interfaces."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 268, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_171_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_171_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_171_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_171_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}monitoredActiveInterface uses Python identifier monitoredActiveInterface
    __monitoredActiveInterface = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'monitoredActiveInterface'), 'monitoredActiveInterface', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_171_httpwww_accellera_orgXMLSchemaIPXACT1685_2014monitoredActiveInterface', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 272, 4), )

    
    monitoredActiveInterface = property(__monitoredActiveInterface.value, __monitoredActiveInterface.set, None, 'Describes an active interface of the design that all the monitors will be connected to.\n\nThe componentRef and busRef attributes indicate the instance name and bus interface name. The optional path attribute indicates the hierarchical instance name path to the component.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}monitorInterface uses Python identifier monitorInterface
    __monitorInterface = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'monitorInterface'), 'monitorInterface', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_171_httpwww_accellera_orgXMLSchemaIPXACT1685_2014monitorInterface', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 279, 4), )

    
    monitorInterface = property(__monitorInterface.value, __monitorInterface.set, None, 'Describes a list of monitor interfaces that are connected to the single active interface.\n\nThe componentRef and busRef attributes indicate the instance name and bus interface name. The optional path attribute indicates the hierarchical instance name path to the component.')

    _ElementMap.update({
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __monitoredActiveInterface.name() : __monitoredActiveInterface,
        __monitorInterface.name() : __monitorInterface
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_172 (pyxb.binding.basis.complexTypeDefinition):
    """Connections between internal sub components."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 302, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interconnection uses Python identifier interconnection
    __interconnection = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'interconnection'), 'interconnection', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_172_httpwww_accellera_orgXMLSchemaIPXACT1685_2014interconnection', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 221, 1), )

    
    interconnection = property(__interconnection.value, __interconnection.set, None, 'Describes a connection between two active (not monitor) busInterfaces.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}monitorInterconnection uses Python identifier monitorInterconnection
    __monitorInterconnection = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'monitorInterconnection'), 'monitorInterconnection', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_172_httpwww_accellera_orgXMLSchemaIPXACT1685_2014monitorInterconnection', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 262, 1), )

    
    monitorInterconnection = property(__monitorInterconnection.value, __monitorInterconnection.set, None, 'Describes a connection from the interface of one component to any number of monitor interfaces in the design.\n\nAn active interface can be connected to unlimited number of monitor interfaces.')

    _ElementMap.update({
        __interconnection.name() : __interconnection,
        __monitorInterconnection.name() : __monitorInterconnection
    })
    _AttributeMap.update({
        
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interfaceType with content type EMPTY
class interfaceType (pyxb.binding.basis.complexTypeDefinition):
    """A representation of a component/bus interface relation; i.e. a bus interface belonging to a certain component."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'interfaceType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 309, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_interfaceType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute componentRef uses Python identifier componentRef
    __componentRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'componentRef'), 'componentRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_interfaceType_componentRef', pyxb.binding.datatypes.Name, required=True)
    __componentRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 313, 2)
    __componentRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 313, 2)
    
    componentRef = property(__componentRef.value, __componentRef.set, None, 'Reference to a component instance name.')

    
    # Attribute busRef uses Python identifier busRef
    __busRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'busRef'), 'busRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_interfaceType_busRef', pyxb.binding.datatypes.Name, required=True)
    __busRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 318, 2)
    __busRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 318, 2)
    
    busRef = property(__busRef.value, __busRef.set, None, 'Reference to the components  bus interface')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id,
        __componentRef.name() : __componentRef,
        __busRef.name() : __busRef
    })
Namespace.addCategoryObject('typeBinding', 'interfaceType', interfaceType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}hierInterfaceType with content type ELEMENT_ONLY
class hierInterfaceType (pyxb.binding.basis.complexTypeDefinition):
    """A representation of an exported interface. The busRef indicates the name of the interface in the containing component."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'hierInterfaceType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 325, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_hierInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_hierInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_hierInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_hierInterfaceType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute busRef uses Python identifier busRef
    __busRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'busRef'), 'busRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_hierInterfaceType_busRef', pyxb.binding.datatypes.Name, required=True)
    __busRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 334, 2)
    __busRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 334, 2)
    
    busRef = property(__busRef.value, __busRef.set, None, 'Reference to the components  bus interface')

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __description.name() : __description,
        __isPresent.name() : __isPresent
    })
    _AttributeMap.update({
        __id.name() : __id,
        __busRef.name() : __busRef
    })
Namespace.addCategoryObject('typeBinding', 'hierInterfaceType', hierInterfaceType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_173 (pyxb.binding.basis.complexTypeDefinition):
    """The list of physical ports to be excluded from an interface based connection. Analogous to the removing the port map element for the named ports."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 384, 7)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}excludePort uses Python identifier excludePort
    __excludePort = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'excludePort'), 'excludePort', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_173_httpwww_accellera_orgXMLSchemaIPXACT1685_2014excludePort', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 386, 9), )

    
    excludePort = property(__excludePort.value, __excludePort.set, None, 'The name of a physical port to be excluded from the interface based connection.')

    _ElementMap.update({
        __excludePort.name() : __excludePort
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_174 (pyxb.binding.basis.complexTypeDefinition):
    """Define the mode for the interfaces on this abstractor. 

For master the first interface connects to the master, the second connects to the mirroredMaster

For slave the first interface connects to the mirroredSlave the second connects to the slave

For direct the first interface connects to the master, the second connects to the slave

For system the first interface connects to the system, the second connects to the mirroredSystem. For system the group attribute is required"""
    _TypeDefinition = abstractorModeType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 76, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is abstractorModeType
    
    # Attribute group uses Python identifier group
    __group = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'group'), 'group', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_174_group', pyxb.binding.datatypes.Name)
    __group._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 79, 7)
    __group._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 79, 7)
    
    group = property(__group.value, __group.set, None, 'Define the system group if the mode is set to system')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __group.name() : __group
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_175 (pyxb.binding.basis.complexTypeDefinition):
    """Contains the name and value of a port on the component, the value indicates the logic value which this port must take to effect the remapping. The portMapRef attribute stores the name of the port which takes that value."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 231, 11)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portIndex uses Python identifier portIndex
    __portIndex = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'portIndex'), 'portIndex', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_175_httpwww_accellera_orgXMLSchemaIPXACT1685_2014portIndex', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 233, 13), )

    
    portIndex = property(__portIndex.value, __portIndex.set, None, 'Index for a vectored type port. Must be a number between left and right for the port.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}value uses Python identifier value_
    __value = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'value'), 'value_', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_175_httpwww_accellera_orgXMLSchemaIPXACT1685_2014value', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 238, 13), )

    
    value_ = property(__value.value, __value.set, None, None)

    
    # Attribute portRef uses Python identifier portRef
    __portRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'portRef'), 'portRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_175_portRef', portName, required=True)
    __portRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 240, 12)
    __portRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 240, 12)
    
    portRef = property(__portRef.value, __portRef.set, None, "This attribute identifies a signal on the component which affects the component's memory layout ")

    _ElementMap.update({
        __portIndex.name() : __portIndex,
        __value.name() : __value
    })
    _AttributeMap.update({
        __portRef.name() : __portRef
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_176 (addrSpaceRefType):
    """If this master connects to an addressable bus, this element references the address space it maps to."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 271, 7)
    _ElementMap = addrSpaceRefType._ElementMap.copy()
    _AttributeMap = addrSpaceRefType._AttributeMap.copy()
    # Base type is addrSpaceRefType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}baseAddress uses Python identifier baseAddress
    __baseAddress = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'baseAddress'), 'baseAddress', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_176_httpwww_accellera_orgXMLSchemaIPXACT1685_2014baseAddress', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 278, 11), )

    
    baseAddress = property(__baseAddress.value, __baseAddress.set, None, 'Base of an address space.')

    
    # Element isPresent ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addrSpaceRefType
    
    # Attribute id inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addrSpaceRefType
    
    # Attribute addressSpaceRef inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addrSpaceRefType
    _ElementMap.update({
        __baseAddress.name() : __baseAddress
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_177 (pyxb.binding.basis.complexTypeDefinition):
    """Indicates that this is a (passive) monitor interface. All of the ports in the interface must be inputs. The type of interface to be monitored is specified with the required interfaceType attribute. The ipxact:group element must be specified if monitoring a system interface."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 392, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'group'), 'group', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_177_httpwww_accellera_orgXMLSchemaIPXACT1685_2014group', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 166, 1), )

    
    group = property(__group.value, __group.set, None, 'Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.')

    
    # Attribute interfaceMode uses Python identifier interfaceMode
    __interfaceMode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'interfaceMode'), 'interfaceMode', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_177_interfaceMode', STD_ANON_2, required=True)
    __interfaceMode._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 400, 5)
    __interfaceMode._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 400, 5)
    
    interfaceMode = property(__interfaceMode.value, __interfaceMode.set, None, None)

    _ElementMap.update({
        __group.name() : __group
    })
    _AttributeMap.update({
        __interfaceMode.name() : __interfaceMode
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType with content type ELEMENT_ONLY
class parameterBaseType (pyxb.binding.basis.complexTypeDefinition):
    """Name and value type for use in resolvable elements"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'parameterBaseType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 371, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}arrays uses Python identifier arrays
    __arrays = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'arrays'), 'arrays', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014arrays', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 378, 3), )

    
    arrays = property(__arrays.value, __arrays.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}value uses Python identifier value_
    __value = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'value'), 'value_', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014value', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 379, 3), )

    
    value_ = property(__value.value, __value.set, None, 'The value of the parameter.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vectors uses Python identifier vectors
    __vectors = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vectors'), 'vectors', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vectors', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 539, 1), )

    
    vectors = property(__vectors.value, __vectors.set, None, 'Vectored information.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 600, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Attribute parameterId uses Python identifier parameterId
    __parameterId = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'parameterId'), 'parameterId', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_parameterId', pyxb.binding.datatypes.Name)
    __parameterId._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 386, 2)
    __parameterId._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 386, 2)
    
    parameterId = property(__parameterId.value, __parameterId.set, None, 'ID attribute for uniquely identifying a parameter within its document. Attribute is used to refer to this from a configurable element.')

    
    # Attribute prompt uses Python identifier prompt
    __prompt = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'prompt'), 'prompt', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_prompt', pyxb.binding.datatypes.string)
    __prompt._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 391, 2)
    __prompt._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 391, 2)
    
    prompt = property(__prompt.value, __prompt.set, None, 'Provides a string used to prompt the user for user-resolved property values.')

    
    # Attribute choiceRef uses Python identifier choiceRef
    __choiceRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'choiceRef'), 'choiceRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_choiceRef', pyxb.binding.datatypes.Name)
    __choiceRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 396, 2)
    __choiceRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 396, 2)
    
    choiceRef = property(__choiceRef.value, __choiceRef.set, None, 'For user defined properties, refers the choice element enumerating the values to choose from.')

    
    # Attribute order uses Python identifier order
    __order = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'order'), 'order', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_order', pyxb.binding.datatypes.float)
    __order._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 401, 2)
    __order._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 401, 2)
    
    order = property(__order.value, __order.set, None, 'For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.')

    
    # Attribute configGroups uses Python identifier configGroups
    __configGroups = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'configGroups'), 'configGroups', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_configGroups', pyxb.binding.datatypes.NMTOKENS)
    __configGroups._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 406, 2)
    __configGroups._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 406, 2)
    
    configGroups = property(__configGroups.value, __configGroups.set, None, 'Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.')

    
    # Attribute minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'minimum'), 'minimum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_minimum', pyxb.binding.datatypes.string)
    __minimum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 411, 2)
    __minimum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 411, 2)
    
    minimum = property(__minimum.value, __minimum.set, None, 'For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for the types: byte, shortint, int, longint, shortreal and real. The type of this value is the same as the type of the parameter-value, which is specified by the parameter-type attribute.')

    
    # Attribute maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'maximum'), 'maximum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_maximum', pyxb.binding.datatypes.string)
    __maximum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 416, 2)
    __maximum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 416, 2)
    
    maximum = property(__maximum.value, __maximum.set, None, 'For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for the types: byte, shortint, int, longint, shortreal and real. The type of this value is the same as the type of the parameter-value, which is specified by the parameter-type attribute.')

    
    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type'), 'type', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_type', formatType, unicode_default='string')
    __type._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 421, 2)
    __type._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 421, 2)
    
    type = property(__type.value, __type.set, None, 'Specifies the type of the value of the parameter. A parameter of type byte is resolved to an 8-bit integer value, shortint is resolved to a 16-bit integer value, int is resolved to a 32-bit integer value, longint is resolved to a 64-bit integer value, shortreal is resolved to a 32-bit floating point value, real is resolved to a 64-bit floating point value, bit is by default resolved to a one bit value, unless a vector size has been specified and the string type is resolved to a string value.')

    
    # Attribute sign uses Python identifier sign
    __sign = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'sign'), 'sign', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_sign', signType)
    __sign._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 426, 2)
    __sign._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 426, 2)
    
    sign = property(__sign.value, __sign.set, None, 'Specify the signedness explicitly. The data types byte, shortint, int, longint default to signed. The data type bit defaults to unsigned. When setting this values for the data types string, real and shortreal the setting is ignored.')

    
    # Attribute prefix uses Python identifier prefix
    __prefix = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'prefix'), 'prefix', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_prefix', STD_ANON_4)
    __prefix._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 431, 2)
    __prefix._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 431, 2)
    
    prefix = property(__prefix.value, __prefix.set, None, 'Defines the prefix that precedes the unit of a value. The prefix is not applied to the value (e.g. in calculations).')

    
    # Attribute unit uses Python identifier unit
    __unit = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'unit'), 'unit', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterBaseType_unit', STD_ANON_5)
    __unit._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 460, 2)
    __unit._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 460, 2)
    
    unit = property(__unit.value, __unit.set, None, 'Defines the unit of the value.')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __arrays.name() : __arrays,
        __value.name() : __value,
        __vectors.name() : __vectors,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description
    })
    _AttributeMap.update({
        __parameterId.name() : __parameterId,
        __prompt.name() : __prompt,
        __choiceRef.name() : __choiceRef,
        __order.name() : __order,
        __configGroups.name() : __configGroups,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __type.name() : __type,
        __sign.name() : __sign,
        __prefix.name() : __prefix,
        __unit.name() : __unit
    })
Namespace.addCategoryObject('typeBinding', 'parameterBaseType', parameterBaseType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_178 (pyxb.binding.basis.complexTypeDefinition):
    """Used to provide a generic description of a technology library cell."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 142, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}cellFunction uses Python identifier cellFunction
    __cellFunction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'cellFunction'), 'cellFunction', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_178_httpwww_accellera_orgXMLSchemaIPXACT1685_2014cellFunction', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 144, 16), )

    
    cellFunction = property(__cellFunction.value, __cellFunction.set, None, 'Defines a technology library cell in library independent fashion, based on specification of a cell function and strength.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}cellClass uses Python identifier cellClass
    __cellClass = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'cellClass'), 'cellClass', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_178_httpwww_accellera_orgXMLSchemaIPXACT1685_2014cellClass', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 156, 16), )

    
    cellClass = property(__cellClass.value, __cellClass.set, None, 'Defines a technology library cell in library independent fashion, based on specification of a cell class and strength.')

    
    # Attribute cellStrength uses Python identifier cellStrength
    __cellStrength = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'cellStrength'), 'cellStrength', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_178_cellStrength', cellStrengthValueType)
    __cellStrength._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 162, 12)
    __cellStrength._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 162, 12)
    
    cellStrength = property(__cellStrength.value, __cellStrength.set, None, 'Indicates the desired strength of the specified cell.')

    _ElementMap.update({
        __cellFunction.name() : __cellFunction,
        __cellClass.name() : __cellClass
    })
    _AttributeMap.update({
        __cellStrength.name() : __cellStrength
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_179 (pyxb.binding.basis.complexTypeDefinition):
    """Defines a technology library cell in library independent fashion, based on specification of a cell function and strength."""
    _TypeDefinition = cellFunctionValueType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 148, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is cellFunctionValueType
    
    # Attribute other uses Python identifier other
    __other = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'other'), 'other', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_179_other', pyxb.binding.datatypes.token)
    __other._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 151, 20)
    __other._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 151, 20)
    
    other = property(__other.value, __other.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __other.name() : __other
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_180 (pyxb.binding.basis.complexTypeDefinition):
    """Defines a timing constraint for the associated port. The constraint is relative to the clock specified by the clockName attribute. The clockEdge indicates which clock edge the constraint is associated with (default is rising edge). The delayType attribute can be specified to further refine the constraint."""
    _TypeDefinition = delayPercentageType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 173, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is delayPercentageType
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_180_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute clockEdge uses Python identifier clockEdge
    __clockEdge = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'clockEdge'), 'clockEdge', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_180_clockEdge', edgeValueType)
    __clockEdge._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 176, 20)
    __clockEdge._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 176, 20)
    
    clockEdge = property(__clockEdge.value, __clockEdge.set, None, 'Indicates the clock edge that a timing constraint is relative to.')

    
    # Attribute delayType uses Python identifier delayType
    __delayType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'delayType'), 'delayType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_180_delayType', delayValueType)
    __delayType._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 181, 20)
    __delayType._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 181, 20)
    
    delayType = property(__delayType.value, __delayType.set, None, 'Indicates the type of delay in a timing constraint - minimum or maximum.')

    
    # Attribute clockName uses Python identifier clockName
    __clockName = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'clockName'), 'clockName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_180_clockName', portName, required=True)
    __clockName._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 186, 20)
    __clockName._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 186, 20)
    
    clockName = property(__clockName.value, __clockName.set, None, 'Indicates the name of the clock to which this constraint applies.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id,
        __clockEdge.name() : __clockEdge,
        __delayType.name() : __delayType,
        __clockName.name() : __clockName
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_181 (ipxactURI):
    """Specifies a location on which  files or fileSets may be dependent. Typically, this would be a directory that would contain included files."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 329, 6)
    _ElementMap = ipxactURI._ElementMap.copy()
    _AttributeMap = ipxactURI._AttributeMap.copy()
    # Base type is ipxactURI
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_181_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_182 (nameValuePairType):
    """Arguments passed in when the function is called. Arguments are passed in order.

This is an extension of the name-value pair which includes the data type in the ipxact:dataType attribute.  The argument name is in the ipxact:name element and its value is in the ipxact:value element."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 427, 28)
    _ElementMap = nameValuePairType._ElementMap.copy()
    _AttributeMap = nameValuePairType._AttributeMap.copy()
    # Base type is nameValuePairType
    
    # Element vendorExtensions ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}nameValuePairType
    
    # Element value_ ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}value) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}nameValuePairType
    
    # Element name ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}nameValuePairType
    
    # Element displayName ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}nameValuePairType
    
    # Element description ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}nameValuePairType
    
    # Attribute id inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}nameValuePairType
    
    # Attribute dataType uses Python identifier dataType
    __dataType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'dataType'), 'dataType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_182_dataType', dataTypeType, required=True)
    __dataType._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 430, 40)
    __dataType._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 430, 40)
    
    dataType = property(__dataType.value, __dataType.set, None, 'The data type of the argument as pertains to the language. Example: "int", "double", "char *".')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __dataType.name() : __dataType
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_183 (pyxb.binding.basis.complexTypeDefinition):
    """Enumerated file types known by IP-XACT."""
    _TypeDefinition = simpleFileType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/fileType.xsd', 99, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is simpleFileType
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_183_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute user uses Python identifier user
    __user = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'user'), 'user', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_183_user', pyxb.binding.datatypes.string)
    __user._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/fileType.xsd', 102, 8)
    __user._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/fileType.xsd', 102, 8)
    
    user = property(__user.value, __user.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id,
        __user.name() : __user
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_184 (generatorType):
    """Specifies a set of generators."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 118, 2)
    _ElementMap = generatorType._ElementMap.copy()
    _AttributeMap = generatorType._AttributeMap.copy()
    # Base type is generatorType
    
    # Element parameters ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element vendorExtensions ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element name ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element displayName ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element description ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element phase ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}phase) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element apiType ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}apiType) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element transportMethods ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}transportMethods) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element generatorExe ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorExe) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Attribute id inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Attribute hidden inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_185 (pyxb.binding.basis.complexTypeDefinition):
    """Specifies a set of group names used to select subsequent generators. The attribute "multipleGroupOperator" specifies the OR or AND selection operator if there is more than one group name (default=OR)."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 138, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_185_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 140, 4), )

    
    name = property(__name.value, __name.set, None, 'Specifies a generator group name or a generator chain group name to be selected for inclusion in the generator chain.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_185_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute multipleGroupSelectionOperator uses Python identifier multipleGroupSelectionOperator
    __multipleGroupSelectionOperator = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'multipleGroupSelectionOperator'), 'multipleGroupSelectionOperator', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_185_multipleGroupSelectionOperator', STD_ANON_7, unicode_default='or')
    __multipleGroupSelectionOperator._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 153, 3)
    __multipleGroupSelectionOperator._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 153, 3)
    
    multipleGroupSelectionOperator = property(__multipleGroupSelectionOperator.value, __multipleGroupSelectionOperator.set, None, 'Specifies the OR or AND selection operator if there is more than one group name.')

    _ElementMap.update({
        __name.name() : __name
    })
    _AttributeMap.update({
        __id.name() : __id,
        __multipleGroupSelectionOperator.name() : __multipleGroupSelectionOperator
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}instanceGeneratorType with content type ELEMENT_ONLY
class instanceGeneratorType (generatorType):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}instanceGeneratorType with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'instanceGeneratorType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 172, 1)
    _ElementMap = generatorType._ElementMap.copy()
    _AttributeMap = generatorType._AttributeMap.copy()
    # Base type is generatorType
    
    # Element parameters ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element vendorExtensions ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element name ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element displayName ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element description ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element phase ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}phase) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'group'), 'group', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_instanceGeneratorType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014group', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 176, 5), )

    
    group = property(__group.value, __group.set, None, 'An identifier to specify the generator group. This is used by generator chains for selecting which generators to run.')

    
    # Element apiType ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}apiType) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element transportMethods ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}transportMethods) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Element generatorExe ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorExe) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Attribute id inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    
    # Attribute scope uses Python identifier scope
    __scope = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'scope'), 'scope', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_instanceGeneratorType_scope', STD_ANON_8, unicode_default='instance')
    __scope._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 189, 4)
    __scope._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 189, 4)
    
    scope = property(__scope.value, __scope.set, None, 'The scope attribute applies to component generators and specifies whether the generator should be run for each instance of the entity (or module) or just once for all instances of the entity.')

    
    # Attribute hidden inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}generatorType
    _ElementMap.update({
        __group.name() : __group
    })
    _AttributeMap.update({
        __scope.name() : __scope
    })
Namespace.addCategoryObject('typeBinding', 'instanceGeneratorType', instanceGeneratorType)


# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_186 (pyxb.binding.basis.complexTypeDefinition):
    """Indicates the type of API used by the generator. Valid value are TGI_2009, TGI_2014_BASE, TGI_2014_EXTENDED, and none. If this element is not present, TGI_2014_BASE is assumed. The type TGI_2009 indicates a generator using the 1685-2009 version of the TGI API. This is not part of the 1685-2014 version of the standard and may not be supported by Design Environments."""
    _TypeDefinition = apiType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 254, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is apiType
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_186_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_187 (pyxb.binding.basis.complexTypeDefinition):
    """Defines a SOAP transport protocol other than HTTP which is supported by this generator. The only other currently supported protocol is 'file'."""
    _TypeDefinition = transportMethodType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 269, 7)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is transportMethodType
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_187_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressBankType with content type ELEMENT_ONLY
class addressBankType (pyxb.binding.basis.complexTypeDefinition):
    """Top level bank the specify an address"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'addressBankType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 106, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandles uses Python identifier accessHandles
    __accessHandles = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), 'accessHandles', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandles', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 112, 3), )

    
    accessHandles = property(__accessHandles.value, __accessHandles.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}volatile uses Python identifier volatile
    __volatile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'volatile'), 'volatile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014volatile', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), )

    
    volatile = property(__volatile.value, __volatile.set, None, 'Indicates whether the data is volatile.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}access uses Python identifier access
    __access = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'access'), 'access', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014access', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1), )

    
    access = property(__access.value, __access.set, None, "Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}baseAddress uses Python identifier baseAddress
    __baseAddress = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'baseAddress'), 'baseAddress', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014baseAddress', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 558, 1), )

    
    baseAddress = property(__baseAddress.value, __baseAddress.set, None, 'Base of an address block, bank, subspace map or address space. Expressed as the number of addressable units from the containing memoryMap or localMemoryMap.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressBlock uses Python identifier addressBlock
    __addressBlock = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), 'addressBlock', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressBlock', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 594, 4), )

    
    addressBlock = property(__addressBlock.value, __addressBlock.set, None, 'An address block within the bank.  No address information is supplied.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bank uses Python identifier bank
    __bank = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'bank'), 'bank', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014bank', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 603, 4), )

    
    bank = property(__bank.value, __bank.set, None, 'A nested bank of blocks within a bank.  No address information is supplied.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}subspaceMap uses Python identifier subspaceMap
    __subspaceMap = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'subspaceMap'), 'subspaceMap', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014subspaceMap', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 612, 4), )

    
    subspaceMap = property(__subspaceMap.value, __subspaceMap.set, None, 'A subspace map within the bank.  No address information is supplied.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}usage uses Python identifier usage
    __usage = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'usage'), 'usage', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014usage', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3), )

    
    usage = property(__usage.value, __usage.set, None, "Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.")

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute bankAlignment uses Python identifier bankAlignment
    __bankAlignment = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'bankAlignment'), 'bankAlignment', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_addressBankType_bankAlignment', bankAlignmentType, required=True)
    __bankAlignment._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 122, 2)
    __bankAlignment._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 122, 2)
    
    bankAlignment = property(__bankAlignment.value, __bankAlignment.set, None, "Describes whether this bank's blocks are aligned in 'parallel' or 'serial'.")

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __accessHandles.name() : __accessHandles,
        __volatile.name() : __volatile,
        __access.name() : __access,
        __baseAddress.name() : __baseAddress,
        __addressBlock.name() : __addressBlock,
        __bank.name() : __bank,
        __subspaceMap.name() : __subspaceMap,
        __usage.name() : __usage
    })
    _AttributeMap.update({
        __id.name() : __id,
        __bankAlignment.name() : __bankAlignment
    })
Namespace.addCategoryObject('typeBinding', 'addressBankType', addressBankType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}localAddressBankType with content type ELEMENT_ONLY
class localAddressBankType (pyxb.binding.basis.complexTypeDefinition):
    """Top level bank the specify an address"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'localAddressBankType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 129, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandles uses Python identifier accessHandles
    __accessHandles = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), 'accessHandles', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandles', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 135, 3), )

    
    accessHandles = property(__accessHandles.value, __accessHandles.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}volatile uses Python identifier volatile
    __volatile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'volatile'), 'volatile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014volatile', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), )

    
    volatile = property(__volatile.value, __volatile.set, None, 'Indicates whether the data is volatile.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}access uses Python identifier access
    __access = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'access'), 'access', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014access', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1), )

    
    access = property(__access.value, __access.set, None, "Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}baseAddress uses Python identifier baseAddress
    __baseAddress = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'baseAddress'), 'baseAddress', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014baseAddress', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 558, 1), )

    
    baseAddress = property(__baseAddress.value, __baseAddress.set, None, 'Base of an address block, bank, subspace map or address space. Expressed as the number of addressable units from the containing memoryMap or localMemoryMap.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressBlock uses Python identifier addressBlock
    __addressBlock = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), 'addressBlock', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressBlock', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 629, 4), )

    
    addressBlock = property(__addressBlock.value, __addressBlock.set, None, 'An address block within the bank.  No address information is supplied.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bank uses Python identifier bank
    __bank = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'bank'), 'bank', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014bank', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 638, 4), )

    
    bank = property(__bank.value, __bank.set, None, 'A nested bank of blocks within a bank.  No address information is supplied.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}usage uses Python identifier usage
    __usage = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'usage'), 'usage', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014usage', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3), )

    
    usage = property(__usage.value, __usage.set, None, "Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.")

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute bankAlignment uses Python identifier bankAlignment
    __bankAlignment = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'bankAlignment'), 'bankAlignment', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localAddressBankType_bankAlignment', bankAlignmentType, required=True)
    __bankAlignment._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 145, 2)
    __bankAlignment._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 145, 2)
    
    bankAlignment = property(__bankAlignment.value, __bankAlignment.set, None, "Describes whether this bank's blocks are aligned in 'parallel' or 'serial'.")

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __accessHandles.name() : __accessHandles,
        __volatile.name() : __volatile,
        __access.name() : __access,
        __baseAddress.name() : __baseAddress,
        __addressBlock.name() : __addressBlock,
        __bank.name() : __bank,
        __usage.name() : __usage
    })
    _AttributeMap.update({
        __id.name() : __id,
        __bankAlignment.name() : __bankAlignment
    })
Namespace.addCategoryObject('typeBinding', 'localAddressBankType', localAddressBankType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bankedBankType with content type ELEMENT_ONLY
class bankedBankType (pyxb.binding.basis.complexTypeDefinition):
    """Banks nested inside a bank do not specify address."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'bankedBankType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 196, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandles uses Python identifier accessHandles
    __accessHandles = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), 'accessHandles', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandles', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 202, 3), )

    
    accessHandles = property(__accessHandles.value, __accessHandles.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}volatile uses Python identifier volatile
    __volatile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'volatile'), 'volatile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014volatile', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), )

    
    volatile = property(__volatile.value, __volatile.set, None, 'Indicates whether the data is volatile.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}access uses Python identifier access
    __access = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'access'), 'access', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014access', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1), )

    
    access = property(__access.value, __access.set, None, "Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressBlock uses Python identifier addressBlock
    __addressBlock = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), 'addressBlock', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressBlock', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 594, 4), )

    
    addressBlock = property(__addressBlock.value, __addressBlock.set, None, 'An address block within the bank.  No address information is supplied.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bank uses Python identifier bank
    __bank = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'bank'), 'bank', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014bank', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 603, 4), )

    
    bank = property(__bank.value, __bank.set, None, 'A nested bank of blocks within a bank.  No address information is supplied.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}subspaceMap uses Python identifier subspaceMap
    __subspaceMap = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'subspaceMap'), 'subspaceMap', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014subspaceMap', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 612, 4), )

    
    subspaceMap = property(__subspaceMap.value, __subspaceMap.set, None, 'A subspace map within the bank.  No address information is supplied.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}usage uses Python identifier usage
    __usage = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'usage'), 'usage', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014usage', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3), )

    
    usage = property(__usage.value, __usage.set, None, "Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.")

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute bankAlignment uses Python identifier bankAlignment
    __bankAlignment = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'bankAlignment'), 'bankAlignment', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_bankedBankType_bankAlignment', bankAlignmentType, required=True)
    __bankAlignment._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 211, 2)
    __bankAlignment._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 211, 2)
    
    bankAlignment = property(__bankAlignment.value, __bankAlignment.set, None, None)

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __accessHandles.name() : __accessHandles,
        __volatile.name() : __volatile,
        __access.name() : __access,
        __addressBlock.name() : __addressBlock,
        __bank.name() : __bank,
        __subspaceMap.name() : __subspaceMap,
        __usage.name() : __usage
    })
    _AttributeMap.update({
        __id.name() : __id,
        __bankAlignment.name() : __bankAlignment
    })
Namespace.addCategoryObject('typeBinding', 'bankedBankType', bankedBankType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}localBankedBankType with content type ELEMENT_ONLY
class localBankedBankType (pyxb.binding.basis.complexTypeDefinition):
    """Banks nested inside a bank do not specify address."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'localBankedBankType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 214, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'parameters'), 'parameters', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localBankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014parameters', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1), )

    
    parameters = property(__parameters.value, __parameters.set, None, 'A collection of parameters and associated value assertions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localBankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localBankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localBankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localBankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localBankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}accessHandles uses Python identifier accessHandles
    __accessHandles = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), 'accessHandles', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localBankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014accessHandles', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 220, 3), )

    
    accessHandles = property(__accessHandles.value, __accessHandles.set, None, None)

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}volatile uses Python identifier volatile
    __volatile = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'volatile'), 'volatile', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localBankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014volatile', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), )

    
    volatile = property(__volatile.value, __volatile.set, None, 'Indicates whether the data is volatile.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}access uses Python identifier access
    __access = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'access'), 'access', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localBankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014access', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1), )

    
    access = property(__access.value, __access.set, None, "Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.")

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}addressBlock uses Python identifier addressBlock
    __addressBlock = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), 'addressBlock', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localBankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014addressBlock', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 629, 4), )

    
    addressBlock = property(__addressBlock.value, __addressBlock.set, None, 'An address block within the bank.  No address information is supplied.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}bank uses Python identifier bank
    __bank = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'bank'), 'bank', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localBankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014bank', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 638, 4), )

    
    bank = property(__bank.value, __bank.set, None, 'A nested bank of blocks within a bank.  No address information is supplied.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}usage uses Python identifier usage
    __usage = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'usage'), 'usage', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localBankedBankType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014usage', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3), )

    
    usage = property(__usage.value, __usage.set, None, "Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.")

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localBankedBankType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute bankAlignment uses Python identifier bankAlignment
    __bankAlignment = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'bankAlignment'), 'bankAlignment', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_localBankedBankType_bankAlignment', bankAlignmentType, required=True)
    __bankAlignment._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 229, 2)
    __bankAlignment._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 229, 2)
    
    bankAlignment = property(__bankAlignment.value, __bankAlignment.set, None, None)

    _ElementMap.update({
        __parameters.name() : __parameters,
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __accessHandles.name() : __accessHandles,
        __volatile.name() : __volatile,
        __access.name() : __access,
        __addressBlock.name() : __addressBlock,
        __bank.name() : __bank,
        __usage.name() : __usage
    })
    _AttributeMap.update({
        __id.name() : __id,
        __bankAlignment.name() : __bankAlignment
    })
Namespace.addCategoryObject('typeBinding', 'localBankedBankType', localBankedBankType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_188 (pyxb.binding.basis.complexTypeDefinition):
    """Enumerates specific values that can be assigned to the bit field. The name of this enumerated value. This may be used as a token in generating code."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 825, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_188_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'name'), 'name', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_188_httpwww_accellera_orgXMLSchemaIPXACT1685_2014name', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3), )

    
    name = property(__name.value, __name.set, None, 'Unique name')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName uses Python identifier displayName
    __displayName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'displayName'), 'displayName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_188_httpwww_accellera_orgXMLSchemaIPXACT1685_2014displayName', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1), )

    
    displayName = property(__displayName.value, __displayName.set, None, 'Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_188_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}value uses Python identifier value_
    __value = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'value'), 'value_', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_188_httpwww_accellera_orgXMLSchemaIPXACT1685_2014value', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 828, 7), )

    
    value_ = property(__value.value, __value.set, None, 'Enumerated bit field value.')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_188_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute usage uses Python identifier usage
    __usage = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'usage'), 'usage', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_188_usage', STD_ANON_9, unicode_default='read-write')
    __usage._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 835, 6)
    __usage._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 835, 6)
    
    usage = property(__usage.value, __usage.set, None, "Usage for the enumeration. 'read' for a software read access. 'write' for a software write access. 'read-write' for a software read or write access.")

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __name.name() : __name,
        __displayName.name() : __displayName,
        __description.name() : __description,
        __value.name() : __value
    })
    _AttributeMap.update({
        __id.name() : __id,
        __usage.name() : __usage
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_189 (pyxb.binding.basis.complexTypeDefinition):
    """If present this element describes the modification of field data caused by a write operation. 'oneToClear' means that in a bitwise fashion each write data bit of a one will clear the corresponding bit in the field. 'oneToSet' means that in a bitwise fashion each write data bit of a one will set the corresponding bit in the field.  'oneToToggle' means that in a bitwise fashion each write data bit of a one will toggle the corresponding bit in the field. 'zeroToClear' means that in a bitwise fashion each write data bit of a zero will clear the corresponding bit in the field. 'zeroToSet' means that in a bitwise fashion each write data bit of a zero will set the corresponding bit in the field. 'zeroToToggle' means that in a bitwise fashion each write data bit of a zero will toggle the corresponding bit in the field. 'clear' means any write to this field clears the field. 'set' means any write to the field sets the field. 'modify' means any write to this field may modify that data. If this element is not present the write operation data is written."""
    _TypeDefinition = modifiedWriteValueType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 899, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is modifiedWriteValueType
    
    # Attribute modify uses Python identifier modify
    __modify = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'modify'), 'modify', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_189_modify', pyxb.binding.datatypes.Name)
    __modify._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 902, 7)
    __modify._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 902, 7)
    
    modify = property(__modify.value, __modify.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __modify.name() : __modify
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_190 (pyxb.binding.basis.complexTypeDefinition):
    """A list of possible actions for a read to set the field after the read. 'clear' means that after a read the field is cleared. 'set' means that after a read the field is set. 'modify' means after a read the field is modified. If not present the field value is not modified after a read."""
    _TypeDefinition = readActionType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 916, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is readActionType
    
    # Attribute modify uses Python identifier modify
    __modify = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'modify'), 'modify', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_190_modify', pyxb.binding.datatypes.Name)
    __modify._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 919, 7)
    __modify._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 919, 7)
    
    modify = property(__modify.value, __modify.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __modify.name() : __modify
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_191 (pyxb.binding.basis.complexTypeDefinition):
    """Can the field be tested with an automated register test routine. The presumed value is true if not specified."""
    _TypeDefinition = pyxb.binding.datatypes.boolean
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 928, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.boolean
    
    # Attribute testConstraint uses Python identifier testConstraint
    __testConstraint = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'testConstraint'), 'testConstraint', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_191_testConstraint', STD_ANON_10, unicode_default='unconstrained')
    __testConstraint._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 931, 7)
    __testConstraint._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 931, 7)
    
    testConstraint = property(__testConstraint.value, __testConstraint.set, None, "Constraint for an automated register test routine. 'unconstrained' (default) means may read and write all legal values. 'restore' means may read and write legal values but the value must be restored to the initially read value before accessing another register. 'writeAsRead' has limitations on testability where only the value read before a write may be written to the field. 'readOnly' has limitations on testability where values may only be read from the field.")

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __testConstraint.name() : __testConstraint
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_192 (pyxb.binding.basis.complexTypeDefinition):
    """ Defines the hardware environment in which this view applies. The format of the string is language:tool:vendor_extension, with each piece being optional. The language must be one of the types from ipxact:fileType. The tool values are defined by the Accellera Systems Initiative, and include generic values "*Simulation" and "*Synthesis" to imply any tool of the indicated type. Having more than one envIdentifier indicates that the view applies to multiple environments.  """
    _TypeDefinition = envIdentifierType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 220, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is envIdentifierType
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_192_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_193 (pyxb.binding.basis.complexTypeDefinition):
    """ Defines the hardware environment in which this view applies. The format of the string is language:tool:vendor_extension, with each piece being optional. The language must be one of the types from ipxact:fileType. The tool values are defined by the Accellera Systems Initiative, and include generic values "*Simulation" and "*Synthesis" to imply any tool of the indicated type. Having more than one envIdentifier indicates that the view applies to multiple environments.  """
    _TypeDefinition = envIdentifierType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 286, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is envIdentifierType
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_193_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractorPortType with content type ELEMENT_ONLY
class abstractorPortType (portType):
    """A port description, giving a name and an access type for high level ports. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'abstractorPortType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 98, 1)
    _ElementMap = portType._ElementMap.copy()
    _AttributeMap = portType._AttributeMap.copy()
    # Base type is portType
    
    # Element vendorExtensions ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portType
    
    # Element name ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portType
    
    # Element displayName ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portType
    
    # Element description ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portType
    
    # Element isPresent ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portType
    
    # Element wire ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}wire) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portType
    
    # Element transactional ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}transactional) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portType
    
    # Element access ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}access) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portType
    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_portType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', 'abstractorPortType', abstractorPortType)


# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_194 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type SIMPLE"""
    _TypeDefinition = protocolTypeType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 164, 5)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is protocolTypeType
    
    # Attribute custom uses Python identifier custom
    __custom = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'custom'), 'custom', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_194_custom', pyxb.binding.datatypes.string)
    __custom._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 167, 8)
    __custom._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 167, 8)
    
    custom = property(__custom.value, __custom.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __custom.name() : __custom
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_195 (pyxb.binding.basis.complexTypeDefinition):
    """Defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets"""
    _TypeDefinition = kindType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 195, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is kindType
    
    # Attribute custom uses Python identifier custom
    __custom = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'custom'), 'custom', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_195_custom', pyxb.binding.datatypes.string)
    __custom._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 198, 5)
    __custom._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 198, 5)
    
    custom = property(__custom.value, __custom.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __custom.name() : __custom
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}abstractorPortWireType with content type ELEMENT_ONLY
class abstractorPortWireType (portWireType):
    """Wire port type for an abstractor."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'abstractorPortWireType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 536, 1)
    _ElementMap = portWireType._ElementMap.copy()
    _AttributeMap = portWireType._AttributeMap.copy()
    # Base type is portWireType
    
    # Element vectors ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vectors) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portWireType
    
    # Element wireTypeDefs ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}wireTypeDefs) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portWireType
    
    # Element direction ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}direction) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portWireType
    
    # Element drivers ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}drivers) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portWireType
    
    # Attribute allLogicalDirectionsAllowed inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}portWireType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'abstractorPortWireType', abstractorPortWireType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_196 (clockDriverType):
    """Describes a driven clock port. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 63, 2)
    _ElementMap = clockDriverType._ElementMap.copy()
    _AttributeMap = clockDriverType._AttributeMap.copy()
    # Base type is clockDriverType
    
    # Element clockPeriod ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockPeriod) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockDriverType
    
    # Element clockPulseOffset ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockPulseOffset) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockDriverType
    
    # Element clockPulseValue ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockPulseValue) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockDriverType
    
    # Element clockPulseDuration ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockPulseDuration) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockDriverType
    
    # Attribute id inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockDriverType
    
    # Attribute clockName uses Python identifier clockName
    __clockName = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'clockName'), 'clockName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_196_clockName', pyxb.binding.datatypes.string)
    __clockName._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 66, 5)
    __clockName._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 66, 5)
    
    clockName = property(__clockName.value, __clockName.set, None, 'Indicates the name of the cllock. If not specified the name is assumed to be the name of the containing port. ')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __clockName.name() : __clockName
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_197 (pyxb.binding.basis.complexTypeDefinition):
    """Specifies if a port requires a driver. Default is false. The attribute driverType can further qualify what type of driver is required. Undefined behaviour if direction is not input or inout. Driver type any indicates that any unspecified type of driver must be connected"""
    _TypeDefinition = pyxb.binding.datatypes.boolean
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 103, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.boolean
    
    # Attribute driverType uses Python identifier driverType
    __driverType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'driverType'), 'driverType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_197_driverType', STD_ANON_12, unicode_default='any')
    __driverType._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 106, 5)
    __driverType._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 106, 5)
    
    driverType = property(__driverType.value, __driverType.set, None, 'Defines the type of driver that is required. The default is any type of driver. The 2 other options are a clock type driver or a singleshot type driver.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __driverType.name() : __driverType
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_198 (clockDriverType):
    """Describes a clock not directly associated with an input port. The clockSource attribute can be used on these clocks to indicate the actual clock source (e.g. an output port of a clock generator cell)."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 219, 2)
    _ElementMap = clockDriverType._ElementMap.copy()
    _AttributeMap = clockDriverType._AttributeMap.copy()
    # Base type is clockDriverType
    
    # Element clockPeriod ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockPeriod) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockDriverType
    
    # Element clockPulseOffset ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockPulseOffset) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockDriverType
    
    # Element clockPulseValue ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockPulseValue) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockDriverType
    
    # Element clockPulseDuration ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockPulseDuration) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockDriverType
    
    # Attribute id inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}clockDriverType
    
    # Attribute clockName uses Python identifier clockName
    __clockName = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'clockName'), 'clockName', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_198_clockName', pyxb.binding.datatypes.Name, required=True)
    __clockName._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 222, 5)
    __clockName._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 222, 5)
    
    clockName = property(__clockName.value, __clockName.set, None, 'Indicates the name of the clock.')

    
    # Attribute clockSource uses Python identifier clockSource
    __clockSource = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'clockSource'), 'clockSource', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_198_clockSource', pyxb.binding.datatypes.string)
    __clockSource._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 227, 5)
    __clockSource._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 227, 5)
    
    clockSource = property(__clockSource.value, __clockSource.set, None, 'Indicates the name of the actual clock source (e.g. an output pin of a clock generator cell).')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __clockName.name() : __clockName,
        __clockSource.name() : __clockSource
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}complexBaseExpression with content type SIMPLE
class complexBaseExpression (pyxb.binding.basis.complexTypeDefinition):
    """Represents the base-type for an expressions."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'complexBaseExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 250, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is simpleBaseExpression
    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'complexBaseExpression', complexBaseExpression)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_199 (pyxb.binding.basis.complexTypeDefinition):
    """Defines a reference to a port on a component contained within the design."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 182, 9)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}partSelect uses Python identifier partSelect
    __partSelect = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'partSelect'), 'partSelect', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_199_httpwww_accellera_orgXMLSchemaIPXACT1685_2014partSelect', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 560, 1), )

    
    partSelect = property(__partSelect.value, __partSelect.set, None, 'Bit range definition.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_199_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_199_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute componentRef uses Python identifier componentRef
    __componentRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'componentRef'), 'componentRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_199_componentRef', pyxb.binding.datatypes.Name, required=True)
    __componentRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 187, 10)
    __componentRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 187, 10)
    
    componentRef = property(__componentRef.value, __componentRef.set, None, 'A reference to the instanceName element of a component in this design.')

    
    # Attribute portRef uses Python identifier portRef
    __portRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'portRef'), 'portRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_199_portRef', portName, required=True)
    __portRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 192, 10)
    __portRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 192, 10)
    
    portRef = property(__portRef.value, __portRef.set, None, 'A port on the on the referenced component from componentRef.')

    _ElementMap.update({
        __partSelect.name() : __partSelect,
        __isPresent.name() : __isPresent
    })
    _AttributeMap.update({
        __id.name() : __id,
        __componentRef.name() : __componentRef,
        __portRef.name() : __portRef
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}hierInterface with content type EMPTY
class hierInterface (interfaceType):
    """Hierarchical reference to an interface"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'hierInterface')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 248, 1)
    _ElementMap = interfaceType._ElementMap.copy()
    _AttributeMap = interfaceType._AttributeMap.copy()
    # Base type is interfaceType
    
    # Attribute id inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interfaceType
    
    # Attribute path uses Python identifier path
    __path = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'path'), 'path', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_hierInterface_path', instancePath)
    __path._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 254, 4)
    __path._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 254, 4)
    
    path = property(__path.value, __path.set, None, 'A decending hierarchical (slash separated - example x/y/z) path to the component instance containing the specified component instance in componentRef. If not specified the componentRef instance shall exist in the current design. ')

    
    # Attribute componentRef inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interfaceType
    
    # Attribute busRef inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interfaceType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __path.name() : __path
    })
Namespace.addCategoryObject('typeBinding', 'hierInterface', hierInterface)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}monitorInterfaceType with content type ELEMENT_ONLY
class monitorInterfaceType (interfaceType):
    """Hierarchical reference to an interface being monitored or monitoring another interface."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'monitorInterfaceType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 341, 1)
    _ElementMap = interfaceType._ElementMap.copy()
    _AttributeMap = interfaceType._AttributeMap.copy()
    # Base type is interfaceType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_monitorInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_monitorInterfaceType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Attribute id inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interfaceType
    
    # Attribute componentRef inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interfaceType
    
    # Attribute busRef inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interfaceType
    
    # Attribute path uses Python identifier path
    __path = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'path'), 'path', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_monitorInterfaceType_path', pyxb.binding.datatypes.anySimpleType)
    __path._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 351, 4)
    __path._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 351, 4)
    
    path = property(__path.value, __path.set, None, 'A decending hierarchical (slash separated - example x/y/z) path to the component instance containing the specified component instance in componentRef. If not specified the componentRef instance shall exist in the current design. ')

    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __description.name() : __description
    })
    _AttributeMap.update({
        __path.name() : __path
    })
Namespace.addCategoryObject('typeBinding', 'monitorInterfaceType', monitorInterfaceType)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_200 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 360, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}partSelect uses Python identifier partSelect
    __partSelect = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'partSelect'), 'partSelect', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_200_httpwww_accellera_orgXMLSchemaIPXACT1685_2014partSelect', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 560, 1), )

    
    partSelect = property(__partSelect.value, __partSelect.set, None, 'Bit range definition.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_200_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_200_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute portRef uses Python identifier portRef
    __portRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'portRef'), 'portRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_200_portRef', portName, required=True)
    __portRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 365, 3)
    __portRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 365, 3)
    
    portRef = property(__portRef.value, __portRef.set, None, 'A port on the on the referenced component from componentRef.')

    _ElementMap.update({
        __partSelect.name() : __partSelect,
        __isPresent.name() : __isPresent
    })
    _AttributeMap.update({
        __id.name() : __id,
        __portRef.name() : __portRef
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_201 (interfaceType):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 374, 2)
    _ElementMap = interfaceType._ElementMap.copy()
    _AttributeMap = interfaceType._AttributeMap.copy()
    # Base type is interfaceType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions uses Python identifier vendorExtensions
    __vendorExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), 'vendorExtensions', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_201_httpwww_accellera_orgXMLSchemaIPXACT1685_2014vendorExtensions', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1), )

    
    vendorExtensions = property(__vendorExtensions.value, __vendorExtensions.set, None, 'Container for vendor specific extensions.')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'description'), 'description', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_201_httpwww_accellera_orgXMLSchemaIPXACT1685_2014description', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1), )

    
    description = property(__description.value, __description.set, None, 'Full description string, typically for documentation')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_201_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}excludePorts uses Python identifier excludePorts
    __excludePorts = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'excludePorts'), 'excludePorts', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_201_httpwww_accellera_orgXMLSchemaIPXACT1685_2014excludePorts', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 380, 6), )

    
    excludePorts = property(__excludePorts.value, __excludePorts.set, None, 'The list of physical ports to be excluded from an interface based connection. Analogous to the removing the port map element for the named ports.')

    
    # Attribute id inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interfaceType
    
    # Attribute componentRef inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interfaceType
    
    # Attribute busRef inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interfaceType
    _ElementMap.update({
        __vendorExtensions.name() : __vendorExtensions,
        __description.name() : __description,
        __isPresent.name() : __isPresent,
        __excludePorts.name() : __excludePorts
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_202 (pyxb.binding.basis.complexTypeDefinition):
    """The name of a physical port to be excluded from the interface based connection."""
    _TypeDefinition = portName
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 390, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is portName
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_202_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_203 (complexBaseExpression):
    """One possible value of ipxact:choice"""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 116, 8)
    _ElementMap = complexBaseExpression._ElementMap.copy()
    _AttributeMap = complexBaseExpression._AttributeMap.copy()
    # Base type is complexBaseExpression
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_203_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute text uses Python identifier text
    __text = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'text'), 'text', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_203_text', pyxb.binding.datatypes.string)
    __text._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 119, 11)
    __text._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 119, 11)
    
    text = property(__text.value, __text.set, None, 'When specified, displayed in place of the ipxact:enumeration value ')

    
    # Attribute help uses Python identifier help
    __help = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'help'), 'help', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_203_help', pyxb.binding.datatypes.string)
    __help._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 124, 11)
    __help._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 124, 11)
    
    help = property(__help.value, __help.set, None, 'Text that may be displayed if the user requests help about the meaning of an element')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id,
        __text.name() : __text,
        __help.name() : __help
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterType with content type ELEMENT_ONLY
class parameterType (parameterBaseType):
    """Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterType with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'parameterType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 484, 1)
    _ElementMap = parameterBaseType._ElementMap.copy()
    _AttributeMap = parameterBaseType._AttributeMap.copy()
    # Base type is parameterBaseType
    
    # Element vendorExtensions ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Element arrays ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}arrays) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Element value_ ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}value) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Element vectors ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vectors) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Element name ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Element displayName ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Element description ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute parameterId inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute prompt inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute choiceRef inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute order inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute configGroups inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute minimum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute maximum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute type inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute sign inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute prefix inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute unit inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute resolve uses Python identifier resolve
    __resolve = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'resolve'), 'resolve', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_parameterType_resolve', STD_ANON_6, unicode_default='immediate')
    __resolve._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 487, 4)
    __resolve._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 487, 4)
    
    resolve = property(__resolve.value, __resolve.set, None, 'Determines how a property value can be configured.')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __resolve.name() : __resolve
    })
Namespace.addCategoryObject('typeBinding', 'parameterType', parameterType)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}unsignedLongintExpression with content type SIMPLE
class unsignedLongintExpression (complexBaseExpression):
    """An unsigned longint which supports an expression value."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'unsignedLongintExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 52, 4)
    _ElementMap = complexBaseExpression._ElementMap.copy()
    _AttributeMap = complexBaseExpression._AttributeMap.copy()
    # Base type is complexBaseExpression
    
    # Attribute minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'minimum'), 'minimum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_unsignedLongintExpression_minimum', pyxb.binding.datatypes.int)
    __minimum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 58, 12)
    __minimum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 58, 12)
    
    minimum = property(__minimum.value, __minimum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to a unsigend longint value, this indicates the minimum value allowed.')

    
    # Attribute maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'maximum'), 'maximum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_unsignedLongintExpression_maximum', pyxb.binding.datatypes.int)
    __maximum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 63, 12)
    __maximum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 63, 12)
    
    maximum = property(__maximum.value, __maximum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to an unsigend longint value, this indicates the maximum value allowed.')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __minimum.name() : __minimum,
        __maximum.name() : __maximum
    })
Namespace.addCategoryObject('typeBinding', 'unsignedLongintExpression', unsignedLongintExpression)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}unsignedPositiveLongintExpression with content type SIMPLE
class unsignedPositiveLongintExpression (complexBaseExpression):
    """A positive unsigned longint which supports an expression value."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'unsignedPositiveLongintExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 72, 4)
    _ElementMap = complexBaseExpression._ElementMap.copy()
    _AttributeMap = complexBaseExpression._AttributeMap.copy()
    # Base type is complexBaseExpression
    
    # Attribute minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'minimum'), 'minimum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_unsignedPositiveLongintExpression_minimum', pyxb.binding.datatypes.int)
    __minimum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 78, 12)
    __minimum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 78, 12)
    
    minimum = property(__minimum.value, __minimum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to a positive unsigned longint value, this indicates the minimum value allowed.')

    
    # Attribute maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'maximum'), 'maximum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_unsignedPositiveLongintExpression_maximum', pyxb.binding.datatypes.int)
    __maximum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 83, 12)
    __maximum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 83, 12)
    
    maximum = property(__maximum.value, __maximum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to a positive unsigned longint value, this indicates the maximum value allowed.')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __minimum.name() : __minimum,
        __maximum.name() : __maximum
    })
Namespace.addCategoryObject('typeBinding', 'unsignedPositiveLongintExpression', unsignedPositiveLongintExpression)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}signedLongintExpression with content type SIMPLE
class signedLongintExpression (complexBaseExpression):
    """An unsigned longint which supports an expression value."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'signedLongintExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 92, 4)
    _ElementMap = complexBaseExpression._ElementMap.copy()
    _AttributeMap = complexBaseExpression._AttributeMap.copy()
    # Base type is complexBaseExpression
    
    # Attribute minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'minimum'), 'minimum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_signedLongintExpression_minimum', pyxb.binding.datatypes.int)
    __minimum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 98, 12)
    __minimum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 98, 12)
    
    minimum = property(__minimum.value, __minimum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to a signed longint value, this indicates the minimum value allowed.')

    
    # Attribute maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'maximum'), 'maximum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_signedLongintExpression_maximum', pyxb.binding.datatypes.int)
    __maximum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 103, 12)
    __maximum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 103, 12)
    
    maximum = property(__maximum.value, __maximum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to a signed longint value, this indicates the maximum value allowed.')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __minimum.name() : __minimum,
        __maximum.name() : __maximum
    })
Namespace.addCategoryObject('typeBinding', 'signedLongintExpression', signedLongintExpression)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}unsignedIntExpression with content type SIMPLE
class unsignedIntExpression (complexBaseExpression):
    """An unsigned int which supports an expression value."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'unsignedIntExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 112, 4)
    _ElementMap = complexBaseExpression._ElementMap.copy()
    _AttributeMap = complexBaseExpression._AttributeMap.copy()
    # Base type is complexBaseExpression
    
    # Attribute minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'minimum'), 'minimum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_unsignedIntExpression_minimum', pyxb.binding.datatypes.int)
    __minimum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 118, 12)
    __minimum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 118, 12)
    
    minimum = property(__minimum.value, __minimum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to an unsiged int value, this indicates the minimum value allowed.')

    
    # Attribute maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'maximum'), 'maximum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_unsignedIntExpression_maximum', pyxb.binding.datatypes.int)
    __maximum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 123, 12)
    __maximum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 123, 12)
    
    maximum = property(__maximum.value, __maximum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to a unsigned int value, this indicates the maximum value allowed.')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __minimum.name() : __minimum,
        __maximum.name() : __maximum
    })
Namespace.addCategoryObject('typeBinding', 'unsignedIntExpression', unsignedIntExpression)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}unsignedPositiveIntExpression with content type SIMPLE
class unsignedPositiveIntExpression (complexBaseExpression):
    """An positive unsigned int which supports an expression value."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'unsignedPositiveIntExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 132, 4)
    _ElementMap = complexBaseExpression._ElementMap.copy()
    _AttributeMap = complexBaseExpression._AttributeMap.copy()
    # Base type is complexBaseExpression
    
    # Attribute minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'minimum'), 'minimum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_unsignedPositiveIntExpression_minimum', pyxb.binding.datatypes.int)
    __minimum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 138, 12)
    __minimum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 138, 12)
    
    minimum = property(__minimum.value, __minimum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to an unsiged int value, this indicates the minimum value allowed.')

    
    # Attribute maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'maximum'), 'maximum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_unsignedPositiveIntExpression_maximum', pyxb.binding.datatypes.int)
    __maximum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 143, 12)
    __maximum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 143, 12)
    
    maximum = property(__maximum.value, __maximum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to a unsigned int value, this indicates the maximum value allowed.')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __minimum.name() : __minimum,
        __maximum.name() : __maximum
    })
Namespace.addCategoryObject('typeBinding', 'unsignedPositiveIntExpression', unsignedPositiveIntExpression)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}signedIntExpression with content type SIMPLE
class signedIntExpression (complexBaseExpression):
    """A signed int which supports an expression value."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'signedIntExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 152, 4)
    _ElementMap = complexBaseExpression._ElementMap.copy()
    _AttributeMap = complexBaseExpression._AttributeMap.copy()
    # Base type is complexBaseExpression
    
    # Attribute minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'minimum'), 'minimum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_signedIntExpression_minimum', pyxb.binding.datatypes.int)
    __minimum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 158, 12)
    __minimum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 158, 12)
    
    minimum = property(__minimum.value, __minimum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to a long value, this indicates the minimum value allowed.')

    
    # Attribute maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'maximum'), 'maximum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_signedIntExpression_maximum', pyxb.binding.datatypes.int)
    __maximum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 163, 12)
    __maximum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 163, 12)
    
    maximum = property(__maximum.value, __maximum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to a long value, this indicates the maximum value allowed.')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __minimum.name() : __minimum,
        __maximum.name() : __maximum
    })
Namespace.addCategoryObject('typeBinding', 'signedIntExpression', signedIntExpression)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}realExpression with content type SIMPLE
class realExpression (complexBaseExpression):
    """A real which supports an expression value."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'realExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 172, 4)
    _ElementMap = complexBaseExpression._ElementMap.copy()
    _AttributeMap = complexBaseExpression._AttributeMap.copy()
    # Base type is complexBaseExpression
    
    # Attribute minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'minimum'), 'minimum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_realExpression_minimum', pyxb.binding.datatypes.double)
    __minimum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 178, 12)
    __minimum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 178, 12)
    
    minimum = property(__minimum.value, __minimum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to a real value, this indicates the minimum value allowed.')

    
    # Attribute maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'maximum'), 'maximum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_realExpression_maximum', pyxb.binding.datatypes.double)
    __maximum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 183, 12)
    __maximum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 183, 12)
    
    maximum = property(__maximum.value, __maximum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to a real value, this indicates the maximum value allowed.')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __minimum.name() : __minimum,
        __maximum.name() : __maximum
    })
Namespace.addCategoryObject('typeBinding', 'realExpression', realExpression)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}stringExpression with content type SIMPLE
class stringExpression (complexBaseExpression):
    """Represents a string. It supports an expression value."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'stringExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 192, 4)
    _ElementMap = complexBaseExpression._ElementMap.copy()
    _AttributeMap = complexBaseExpression._AttributeMap.copy()
    # Base type is complexBaseExpression
    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'stringExpression', stringExpression)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}stringURIExpression with content type SIMPLE
class stringURIExpression (complexBaseExpression):
    """IP-XACT URI, like a standard xs:anyURI except that it can contain environment variables in the ${ } form, to be replaced by their value to provide the underlying URI"""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'stringURIExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 201, 4)
    _ElementMap = complexBaseExpression._ElementMap.copy()
    _AttributeMap = complexBaseExpression._AttributeMap.copy()
    # Base type is complexBaseExpression
    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'stringURIExpression', stringURIExpression)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}unsignedBitExpression with content type SIMPLE
class unsignedBitExpression (complexBaseExpression):
    """Represents a single-bit/bool. It supports an expression value."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'unsignedBitExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 210, 4)
    _ElementMap = complexBaseExpression._ElementMap.copy()
    _AttributeMap = complexBaseExpression._AttributeMap.copy()
    # Base type is complexBaseExpression
    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'unsignedBitExpression', unsignedBitExpression)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}unsignedBitVectorExpression with content type SIMPLE
class unsignedBitVectorExpression (complexBaseExpression):
    """Represents a bit-string. It supports an expression value."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'unsignedBitVectorExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/simpleTypes.xsd', 219, 4)
    _ElementMap = complexBaseExpression._ElementMap.copy()
    _AttributeMap = complexBaseExpression._AttributeMap.copy()
    # Base type is complexBaseExpression
    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'unsignedBitVectorExpression', unsignedBitVectorExpression)


# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_204 (complexBaseExpression):
    """Describes the content of a configurable element. The required referenceId attribute refers to the ID attribute of the configurable element."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 110, 2)
    _ElementMap = complexBaseExpression._ElementMap.copy()
    _AttributeMap = complexBaseExpression._AttributeMap.copy()
    # Base type is complexBaseExpression
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_204_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute referenceId uses Python identifier referenceId
    __referenceId = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'referenceId'), 'referenceId', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_204_referenceId', pyxb.binding.datatypes.Name, required=True)
    __referenceId._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 113, 5)
    __referenceId._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 113, 5)
    
    referenceId = property(__referenceId.value, __referenceId.set, None, 'Refers to the ID attribute of the configurable element.')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id,
        __referenceId.name() : __referenceId
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_205 (monitorInterfaceType):
    """Describes a list of monitor interfaces that are connected to the single active interface.

The componentRef and busRef attributes indicate the instance name and bus interface name. The optional path attribute indicates the hierarchical instance name path to the component."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 285, 5)
    _ElementMap = monitorInterfaceType._ElementMap.copy()
    _AttributeMap = monitorInterfaceType._AttributeMap.copy()
    # Base type is monitorInterfaceType
    
    # Element vendorExtensions ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}monitorInterfaceType
    
    # Element description ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}monitorInterfaceType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_205_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', True, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Attribute id inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interfaceType
    
    # Attribute componentRef inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interfaceType
    
    # Attribute busRef inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}interfaceType
    
    # Attribute path inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}monitorInterfaceType
    _ElementMap.update({
        __isPresent.name() : __isPresent
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_206 (unsignedLongintExpression):
    """Base of an address block, expressed as the number of bitsInLAU from the containing busInterface. The state attribute indicates the name of the remap state for which this address is valid."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 348, 10)
    _ElementMap = unsignedLongintExpression._ElementMap.copy()
    _AttributeMap = unsignedLongintExpression._AttributeMap.copy()
    # Base type is unsignedLongintExpression
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_206_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute state uses Python identifier state
    __state = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'state'), 'state', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_206_state', pyxb.binding.datatypes.string)
    __state._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 351, 13)
    __state._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 351, 13)
    
    state = property(__state.value, __state.set, None, 'Name of the state in which this remapped address range is valid')

    
    # Attribute minimum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}unsignedLongintExpression
    
    # Attribute maximum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}unsignedLongintExpression
    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id,
        __state.name() : __state
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}moduleParameterType with content type ELEMENT_ONLY
class moduleParameterType (parameterType):
    """Name value pair with data type information."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'moduleParameterType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 53, 1)
    _ElementMap = parameterType._ElementMap.copy()
    _AttributeMap = parameterType._AttributeMap.copy()
    # Base type is parameterType
    
    # Element vendorExtensions ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Element arrays ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}arrays) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Element value_ ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}value) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Element vectors ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vectors) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Element name ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}name) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Element displayName ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}displayName) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Element description ({http://www.accellera.org/XMLSchema/IPXACT/1685-2014}description) inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Element {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent uses Python identifier isPresent
    __isPresent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), 'isPresent', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_moduleParameterType_httpwww_accellera_orgXMLSchemaIPXACT1685_2014isPresent', False, pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1), )

    
    isPresent = property(__isPresent.value, __isPresent.set, None, 'Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")')

    
    # Attribute dataType uses Python identifier dataType
    __dataType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'dataType'), 'dataType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_moduleParameterType_dataType', pyxb.binding.datatypes.string)
    __dataType._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 62, 4)
    __dataType._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 62, 4)
    
    dataType = property(__dataType.value, __dataType.set, None, 'The data type of the argument as pertains to the language. Example: "int", "double", "char *".')

    
    # Attribute usageType uses Python identifier usageType
    __usageType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'usageType'), 'usageType', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_moduleParameterType_usageType', STD_ANON_3, unicode_default='nontyped')
    __usageType._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 67, 4)
    __usageType._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 67, 4)
    
    usageType = property(__usageType.value, __usageType.set, None, "Indicates the type of the module parameter. Legal values are defined in the attribute enumeration list. Default value is 'nontyped'.")

    
    # Attribute parameterId inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute prompt inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute choiceRef inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute order inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute configGroups inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute minimum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute maximum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute type inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute sign inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute prefix inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute unit inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterBaseType
    
    # Attribute resolve inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameterType
    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        __isPresent.name() : __isPresent
    })
    _AttributeMap.update({
        __dataType.name() : __dataType,
        __usageType.name() : __usageType
    })
Namespace.addCategoryObject('typeBinding', 'moduleParameterType', moduleParameterType)


# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_207 (stringExpression):
    """Flags given to the build command when building this file. If the optional attribute "append" is "true", this string will be appended to any existing flags, otherwise these flags will replace any existing default flags."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 130, 32)
    _ElementMap = stringExpression._ElementMap.copy()
    _AttributeMap = stringExpression._AttributeMap.copy()
    # Base type is stringExpression
    
    # Attribute append uses Python identifier append_
    __append = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'append'), 'append_', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_207_append', pyxb.binding.datatypes.boolean)
    __append._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 133, 44)
    __append._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 133, 44)
    
    append_ = property(__append.value, __append.set, None, '"true" indicates that the flags shall be appended to any existing flags, "false"indicates these flags will replace any existing default flags.')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __append.name() : __append
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_208 (unsignedLongintExpression):
    """Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 722, 7)
    _ElementMap = unsignedLongintExpression._ElementMap.copy()
    _AttributeMap = unsignedLongintExpression._AttributeMap.copy()
    # Base type is unsignedLongintExpression
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_208_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute minimum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}unsignedLongintExpression
    
    # Attribute maximum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}unsignedLongintExpression
    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_209 (unsignedLongintExpression):
    """Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1003, 5)
    _ElementMap = unsignedLongintExpression._ElementMap.copy()
    _AttributeMap = unsignedLongintExpression._AttributeMap.copy()
    # Base type is unsignedLongintExpression
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_209_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute minimum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}unsignedLongintExpression
    
    # Attribute maximum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}unsignedLongintExpression
    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isResetType with content type SIMPLE
class isResetType (unsignedBitExpression):
    """If this evaluates to true, it indicates this port triggers the reset of registers and fields, if not present its value is assumed to be false. The resetTypeRef attribute indicates the triggered reset event."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'isResetType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 154, 1)
    _ElementMap = unsignedBitExpression._ElementMap.copy()
    _AttributeMap = unsignedBitExpression._AttributeMap.copy()
    # Base type is unsignedBitExpression
    
    # Attribute {http://www.w3.org/XML/1998/namespace}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.XML, 'id'), 'id', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_isResetType_httpwww_w3_orgXML1998namespaceid', pyxb.binding.datatypes.ID)
    __id._DeclarationLocation = None
    __id._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 93, 2)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute resetTypeRef uses Python identifier resetTypeRef
    __resetTypeRef = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'resetTypeRef'), 'resetTypeRef', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_isResetType_resetTypeRef', pyxb.binding.datatypes.Name)
    __resetTypeRef._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 160, 4)
    __resetTypeRef._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 160, 4)
    
    resetTypeRef = property(__resetTypeRef.value, __resetTypeRef.set, None, 'Reference to a user defined resetType. Assumed to be HARD if not present.')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id,
        __resetTypeRef.name() : __resetTypeRef
    })
Namespace.addCategoryObject('typeBinding', 'isResetType', isResetType)


# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_210 (realExpression):
    """Clock period in units defined by the units attribute. Default is nanoseconds."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 175, 4)
    _ElementMap = realExpression._ElementMap.copy()
    _AttributeMap = realExpression._AttributeMap.copy()
    # Base type is realExpression
    
    # Attribute units uses Python identifier units
    __units = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'units'), 'units', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_210_units', delayValueUnitType, unicode_default='ns')
    __units._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 178, 7)
    __units._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 178, 7)
    
    units = property(__units.value, __units.set, None, None)

    
    # Attribute minimum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}realExpression
    
    # Attribute maximum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}realExpression
    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __units.name() : __units
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_211 (realExpression):
    """Time until first pulse. Units are defined by the units attribute. Default is nanoseconds."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 187, 4)
    _ElementMap = realExpression._ElementMap.copy()
    _AttributeMap = realExpression._AttributeMap.copy()
    # Base type is realExpression
    
    # Attribute units uses Python identifier units
    __units = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'units'), 'units', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_211_units', delayValueUnitType, unicode_default='ns')
    __units._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 190, 7)
    __units._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 190, 7)
    
    units = property(__units.value, __units.set, None, None)

    
    # Attribute minimum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}realExpression
    
    # Attribute maximum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}realExpression
    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __units.name() : __units
    })



# Complex type [anonymous] with content type SIMPLE
class CTD_ANON_212 (realExpression):
    """Duration of first state in cycle. Units are defined by the units attribute. Default is nanoseconds."""
    _TypeDefinition = simpleBaseExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 204, 4)
    _ElementMap = realExpression._ElementMap.copy()
    _AttributeMap = realExpression._AttributeMap.copy()
    # Base type is realExpression
    
    # Attribute units uses Python identifier units
    __units = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'units'), 'units', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_CTD_ANON_212_units', delayValueUnitType, unicode_default='ns')
    __units._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 207, 7)
    __units._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 207, 7)
    
    units = property(__units.value, __units.set, None, None)

    
    # Attribute minimum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}realExpression
    
    # Attribute maximum inherited from {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}realExpression
    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __units.name() : __units
    })



# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}complexBitSteeringExpression with content type SIMPLE
class complexBitSteeringExpression (pyxb.binding.basis.complexTypeDefinition):
    """Indicates whether bit steering should be used to map this interface onto a bus of different data width.
            
  Values are "on", "off" or an expression which resolves to an unsigned-bit where a '1' indicates "on" and a '0' indicates "off" (defaults to "off")."""
    _TypeDefinition = simpleBitSteeringExpression
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'complexBitSteeringExpression')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 56, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is simpleBitSteeringExpression
    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'complexBitSteeringExpression', complexBitSteeringExpression)


# Complex type {http://www.accellera.org/XMLSchema/IPXACT/1685-2014}complexTiedValueType with content type SIMPLE
class complexTiedValueType (pyxb.binding.basis.complexTypeDefinition):
    """An unsigned longint expression that resolves to the value set {0, 1, ...} or open or default.  It is derived from longintExpression and it supports an expression value."""
    _TypeDefinition = simpleTiedValueType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'complexTiedValueType')
    _XSDLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 55, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is simpleTiedValueType
    
    # Attribute minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'minimum'), 'minimum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_complexTiedValueType_minimum', pyxb.binding.datatypes.int)
    __minimum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 62, 4)
    __minimum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 62, 4)
    
    minimum = property(__minimum.value, __minimum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to a long value, this indicates the minimum value allowed.')

    
    # Attribute maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'maximum'), 'maximum', '__httpwww_accellera_orgXMLSchemaIPXACT1685_2014_complexTiedValueType_maximum', pyxb.binding.datatypes.int)
    __maximum._DeclarationLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 67, 4)
    __maximum._UseLocation = pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 67, 4)
    
    maximum = property(__maximum.value, __maximum.set, None, 'For elements which can be specified using expression which are supposed to be resolved to a long value, this indicates the maximum value allowed.')

    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=(pyxb.binding.content.Wildcard.NC_not, 'http://www.accellera.org/XMLSchema/IPXACT/1685-2014'))
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __minimum.name() : __minimum,
        __maximum.name() : __maximum
    })
Namespace.addCategoryObject('typeBinding', 'complexTiedValueType', complexTiedValueType)


group = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'group'), pyxb.binding.datatypes.Name, documentation='Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 166, 1))
Namespace.addCategoryObject('elementBinding', group.name().localName(), group)

indirectAddressRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'indirectAddressRef'), pyxb.binding.datatypes.Name, documentation='A reference to a field used for addressing the indirectly accessible memoryMap.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 535, 1))
Namespace.addCategoryObject('elementBinding', indirectAddressRef.name().localName(), indirectAddressRef)

indirectDataRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'indirectDataRef'), pyxb.binding.datatypes.Name, documentation='A reference to a field used for read/write access to the indirectly accessible memoryMap.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 540, 1))
Namespace.addCategoryObject('elementBinding', indirectDataRef.name().localName(), indirectDataRef)

displayName = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1))
Namespace.addCategoryObject('elementBinding', displayName.name().localName(), displayName)

description = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1))
Namespace.addCategoryObject('elementBinding', description.name().localName(), description)

volatile = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'volatile'), pyxb.binding.datatypes.boolean, documentation='Indicates whether the data is volatile.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), unicode_default='false')
Namespace.addCategoryObject('elementBinding', volatile.name().localName(), volatile)

instanceName = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'instanceName'), pyxb.binding.datatypes.Name, documentation='An instance name assigned to subcomponent instances and contained channels, that is unique within the parent component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 123, 1))
Namespace.addCategoryObject('elementBinding', instanceName.name().localName(), instanceName)

presence = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'presence'), presenceType, documentation="If this element is present, the\n            existance of the port is controlled by the specified\n            value. valid values are 'illegal', 'required' and\n            'optional'.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 70, 1), unicode_default='optional')
Namespace.addCategoryObject('elementBinding', presence.name().localName(), presence)

abstractionDefinition = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractionDefinition'), CTD_ANON, documentation='Define the ports and other information of a particular abstraction of the bus', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 139, 1))
Namespace.addCategoryObject('elementBinding', abstractionDefinition.name().localName(), abstractionDefinition)

abstractor = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractor'), abstractorType, documentation='This is the root element for abstractors', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 134, 1))
Namespace.addCategoryObject('elementBinding', abstractor.name().localName(), abstractor)

choices = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'choices'), CTD_ANON_14, documentation='Choices used by elements with an attribute ipxact:choiceRef.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 95, 1))
Namespace.addCategoryObject('elementBinding', choices.name().localName(), choices)

busDefinition = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busDefinition'), CTD_ANON_16, documentation='Defines the structural information associated with a bus type, independent of the abstraction level.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 64, 1))
Namespace.addCategoryObject('elementBinding', busDefinition.name().localName(), busDefinition)

viewRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), CTD_ANON_19, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 101, 1))
Namespace.addCategoryObject('elementBinding', viewRef.name().localName(), viewRef)

busInterface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busInterface'), busInterfaceType, documentation='Describes one of the bus interfaces supported by this component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 110, 1))
Namespace.addCategoryObject('elementBinding', busInterface.name().localName(), busInterface)

busInterfaces = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busInterfaces'), CTD_ANON_20, documentation='A list of bus interfaces supported by this component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 115, 1))
Namespace.addCategoryObject('elementBinding', busInterfaces.name().localName(), busInterfaces)

channels = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'channels'), CTD_ANON_21, documentation='Lists all channel connections between mirror interfaces of this component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 171, 1))
Namespace.addCategoryObject('elementBinding', channels.name().localName(), channels)

remapStates = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'remapStates'), CTD_ANON_24, documentation='Contains a list of remap state names and associated port values', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 208, 1))
Namespace.addCategoryObject('elementBinding', remapStates.name().localName(), remapStates)

transparentBridge = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'transparentBridge'), CTD_ANON_35, documentation='If this element is present, it indicates that the bus interface provides a transparent bridge to another master bus interface on the same component.  It has a masterRef attribute which contains the name of the other bus interface.\n\nAny slave interface can bridge to multiple master interfaces, and multiple slave interfaces can bridge to the same master interface.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 416, 1))
Namespace.addCategoryObject('elementBinding', transparentBridge.name().localName(), transparentBridge)

indirectInterface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'indirectInterface'), indirectInterfaceType, documentation='Describes one of the bus interfaces supported by this component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 493, 1))
Namespace.addCategoryObject('elementBinding', indirectInterface.name().localName(), indirectInterface)

indirectInterfaces = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'indirectInterfaces'), CTD_ANON_38, documentation='A list of bus interfaces supported by this component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 498, 1))
Namespace.addCategoryObject('elementBinding', indirectInterfaces.name().localName(), indirectInterfaces)

abstractionTypes = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractionTypes'), CTD_ANON_39, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 545, 1))
Namespace.addCategoryObject('elementBinding', abstractionTypes.name().localName(), abstractionTypes)

catalog = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'catalog'), CTD_ANON_45, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 77, 1))
Namespace.addCategoryObject('elementBinding', catalog.name().localName(), catalog)

assertion = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'assertion'), CTD_ANON_46, documentation='Provides an expression for describing valid parameter value settings.  If a assertion assert expression evaluates false, the name, displayName and/or description can be used to communicate the assertion failure.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 86, 1))
Namespace.addCategoryObject('elementBinding', assertion.name().localName(), assertion)

assertions = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'assertions'), CTD_ANON_47, documentation='List of assertions about allowed parameter values.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1))
Namespace.addCategoryObject('elementBinding', assertions.name().localName(), assertions)

parameters = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1))
Namespace.addCategoryObject('elementBinding', parameters.name().localName(), parameters)

vendorExtensions = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1))
Namespace.addCategoryObject('elementBinding', vendorExtensions.name().localName(), vendorExtensions)

vector = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vector'), CTD_ANON_59, documentation='Left and right ranges of the vector.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 528, 1))
Namespace.addCategoryObject('elementBinding', vector.name().localName(), vector)

vectors = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vectors'), CTD_ANON_60, documentation='Vectored information.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 539, 1))
Namespace.addCategoryObject('elementBinding', vectors.name().localName(), vectors)

range = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'range'), CTD_ANON_61, documentation='Left and right bound of a reference into a vector.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 549, 1))
Namespace.addCategoryObject('elementBinding', range.name().localName(), range)

partSelect = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'partSelect'), CTD_ANON_62, documentation='Bit range definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 560, 1))
Namespace.addCategoryObject('elementBinding', partSelect.name().localName(), partSelect)

component = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'component'), componentType, documentation='This is the root element for all non platform-core components.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 161, 1))
Namespace.addCategoryObject('elementBinding', component.name().localName(), component)

driveConstraint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'driveConstraint'), CTD_ANON_69, documentation='Defines a constraint indicating how an input is to be driven. The preferred methodology is to specify a library cell in technology independent fashion. The implemention tool should assume that the associated port is driven by the specified cell, or that the drive strength of the input port is indicated by the specified resistance value.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 196, 4))
Namespace.addCategoryObject('elementBinding', driveConstraint.name().localName(), driveConstraint)

loadConstraint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'loadConstraint'), CTD_ANON_70, documentation='Defines a constraint indicating the type of load on an output port.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 206, 4))
Namespace.addCategoryObject('elementBinding', loadConstraint.name().localName(), loadConstraint)

constraintSet = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'constraintSet'), CTD_ANON_71, documentation='Defines constraints that apply to a component port. If multiple constraintSet elements are used, each must have a unique value for the constraintSetId attribute.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 221, 4))
Namespace.addCategoryObject('elementBinding', constraintSet.name().localName(), constraintSet)

constraintSets = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'constraintSets'), CTD_ANON_73, documentation='List of constraintSet elements for a component port.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 259, 4))
Namespace.addCategoryObject('elementBinding', constraintSets.name().localName(), constraintSets)

constraintSetRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'constraintSetRef'), CTD_ANON_74, documentation='A reference to a set of port constraints.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 269, 4))
Namespace.addCategoryObject('elementBinding', constraintSetRef.name().localName(), constraintSetRef)

design = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'design'), CTD_ANON_75, documentation='Root element for a platform design.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 55, 1))
Namespace.addCategoryObject('elementBinding', design.name().localName(), design)

designConfiguration = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'designConfiguration'), CTD_ANON_76, documentation='Top level element for describing the current configuration of a design. Does not describe instance parameterization', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 55, 1))
Namespace.addCategoryObject('elementBinding', designConfiguration.name().localName(), designConfiguration)

file = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'file'), CTD_ANON_83, documentation='IP-XACT reference to a file or directory.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 53, 4))
Namespace.addCategoryObject('elementBinding', file.name().localName(), file)

fileSet = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileSet'), fileSetType, documentation='This element specifies a list of unique pathnames to files and directories. It may also include build instructions for the files. If compilation order is important, e.g. for VHDL files, the files have to be provided in compilation order.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 189, 4))
Namespace.addCategoryObject('elementBinding', fileSet.name().localName(), fileSet)

executableImage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'executableImage'), CTD_ANON_89, documentation='Specifies an executable software image to be loaded into a processors address space. The format of the image is not specified. It could, for example, be an ELF loadfile, or it could be raw binary or ascii hex data for loading directly into a memory model instance.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 194, 4))
Namespace.addCategoryObject('elementBinding', executableImage.name().localName(), executableImage)

linkerCommandFile = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'linkerCommandFile'), CTD_ANON_93, documentation='Specifies a linker command file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 282, 4))
Namespace.addCategoryObject('elementBinding', linkerCommandFile.name().localName(), linkerCommandFile)

fileSetRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileSetRef'), CTD_ANON_94, documentation='A reference to a fileSet.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 309, 4))
Namespace.addCategoryObject('elementBinding', fileSetRef.name().localName(), fileSetRef)

fileSets = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileSets'), CTD_ANON_95, documentation='List of file sets associated with component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 337, 4))
Namespace.addCategoryObject('elementBinding', fileSets.name().localName(), fileSets)

generatorRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'generatorRef'), CTD_ANON_99, documentation='A reference to a generator element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 491, 4))
Namespace.addCategoryObject('elementBinding', generatorRef.name().localName(), generatorRef)

generatorChain = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'generatorChain'), CTD_ANON_100, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 54, 1))
Namespace.addCategoryObject('elementBinding', generatorChain.name().localName(), generatorChain)

componentGenerators = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'componentGenerators'), CTD_ANON_105, documentation='List of component generators.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 209, 1))
Namespace.addCategoryObject('elementBinding', componentGenerators.name().localName(), componentGenerators)

abstractorGenerators = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractorGenerators'), CTD_ANON_106, documentation='List of abstractor generators.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 219, 1))
Namespace.addCategoryObject('elementBinding', abstractorGenerators.name().localName(), abstractorGenerators)

access = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'access'), accessType, documentation="Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1))
Namespace.addCategoryObject('elementBinding', access.name().localName(), access)

addressBlock = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), addressBlockType, documentation='This is a single contiguous block of memory inside a memory map.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 432, 1))
Namespace.addCategoryObject('elementBinding', addressBlock.name().localName(), addressBlock)

addressSpaceRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressSpaceRef'), addrSpaceRefType, documentation='References the address space.  The name of the address space is kept in its addressSpaceRef attribute.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 441, 1))
Namespace.addCategoryObject('elementBinding', addressSpaceRef.name().localName(), addressSpaceRef)

addressSpaces = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressSpaces'), CTD_ANON_116, documentation='If this component is a bus master, this lists all the address spaces\ndefined by the component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 446, 1))
Namespace.addCategoryObject('elementBinding', addressSpaces.name().localName(), addressSpaces)

memoryMapRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'memoryMapRef'), memoryMapRefType, documentation='References the memory map. The name of the memory map is kept in its memoryMapRef attribute.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 522, 1))
Namespace.addCategoryObject('elementBinding', memoryMapRef.name().localName(), memoryMapRef)

memoryMaps = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'memoryMaps'), CTD_ANON_120, documentation='Lists all the slave memory maps defined by the component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 527, 1))
Namespace.addCategoryObject('elementBinding', memoryMaps.name().localName(), memoryMaps)

alternateRegisters = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'alternateRegisters'), CTD_ANON_123, documentation='Alternate definitions for the current register', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 754, 1))
Namespace.addCategoryObject('elementBinding', alternateRegisters.name().localName(), alternateRegisters)

enumeratedValues = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'enumeratedValues'), CTD_ANON_128, documentation='Enumerates specific values that can be assigned to the bit field.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 815, 1))
Namespace.addCategoryObject('elementBinding', enumeratedValues.name().localName(), enumeratedValues)

registerFile = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'registerFile'), CTD_ANON_129, documentation='A structure of registers and register files', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 984, 1))
Namespace.addCategoryObject('elementBinding', registerFile.name().localName(), registerFile)

reset = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'reset'), CTD_ANON_131, documentation='Register value at reset.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1133, 1))
Namespace.addCategoryObject('elementBinding', reset.name().localName(), reset)

model = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'model'), modelType, documentation='Model information.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 327, 1))
Namespace.addCategoryObject('elementBinding', model.name().localName(), model)

initiative = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'initiative'), initiativeType, documentation='If this element is present, the type of access is restricted to the specified value.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 147, 1))
Namespace.addCategoryObject('elementBinding', initiative.name().localName(), initiative)

protocol = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'protocol'), CTD_ANON_142, documentation='defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 157, 1))
Namespace.addCategoryObject('elementBinding', protocol.name().localName(), protocol)

portAccessType = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'portAccessType'), simplePortAccessType, documentation="Indicates how a netlister accesses a port. 'ref' means accessed by reference (default) and 'ptr' means accessed by pointer.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 209, 1))
Namespace.addCategoryObject('elementBinding', portAccessType.name().localName(), portAccessType)

payload = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'payload'), CTD_ANON_143, documentation='defines the structure of data transported by this port', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 214, 1))
Namespace.addCategoryObject('elementBinding', payload.name().localName(), payload)

typeParameters = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeParameters'), CTD_ANON_145, documentation='list of port type parameters (e.g. template or constructor parameters for a systemC port or socket)', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 256, 1))
Namespace.addCategoryObject('elementBinding', typeParameters.name().localName(), typeParameters)

transTypeDef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'transTypeDef'), CTD_ANON_146, documentation='Definition of a single transactional type defintion', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 273, 1))
Namespace.addCategoryObject('elementBinding', transTypeDef.name().localName(), transTypeDef)

serviceTypeDef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'serviceTypeDef'), CTD_ANON_150, documentation='Definition of a single service type defintion', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 324, 1))
Namespace.addCategoryObject('elementBinding', serviceTypeDef.name().localName(), serviceTypeDef)

wireTypeDef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'wireTypeDef'), CTD_ANON_153, documentation='Definition of a single wire type defintion that can relate to multiple views.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 364, 1))
Namespace.addCategoryObject('elementBinding', wireTypeDef.name().localName(), wireTypeDef)

serviceTypeDefs = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'serviceTypeDefs'), CTD_ANON_157, documentation='The group of type definitions. If no match to a viewName is found then the default language types are to be used. See the User Guide for these default types.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 414, 1))
Namespace.addCategoryObject('elementBinding', serviceTypeDefs.name().localName(), serviceTypeDefs)

wireTypeDefs = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'wireTypeDefs'), CTD_ANON_158, documentation='The group of wire type definitions. If no match to a viewName is found then the default language types are to be used. See the User Guide for these default types.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 424, 1))
Namespace.addCategoryObject('elementBinding', wireTypeDefs.name().localName(), wireTypeDefs)

transTypeDefs = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'transTypeDefs'), CTD_ANON_159, documentation='The group of transactional type definitions. If no match to a viewName is found then the default language types are to be used. See the User Guide for these default types.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 438, 1))
Namespace.addCategoryObject('elementBinding', transTypeDefs.name().localName(), transTypeDefs)

port = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'port'), portType, documentation='Describes port characteristics.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 452, 1))
Namespace.addCategoryObject('elementBinding', port.name().localName(), port)

arrays = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'arrays'), configurableArrays, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 567, 1))
Namespace.addCategoryObject('elementBinding', arrays.name().localName(), arrays)

singleShotDriver = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'singleShotDriver'), CTD_ANON_162, documentation='Describes a driven one-shot port.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 75, 1))
Namespace.addCategoryObject('elementBinding', singleShotDriver.name().localName(), singleShotDriver)

drivers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'drivers'), CTD_ANON_163, documentation='Container for wire port driver elements.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 135, 1))
Namespace.addCategoryObject('elementBinding', drivers.name().localName(), drivers)

driver = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'driver'), driverType, documentation='Wire port driver element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 149, 1))
Namespace.addCategoryObject('elementBinding', driver.name().localName(), driver)

configurableElementValues = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'configurableElementValues'), CTD_ANON_164, documentation='All configuration information for a contained component, generator, generator chain or abstractor instance.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 92, 1))
Namespace.addCategoryObject('elementBinding', configurableElementValues.name().localName(), configurableElementValues)

componentInstance = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'componentInstance'), CTD_ANON_165, documentation='Component instance element.  The instance name is contained in the unique-value instanceName attribute.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 128, 1))
Namespace.addCategoryObject('elementBinding', componentInstance.name().localName(), componentInstance)

componentInstances = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'componentInstances'), CTD_ANON_166, documentation='Sub instances of internal components.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 148, 1))
Namespace.addCategoryObject('elementBinding', componentInstances.name().localName(), componentInstances)

adHocConnection = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'adHocConnection'), CTD_ANON_167, documentation='Represents an ad-hoc connection between component ports.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 158, 1))
Namespace.addCategoryObject('elementBinding', adHocConnection.name().localName(), adHocConnection)

adHocConnections = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'adHocConnections'), CTD_ANON_169, documentation='Defines the set of ad-hoc connections in a design. An ad-hoc connection represents a connection between two component pins which were not connected as a result of interface connections (i.e.the pin to pin connection was made explicitly and is represented explicitly).', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 211, 1))
Namespace.addCategoryObject('elementBinding', adHocConnections.name().localName(), adHocConnections)

interconnection = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'interconnection'), CTD_ANON_170, documentation='Describes a connection between two active (not monitor) busInterfaces.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 221, 1))
Namespace.addCategoryObject('elementBinding', interconnection.name().localName(), interconnection)

monitorInterconnection = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'monitorInterconnection'), CTD_ANON_171, documentation='Describes a connection from the interface of one component to any number of monitor interfaces in the design.\n\nAn active interface can be connected to unlimited number of monitor interfaces.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 262, 1))
Namespace.addCategoryObject('elementBinding', monitorInterconnection.name().localName(), monitorInterconnection)

interconnections = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'interconnections'), CTD_ANON_172, documentation='Connections between internal sub components.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 298, 1))
Namespace.addCategoryObject('elementBinding', interconnections.name().localName(), interconnections)

cellSpecification = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'cellSpecification'), CTD_ANON_178, documentation='Used to provide a generic description of a technology library cell.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 138, 4))
Namespace.addCategoryObject('elementBinding', cellSpecification.name().localName(), cellSpecification)

timingConstraint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'timingConstraint'), CTD_ANON_180, documentation='Defines a timing constraint for the associated port. The constraint is relative to the clock specified by the clockName attribute. The clockEdge indicates which clock edge the constraint is associated with (default is rising edge). The delayType attribute can be specified to further refine the constraint.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 169, 4))
Namespace.addCategoryObject('elementBinding', timingConstraint.name().localName(), timingConstraint)

dependency = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'dependency'), CTD_ANON_181, documentation='Specifies a location on which  files or fileSets may be dependent. Typically, this would be a directory that would contain included files.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 325, 4))
Namespace.addCategoryObject('elementBinding', dependency.name().localName(), dependency)

fileType = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileType'), CTD_ANON_183, documentation='Enumerated file types known by IP-XACT.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/fileType.xsd', 95, 1))
Namespace.addCategoryObject('elementBinding', fileType.name().localName(), fileType)

generator = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'generator'), CTD_ANON_184, documentation='Specifies a set of generators.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 114, 1))
Namespace.addCategoryObject('elementBinding', generator.name().localName(), generator)

componentGenerator = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'componentGenerator'), instanceGeneratorType, documentation='Specifies a set of component generators. The scope attribute applies to component generators and specifies whether the generator should be run for each instance of the entity (or module) or just once for all instances of the entity.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 124, 1))
Namespace.addCategoryObject('elementBinding', componentGenerator.name().localName(), componentGenerator)

abstractorGenerator = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractorGenerator'), instanceGeneratorType, documentation='Specifies a set of abstractor generators. The scope attribute applies to abstractor generators and specifies whether the generator should be run for each instance of the entity (or module) or just once for all instances of the entity.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 129, 1))
Namespace.addCategoryObject('elementBinding', abstractorGenerator.name().localName(), abstractorGenerator)

groupSelector = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'groupSelector'), CTD_ANON_185, documentation='Specifies a set of group names used to select subsequent generators. The attribute "multipleGroupOperator" specifies the OR or AND selection operator if there is more than one group name (default=OR).', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 134, 1))
Namespace.addCategoryObject('elementBinding', groupSelector.name().localName(), groupSelector)

bank = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'bank'), addressBankType, documentation="Represents a bank of memory made up of address blocks or other banks.  It has a bankAlignment attribute indicating whether its blocks are aligned in 'parallel' (occupying adjacent bit fields) or 'serial' (occupying contiguous addresses). Its child blocks do not contain addresses or bit offsets.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 549, 1))
Namespace.addCategoryObject('elementBinding', bank.name().localName(), bank)

kind = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'kind'), CTD_ANON_195, documentation='Defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 191, 1))
Namespace.addCategoryObject('elementBinding', kind.name().localName(), kind)

clockDriver = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'clockDriver'), CTD_ANON_196, documentation='Describes a driven clock port. ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 59, 1))
Namespace.addCategoryObject('elementBinding', clockDriver.name().localName(), clockDriver)

requiresDriver = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'requiresDriver'), CTD_ANON_197, documentation='Specifies if a port requires a driver. Default is false. The attribute driverType can further qualify what type of driver is required. Undefined behaviour if direction is not input or inout. Driver type any indicates that any unspecified type of driver must be connected', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 99, 1), unicode_default='false')
Namespace.addCategoryObject('elementBinding', requiresDriver.name().localName(), requiresDriver)

otherClockDriver = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'otherClockDriver'), CTD_ANON_198, documentation='Describes a clock not directly associated with an input port. The clockSource attribute can be used on these clocks to indicate the actual clock source (e.g. an output port of a clock generator cell).', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 215, 1))
Namespace.addCategoryObject('elementBinding', otherClockDriver.name().localName(), otherClockDriver)

externalPortReference = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'externalPortReference'), CTD_ANON_200, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 359, 1))
Namespace.addCategoryObject('elementBinding', externalPortReference.name().localName(), externalPortReference)

activeInterface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'activeInterface'), CTD_ANON_201, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 373, 1))
Namespace.addCategoryObject('elementBinding', activeInterface.name().localName(), activeInterface)

bitsInLau = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'bitsInLau'), unsignedPositiveLongintExpression, documentation='The number of bits in the least addressable unit. The default is byte addressable (8 bits).', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 96, 1))
Namespace.addCategoryObject('elementBinding', bitsInLau.name().localName(), bitsInLau)

parameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameter'), parameterType, documentation='A name value pair.  The name is specified by the name element.  The value is in the text content of the value element.  This value element supports all configurability attributes.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 81, 1))
Namespace.addCategoryObject('elementBinding', parameter.name().localName(), parameter)

right = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'right'), unsignedIntExpression, documentation='The optional element right specifies the right boundary.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 319, 1))
Namespace.addCategoryObject('elementBinding', right.name().localName(), right)

left = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'left'), unsignedIntExpression, documentation='The optional element left specifies the left boundary.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 324, 1))
Namespace.addCategoryObject('elementBinding', left.name().localName(), left)

value = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'value'), stringExpression, documentation='The value of the parameter.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 590, 1))
Namespace.addCategoryObject('elementBinding', value.name().localName(), value)

isPresent = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1))
Namespace.addCategoryObject('elementBinding', isPresent.name().localName(), isPresent)

activeCondition = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'activeCondition'), unsignedBitExpression, documentation='Expression that determines whether the enclosing element responds to read or write accesses to its specified address location. The expression can include dynamic values referencing register/field values and component states.  If it evaluates to true, then the enclosing register can be accessed per its mapping and access specification.  If it evaluates to false, the enclosing register/field cannot be accessed.  If a register does not include an activeCondition or alternateRegister(s), then the register is uncondiitionally accessible.  If a register does not include an activeCondition, but does include alternateRegister(s), then the condition that determines which is accessible is considered unspecified.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 624, 1))
Namespace.addCategoryObject('elementBinding', activeCondition.name().localName(), activeCondition)

phase = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'phase'), realExpression, documentation='This is an non-negative floating point number that is used to sequence when a generator is run. The generators are run in order starting with zero. There may be multiple generators with the same phase number. In this case, the order should not matter with respect to other generators at the same phase. If no phase number is given the generator will be considered in the "last" phase and these generators will be run in the order in which they are encountered while processing generator elements.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 167, 1))
Namespace.addCategoryObject('elementBinding', phase.name().localName(), phase)

baseAddress = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'baseAddress'), unsignedLongintExpression, documentation='Base of an address block, bank, subspace map or address space. Expressed as the number of addressable units from the containing memoryMap or localMemoryMap.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 558, 1))
Namespace.addCategoryObject('elementBinding', baseAddress.name().localName(), baseAddress)

addressUnitBits = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressUnitBits'), unsignedPositiveLongintExpression, documentation='The number of data bits in an addressable unit. The default is byte addressable (8 bits).', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 563, 1))
Namespace.addCategoryObject('elementBinding', addressUnitBits.name().localName(), addressUnitBits)

busWidth = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busWidth'), unsignedIntExpression, documentation='defines the bus size in bits. This can be the result of an expression.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 152, 1))
Namespace.addCategoryObject('elementBinding', busWidth.name().localName(), busWidth)

defaultValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'defaultValue'), unsignedBitVectorExpression, documentation='Default value for a wire port.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 54, 1))
Namespace.addCategoryObject('elementBinding', defaultValue.name().localName(), defaultValue)

configurableElementValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'configurableElementValue'), CTD_ANON_204, documentation='Describes the content of a configurable element. The required referenceId attribute refers to the ID attribute of the configurable element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 106, 1))
Namespace.addCategoryObject('elementBinding', configurableElementValue.name().localName(), configurableElementValue)

typeParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeParameter'), moduleParameterType, documentation='A typed parameter name value pair. The optional attribute dataType defines the type of the value and the usageType attribute indicates how the parameter is to be used.\n\t\t\t', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 267, 1))
Namespace.addCategoryObject('elementBinding', typeParameter.name().localName(), typeParameter)



CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busType'), libraryRefType, scope=CTD_ANON, documentation='Reference to the busDefinition that this abstractionDefinition implements.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 146, 4)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'extends'), libraryRefType, scope=CTD_ANON, documentation='Optional name of abstraction type that this abstraction definition is compatible with. This abstraction definition may change the definitions of ports in the existing abstraction definition and add new ports, the ports in the original abstraction are not deleted but may be marked illegal to disallow their use.\n\t\t\t\tThis abstraction definition may only extend another abstraction definition if the bus type of this abstraction definition extends the bus type of the extended abstraction definition', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 151, 4)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'ports'), CTD_ANON_, scope=CTD_ANON, documentation='This is a list of logical ports defined by the bus.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 157, 4)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'assertions'), CTD_ANON_47, scope=CTD_ANON, documentation='List of assertions about allowed parameter values.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=CTD_ANON, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendor'), pyxb.binding.datatypes.Name, scope=CTD_ANON, documentation='Name of the vendor who supplies this file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'library'), pyxb.binding.datatypes.Name, scope=CTD_ANON, documentation='Name of the logical library this element belongs to.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON, documentation='The name of the object.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'version'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON, documentation='Indicates the version of the named element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3)))

def _BuildAutomaton ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton
    del _BuildAutomaton
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 151, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 327, 4))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 328, 4))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 329, 4))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 330, 4))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendor')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'library')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'version')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'busType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 146, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'extends')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 151, 4))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'ports')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 157, 4))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 327, 4))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 328, 4))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'assertions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 329, 4))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 330, 4))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_10._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON._Automaton = _BuildAutomaton()




CTD_ANON_._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'port'), CTD_ANON_2, scope=CTD_ANON_, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 163, 7)))

def _BuildAutomaton_ ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_
    del _BuildAutomaton_
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'port')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 163, 7))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_._Automaton = _BuildAutomaton_()




CTD_ANON_2._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'logicalName'), pyxb.binding.datatypes.Name, scope=CTD_ANON_2, documentation='The assigned name of this port in bus specifications.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 167, 10)))

CTD_ANON_2._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'wire'), CTD_ANON_3, scope=CTD_ANON_2, documentation='A port that carries logic or an array of logic values', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 178, 11)))

CTD_ANON_2._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'transactional'), CTD_ANON_8, scope=CTD_ANON_2, documentation='A port that carries complex information modeled at a high level of abstraction.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 258, 11)))

CTD_ANON_2._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_2, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_2._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_2, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_2._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_2, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_2._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_2, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

def _BuildAutomaton_2 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_2
    del _BuildAutomaton_2
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 166, 10))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 172, 10))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 173, 10))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 319, 10))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_2._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 166, 10))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_2._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'logicalName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 167, 10))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_2._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 172, 10))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_2._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 173, 10))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_2._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'wire')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 178, 11))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_2._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'transactional')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 258, 11))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_2._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 319, 10))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_2._Automaton = _BuildAutomaton_2()




CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'qualifier'), CTD_ANON_4, scope=CTD_ANON_3, documentation='The type of information this port carries A wire port can carry both address and data, but may not mix this with a clock or reset', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 184, 14)))

CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'onSystem'), CTD_ANON_5, scope=CTD_ANON_3, documentation='Defines constraints for this port when present in a system bus interface with a matching group name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 215, 14)))

CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'onMaster'), CTD_ANON_6, scope=CTD_ANON_3, documentation='Defines constraints for this port when present in a master bus interface.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 231, 14)))

CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'onSlave'), CTD_ANON_7, scope=CTD_ANON_3, documentation='Defines constraints for this port when present in a slave bus interface.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 239, 14)))

CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'defaultValue'), unsignedBitVectorExpression, scope=CTD_ANON_3, documentation='Indicates the default value for this wire port.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 248, 15)))

CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'requiresDriver'), CTD_ANON_197, scope=CTD_ANON_3, documentation='Specifies if a port requires a driver. Default is false. The attribute driverType can further qualify what type of driver is required. Undefined behaviour if direction is not input or inout. Driver type any indicates that any unspecified type of driver must be connected', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 99, 1), unicode_default='false'))

def _BuildAutomaton_3 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_3
    del _BuildAutomaton_3
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 184, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 215, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 231, 14))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 239, 14))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 247, 14))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'qualifier')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 184, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'onSystem')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 215, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'onMaster')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 231, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'onSlave')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 239, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'defaultValue')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 248, 15))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'requiresDriver')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 253, 15))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_3._Automaton = _BuildAutomaton_3()




CTD_ANON_4._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isAddress'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_4, documentation='If this element is present, the port contains address information.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 191, 18)))

CTD_ANON_4._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isData'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_4, documentation='If this element is present, the port contains data information.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 196, 18)))

CTD_ANON_4._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isClock'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_4, documentation='If this element is present, the port contains only clock information.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 202, 17)))

CTD_ANON_4._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isReset'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_4, documentation='Is this element is present, the port contains only reset information.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 207, 17)))

def _BuildAutomaton_4 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_4
    del _BuildAutomaton_4
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 191, 18))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 196, 18))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 202, 17))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 207, 17))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_4._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isAddress')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 191, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_4._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isData')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 196, 18))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_4._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isClock')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 202, 17))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_4._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isReset')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 207, 17))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_4._Automaton = _BuildAutomaton_4()




CTD_ANON_5._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'presence'), presenceType, scope=CTD_ANON_5, documentation="If this element is present, the\n            existance of the port is controlled by the specified\n            value. valid values are 'illegal', 'required' and\n            'optional'.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 70, 1), unicode_default='optional'))

CTD_ANON_5._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'width'), unsignedPositiveIntExpression, scope=CTD_ANON_5, documentation='Number of bits required to represent this port. Absence of this element indicates unconstrained number of bits, i.e. the component will define the number of bits in this port. The logical numbering of the port starts at 0 to width-1.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 115, 3)))

CTD_ANON_5._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'direction'), direction, scope=CTD_ANON_5, documentation='If this element is present, the direction of this port is restricted to the specified value. The direction is relative to the non-mirrored interface.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 120, 3), unicode_default='out'))

CTD_ANON_5._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'modeConstraints'), abstractionDefPortConstraintsType, scope=CTD_ANON_5, documentation="Specifies default constraints for the enclosing wire type port. If the mirroredModeConstraints element is not defined, then these constraints applied to this port when it appears in a 'mode' bus interface or a mirrored-'mode' bus interface. Otherwise they only apply when the port appears in a 'mode' bus interface.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 126, 4)))

CTD_ANON_5._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'mirroredModeConstraints'), abstractionDefPortConstraintsType, scope=CTD_ANON_5, documentation="Specifies default constraints for the enclosing wire type port when it appears in a mirrored-'mode' bus interface. ", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 131, 4)))

CTD_ANON_5._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'group'), pyxb.binding.datatypes.Name, scope=CTD_ANON_5, documentation='Used to group system ports into different groups within a common bus.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 221, 17)))

def _BuildAutomaton_5 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_5
    del _BuildAutomaton_5
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 114, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 115, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 120, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 125, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 131, 4))
    counters.add(cc_4)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_5._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'group')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 221, 17))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_5._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'presence')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 114, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_5._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'width')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 115, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_5._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'direction')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 120, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_5._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'modeConstraints')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 126, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_5._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'mirroredModeConstraints')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 131, 4))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True),
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_5._Automaton = _BuildAutomaton_5()




CTD_ANON_6._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'presence'), presenceType, scope=CTD_ANON_6, documentation="If this element is present, the\n            existance of the port is controlled by the specified\n            value. valid values are 'illegal', 'required' and\n            'optional'.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 70, 1), unicode_default='optional'))

CTD_ANON_6._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'width'), unsignedPositiveIntExpression, scope=CTD_ANON_6, documentation='Number of bits required to represent this port. Absence of this element indicates unconstrained number of bits, i.e. the component will define the number of bits in this port. The logical numbering of the port starts at 0 to width-1.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 115, 3)))

CTD_ANON_6._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'direction'), direction, scope=CTD_ANON_6, documentation='If this element is present, the direction of this port is restricted to the specified value. The direction is relative to the non-mirrored interface.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 120, 3), unicode_default='out'))

CTD_ANON_6._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'modeConstraints'), abstractionDefPortConstraintsType, scope=CTD_ANON_6, documentation="Specifies default constraints for the enclosing wire type port. If the mirroredModeConstraints element is not defined, then these constraints applied to this port when it appears in a 'mode' bus interface or a mirrored-'mode' bus interface. Otherwise they only apply when the port appears in a 'mode' bus interface.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 126, 4)))

CTD_ANON_6._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'mirroredModeConstraints'), abstractionDefPortConstraintsType, scope=CTD_ANON_6, documentation="Specifies default constraints for the enclosing wire type port when it appears in a mirrored-'mode' bus interface. ", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 131, 4)))

def _BuildAutomaton_6 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_6
    del _BuildAutomaton_6
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 114, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 115, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 120, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 125, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 131, 4))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_6._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'presence')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 114, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_6._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'width')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 115, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_6._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'direction')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 120, 3))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_6._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'modeConstraints')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 126, 4))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_6._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'mirroredModeConstraints')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 131, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True),
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_6._Automaton = _BuildAutomaton_6()




CTD_ANON_7._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'presence'), presenceType, scope=CTD_ANON_7, documentation="If this element is present, the\n            existance of the port is controlled by the specified\n            value. valid values are 'illegal', 'required' and\n            'optional'.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 70, 1), unicode_default='optional'))

CTD_ANON_7._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'width'), unsignedPositiveIntExpression, scope=CTD_ANON_7, documentation='Number of bits required to represent this port. Absence of this element indicates unconstrained number of bits, i.e. the component will define the number of bits in this port. The logical numbering of the port starts at 0 to width-1.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 115, 3)))

CTD_ANON_7._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'direction'), direction, scope=CTD_ANON_7, documentation='If this element is present, the direction of this port is restricted to the specified value. The direction is relative to the non-mirrored interface.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 120, 3), unicode_default='out'))

CTD_ANON_7._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'modeConstraints'), abstractionDefPortConstraintsType, scope=CTD_ANON_7, documentation="Specifies default constraints for the enclosing wire type port. If the mirroredModeConstraints element is not defined, then these constraints applied to this port when it appears in a 'mode' bus interface or a mirrored-'mode' bus interface. Otherwise they only apply when the port appears in a 'mode' bus interface.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 126, 4)))

CTD_ANON_7._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'mirroredModeConstraints'), abstractionDefPortConstraintsType, scope=CTD_ANON_7, documentation="Specifies default constraints for the enclosing wire type port when it appears in a mirrored-'mode' bus interface. ", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 131, 4)))

def _BuildAutomaton_7 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_7
    del _BuildAutomaton_7
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 114, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 115, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 120, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 125, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 131, 4))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_7._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'presence')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 114, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_7._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'width')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 115, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_7._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'direction')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 120, 3))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_7._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'modeConstraints')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 126, 4))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_7._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'mirroredModeConstraints')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 131, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True),
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_7._Automaton = _BuildAutomaton_7()




CTD_ANON_8._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'qualifier'), CTD_ANON_9, scope=CTD_ANON_8, documentation='The type of information this port carries A transactional port can carry both address and data information.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 264, 14)))

CTD_ANON_8._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'onSystem'), CTD_ANON_10, scope=CTD_ANON_8, documentation='Defines constraints for this port when present in a system bus interface with a matching group name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 283, 14)))

CTD_ANON_8._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'onMaster'), CTD_ANON_11, scope=CTD_ANON_8, documentation='Defines constraints for this port when present in a master bus interface.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 299, 14)))

CTD_ANON_8._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'onSlave'), CTD_ANON_12, scope=CTD_ANON_8, documentation='Defines constraints for this port when present in a slave bus interface.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 307, 14)))

def _BuildAutomaton_8 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_8
    del _BuildAutomaton_8
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 264, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 283, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 299, 14))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 307, 14))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_8._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'qualifier')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 264, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_8._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'onSystem')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 283, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_8._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'onMaster')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 299, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_8._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'onSlave')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 307, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_8._Automaton = _BuildAutomaton_8()




CTD_ANON_9._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isAddress'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_9, documentation='If this element is present, the port contains address information.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 270, 17)))

CTD_ANON_9._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isData'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_9, documentation='If this element is present, the port contains data information.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 275, 17)))

def _BuildAutomaton_9 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_9
    del _BuildAutomaton_9
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 270, 17))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 275, 17))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_9._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isAddress')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 270, 17))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_9._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isData')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 275, 17))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_9._Automaton = _BuildAutomaton_9()




CTD_ANON_10._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'presence'), presenceType, scope=CTD_ANON_10, documentation="If this element is present, the\n            existance of the port is controlled by the specified\n            value. valid values are 'illegal', 'required' and\n            'optional'.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 70, 1), unicode_default='optional'))

CTD_ANON_10._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'initiative'), STD_ANON, scope=CTD_ANON_10, documentation='If this element is present, the type of access is restricted to the specified value.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 84, 3), unicode_default='requires'))

CTD_ANON_10._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busWidth'), unsignedPositiveIntExpression, scope=CTD_ANON_10, documentation='If this element is present, the width must match', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 97, 3)))

CTD_ANON_10._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'group'), pyxb.binding.datatypes.Name, scope=CTD_ANON_10, documentation='Used to group system ports into different groups within a common bus.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 289, 17)))

CTD_ANON_10._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'protocol'), CTD_ANON_142, scope=CTD_ANON_10, documentation='defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 157, 1)))

CTD_ANON_10._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'kind'), CTD_ANON_195, scope=CTD_ANON_10, documentation='Defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 191, 1)))

def _BuildAutomaton_10 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_10
    del _BuildAutomaton_10
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 83, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 84, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 96, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 97, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 102, 3))
    counters.add(cc_4)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_10._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'group')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 289, 17))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_10._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'presence')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 83, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_10._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'initiative')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 84, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_10._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'kind')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 96, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_10._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'busWidth')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 97, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_10._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'protocol')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 102, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_10._Automaton = _BuildAutomaton_10()




CTD_ANON_11._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'presence'), presenceType, scope=CTD_ANON_11, documentation="If this element is present, the\n            existance of the port is controlled by the specified\n            value. valid values are 'illegal', 'required' and\n            'optional'.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 70, 1), unicode_default='optional'))

CTD_ANON_11._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'initiative'), STD_ANON, scope=CTD_ANON_11, documentation='If this element is present, the type of access is restricted to the specified value.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 84, 3), unicode_default='requires'))

CTD_ANON_11._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busWidth'), unsignedPositiveIntExpression, scope=CTD_ANON_11, documentation='If this element is present, the width must match', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 97, 3)))

CTD_ANON_11._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'protocol'), CTD_ANON_142, scope=CTD_ANON_11, documentation='defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 157, 1)))

CTD_ANON_11._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'kind'), CTD_ANON_195, scope=CTD_ANON_11, documentation='Defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 191, 1)))

def _BuildAutomaton_11 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_11
    del _BuildAutomaton_11
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 83, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 84, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 96, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 97, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 102, 3))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_11._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'presence')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 83, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_11._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'initiative')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 84, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_11._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'kind')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 96, 3))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_11._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'busWidth')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 97, 3))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_11._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'protocol')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 102, 3))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_11._Automaton = _BuildAutomaton_11()




CTD_ANON_12._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'presence'), presenceType, scope=CTD_ANON_12, documentation="If this element is present, the\n            existance of the port is controlled by the specified\n            value. valid values are 'illegal', 'required' and\n            'optional'.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 70, 1), unicode_default='optional'))

CTD_ANON_12._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'initiative'), STD_ANON, scope=CTD_ANON_12, documentation='If this element is present, the type of access is restricted to the specified value.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 84, 3), unicode_default='requires'))

CTD_ANON_12._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busWidth'), unsignedPositiveIntExpression, scope=CTD_ANON_12, documentation='If this element is present, the width must match', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 97, 3)))

CTD_ANON_12._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'protocol'), CTD_ANON_142, scope=CTD_ANON_12, documentation='defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 157, 1)))

CTD_ANON_12._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'kind'), CTD_ANON_195, scope=CTD_ANON_12, documentation='Defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 191, 1)))

def _BuildAutomaton_12 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_12
    del _BuildAutomaton_12
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 83, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 84, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 96, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 97, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 102, 3))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_12._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'presence')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 83, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_12._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'initiative')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 84, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_12._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'kind')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 96, 3))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_12._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'busWidth')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 97, 3))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_12._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'protocol')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractionDefinition.xsd', 102, 3))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_12._Automaton = _BuildAutomaton_12()




abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractorMode'), CTD_ANON_174, scope=abstractorType, documentation='Define the mode for the interfaces on this abstractor. \n\nFor master the first interface connects to the master, the second connects to the mirroredMaster\n\nFor slave the first interface connects to the mirroredSlave the second connects to the slave\n\nFor direct the first interface connects to the master, the second connects to the slave\n\nFor system the first interface connects to the system, the second connects to the mirroredSystem. For system the group attribute is required', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 64, 3)))

abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busType'), libraryRefType, scope=abstractorType, documentation='The bus type of both interfaces. Refers to bus definition using vendor, library, name, version attributes.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 88, 3)))

abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractorInterfaces'), CTD_ANON_13, scope=abstractorType, documentation='The interfaces supported by this abstractor', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 93, 3)))

abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'model'), abstractorModelType, scope=abstractorType, documentation='Model information.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 107, 3)))

abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'choices'), CTD_ANON_14, scope=abstractorType, documentation='Choices used by elements with an attribute ipxact:choiceRef.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 95, 1)))

abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'assertions'), CTD_ANON_47, scope=abstractorType, documentation='List of assertions about allowed parameter values.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1)))

abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=abstractorType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=abstractorType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=abstractorType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileSets'), CTD_ANON_95, scope=abstractorType, documentation='List of file sets associated with component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 337, 4)))

abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractorGenerators'), CTD_ANON_106, scope=abstractorType, documentation='List of abstractor generators.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 219, 1)))

abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendor'), pyxb.binding.datatypes.Name, scope=abstractorType, documentation='Name of the vendor who supplies this file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3)))

abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'library'), pyxb.binding.datatypes.Name, scope=abstractorType, documentation='Name of the logical library this element belongs to.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3)))

abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.NMTOKEN, scope=abstractorType, documentation='The name of the object.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3)))

abstractorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'version'), pyxb.binding.datatypes.NMTOKEN, scope=abstractorType, documentation='Indicates the version of the named element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3)))

def _BuildAutomaton_13 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_13
    del _BuildAutomaton_13
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 107, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 120, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 125, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 126, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 127, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 128, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 129, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 130, 3))
    counters.add(cc_7)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendor')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'library')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'version')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'abstractorMode')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 64, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'busType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 88, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'abstractorInterfaces')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 93, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'model')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 107, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'abstractorGenerators')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 120, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'choices')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 125, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'fileSets')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 126, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 127, 3))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 128, 3))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'assertions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 129, 3))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(abstractorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 130, 3))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, True) ]))
    st_14._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
abstractorType._Automaton = _BuildAutomaton_13()




CTD_ANON_13._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractorInterface'), abstractorBusInterfaceType, scope=CTD_ANON_13, documentation='An abstractor must have exactly 2 Interfaces.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 99, 6)))

def _BuildAutomaton_14 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_14
    del _BuildAutomaton_14
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=2, max=2, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 99, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_13._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'abstractorInterface')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/abstractor.xsd', 99, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_13._Automaton = _BuildAutomaton_14()




CTD_ANON_14._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'choice'), CTD_ANON_15, scope=CTD_ANON_14, documentation='Non-empty set of legal values for a elements with an attribute ipxact:choiceRef.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 101, 4)))

def _BuildAutomaton_15 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_15
    del _BuildAutomaton_15
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_14._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'choice')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 101, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_14._Automaton = _BuildAutomaton_15()




CTD_ANON_15._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_15, documentation='Choice key, available for reference by the ipxact:choiceRef attribute.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 107, 7)))

CTD_ANON_15._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'enumeration'), CTD_ANON_203, scope=CTD_ANON_15, documentation='One possible value of ipxact:choice', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 112, 7)))

def _BuildAutomaton_16 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_16
    del _BuildAutomaton_16
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_15._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 107, 7))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_15._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'enumeration')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 112, 7))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_15._Automaton = _BuildAutomaton_16()




CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'directConnection'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_16, documentation='This element indicates that a master interface may be directly connected to a slave interface (under certain conditions) for busses of this type.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 71, 4)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'broadcast'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_16, documentation="This element indicates that this bus definition supports 'broadcast' mode. This means that it is legal to make one-to-many interface connections.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 76, 4)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isAddressable'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_16, documentation='If true, indicates that this is an addressable bus.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 81, 4)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'extends'), libraryRefType, scope=CTD_ANON_16, documentation='Optional name of bus type that this bus definition is compatible with. This bus definition may change the definitions in the existing bus definition', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 86, 4)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'maxMasters'), unsignedIntExpression, scope=CTD_ANON_16, documentation='Indicates the maximum number of masters this bus supports.  If this element is not present, the number of masters allowed is unbounded. ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 91, 4)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'maxSlaves'), unsignedIntExpression, scope=CTD_ANON_16, documentation='Indicates the maximum number of slaves this bus supports.  If the element is not present, the number of slaves allowed is unbounded.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 96, 4)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'systemGroupNames'), CTD_ANON_17, scope=CTD_ANON_16, documentation='Indicates the list of system group names that are defined for this bus definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 101, 4)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'assertions'), CTD_ANON_47, scope=CTD_ANON_16, documentation='List of assertions about allowed parameter values.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=CTD_ANON_16, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_16, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_16, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendor'), pyxb.binding.datatypes.Name, scope=CTD_ANON_16, documentation='Name of the vendor who supplies this file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'library'), pyxb.binding.datatypes.Name, scope=CTD_ANON_16, documentation='Name of the logical library this element belongs to.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_16, documentation='The name of the object.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'version'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_16, documentation='Indicates the version of the named element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3)))

def _BuildAutomaton_17 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_17
    del _BuildAutomaton_17
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 76, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 86, 4))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 91, 4))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 96, 4))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 101, 4))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 122, 4))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 123, 4))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 124, 4))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 125, 4))
    counters.add(cc_8)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendor')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'library')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'version')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'directConnection')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 71, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'broadcast')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 76, 4))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isAddressable')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 81, 4))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'extends')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 86, 4))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'maxMasters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 91, 4))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'maxSlaves')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 96, 4))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'systemGroupNames')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 101, 4))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 122, 4))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 123, 4))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'assertions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 124, 4))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 125, 4))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, True) ]))
    st_14._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_16._Automaton = _BuildAutomaton_17()




CTD_ANON_17._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'systemGroupName'), CTD_ANON_18, scope=CTD_ANON_17, documentation='Indicates the name of a system group defined for this bus definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 107, 7)))

def _BuildAutomaton_18 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_18
    del _BuildAutomaton_18
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_17._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'systemGroupName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busDefinition.xsd', 107, 7))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_17._Automaton = _BuildAutomaton_18()




CTD_ANON_20._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busInterface'), busInterfaceType, scope=CTD_ANON_20, documentation='Describes one of the bus interfaces supported by this component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 110, 1)))

def _BuildAutomaton_19 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_19
    del _BuildAutomaton_19
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_20._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'busInterface')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 121, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_20._Automaton = _BuildAutomaton_19()




busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'bitsInLau'), unsignedPositiveLongintExpression, scope=busInterfaceType, documentation='The number of bits in the least addressable unit. The default is byte addressable (8 bits).', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 96, 1)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busType'), configurableLibraryRefType, scope=busInterfaceType, documentation='The bus type of this interface. Refers to bus definition using vendor, library, name, version attributes along with any configurable element values needed to configure this interface.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 132, 3)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'connectionRequired'), pyxb.binding.datatypes.boolean, scope=busInterfaceType, documentation='Indicates whether a connection to this interface is required for proper component functionality.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 143, 3), unicode_default='false'))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'bitSteering'), complexBitSteeringExpression, scope=busInterfaceType, documentation='Indicates whether bit steering should be used to map this interface onto a bus of different data width.\n\nValues are "on", "off" (defaults to "off").', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 149, 3), unicode_default='off'))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'endianness'), endianessType, scope=busInterfaceType, documentation="'big': means the most significant element of any multi-element  data field is stored at the lowest memory address. 'little' means the least significant element of any multi-element data field is stored at the lowest memory address. If this element is not present the default is 'little' endian.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 156, 3)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'master'), CTD_ANON_27, scope=busInterfaceType, documentation='If this element is present, the bus interface can serve as a master.  This element encapsulates additional information related to its role as master.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 261, 3)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'slave'), CTD_ANON_28, scope=busInterfaceType, documentation='If this element is present, the bus interface can serve as a slave.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 291, 3)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'system'), CTD_ANON_30, scope=busInterfaceType, documentation='If this element is present, the bus interface is a system interface, neither master nor slave, with a specific function on the bus.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 322, 3)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'mirroredSlave'), CTD_ANON_31, scope=busInterfaceType, documentation='If this element is present, the bus interface represents a mirrored slave interface. All directional constraints on ports are reversed relative to the specification in the bus definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 332, 3)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'mirroredMaster'), CTD_ANON_33, scope=busInterfaceType, documentation='If this element is present, the bus interface represents a mirrored master interface. All directional constraints on ports are reversed relative to the specification in the bus definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 372, 3)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'mirroredSystem'), CTD_ANON_34, scope=busInterfaceType, documentation='If this element is present, the bus interface represents a mirrored system interface. All directional constraints on ports are reversed relative to the specification in the bus definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 378, 3)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'monitor'), CTD_ANON_177, scope=busInterfaceType, documentation='Indicates that this is a (passive) monitor interface. All of the ports in the interface must be inputs. The type of interface to be monitored is specified with the required interfaceType attribute. The ipxact:group element must be specified if monitoring a system interface.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 388, 3)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractionTypes'), CTD_ANON_39, scope=busInterfaceType, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 545, 1)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=busInterfaceType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=busInterfaceType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=busInterfaceType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=busInterfaceType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=busInterfaceType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

busInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=busInterfaceType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

def _BuildAutomaton_20 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_20
    del _BuildAutomaton_20
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 131, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 137, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 143, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 148, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 149, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 156, 3))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 161, 3))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 162, 3))
    counters.add(cc_9)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 131, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'busType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 132, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'abstractionTypes')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 137, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'master')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 261, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'slave')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 291, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'system')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 322, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'mirroredSlave')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 332, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'mirroredMaster')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 372, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'mirroredSystem')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 378, 3))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'monitor')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 388, 3))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'connectionRequired')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 143, 3))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'bitsInLau')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 148, 3))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'bitSteering')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 149, 3))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'endianness')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 156, 3))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 161, 3))
    st_17 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(busInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 162, 3))
    st_18 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_18)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_17._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_9, True) ]))
    st_18._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
busInterfaceType._Automaton = _BuildAutomaton_20()




CTD_ANON_21._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'channel'), CTD_ANON_22, scope=CTD_ANON_21, documentation='Defines a set of mirrored interfaces of this component that are connected to one another.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 177, 4)))

def _BuildAutomaton_21 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_21
    del _BuildAutomaton_21
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_21._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'channel')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 177, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_21._Automaton = _BuildAutomaton_21()




CTD_ANON_22._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busInterfaceRef'), CTD_ANON_23, scope=CTD_ANON_22, documentation='Contains the name of one of the bus interfaces that is part of this channel. The ordering of the references may be important to the design environment.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 185, 7)))

CTD_ANON_22._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_22, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

CTD_ANON_22._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_22, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_22._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_22, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_22._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_22, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

def _BuildAutomaton_22 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_22
    del _BuildAutomaton_22
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 184, 7))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=2, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 185, 7))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_22._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_22._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_22._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_22._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 184, 7))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_22._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'busInterfaceRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 185, 7))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_22._Automaton = _BuildAutomaton_22()




CTD_ANON_23._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'localName'), pyxb.binding.datatypes.Name, scope=CTD_ANON_23, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 191, 10)))

CTD_ANON_23._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_23, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

def _BuildAutomaton_23 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_23
    del _BuildAutomaton_23
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 192, 10))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_23._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'localName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 191, 10))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_23._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 192, 10))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_23._Automaton = _BuildAutomaton_23()




CTD_ANON_24._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'remapState'), CTD_ANON_25, scope=CTD_ANON_24, documentation='Contains a list of ports and values in remapPort and a list of registers and values that when all evaluate to true which tell the decoder to enter this remap state. The name attribute identifies the name of the state. If a list of remapPorts and/or remapRegisters is not defined then the condition for that state cannot be defined.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 214, 4)))

def _BuildAutomaton_24 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_24
    del _BuildAutomaton_24
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_24._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'remapState')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 214, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_24._Automaton = _BuildAutomaton_24()




CTD_ANON_25._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'remapPorts'), CTD_ANON_26, scope=CTD_ANON_25, documentation='List of ports and their values that shall invoke this remap state.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 221, 7)))

CTD_ANON_25._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_25, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

CTD_ANON_25._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_25, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_25._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_25, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

def _BuildAutomaton_25 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_25
    del _BuildAutomaton_25
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 221, 7))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_25._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_25._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_25._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_25._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'remapPorts')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 221, 7))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_25._Automaton = _BuildAutomaton_25()




CTD_ANON_26._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'remapPort'), CTD_ANON_175, scope=CTD_ANON_26, documentation='Contains the name and value of a port on the component, the value indicates the logic value which this port must take to effect the remapping. The portMapRef attribute stores the name of the port which takes that value.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 227, 10)))

def _BuildAutomaton_26 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_26
    del _BuildAutomaton_26
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_26._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'remapPort')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 227, 10))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_26._Automaton = _BuildAutomaton_26()




CTD_ANON_27._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressSpaceRef'), CTD_ANON_176, scope=CTD_ANON_27, documentation='If this master connects to an addressable bus, this element references the address space it maps to.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 267, 6)))

def _BuildAutomaton_27 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_27
    del _BuildAutomaton_27
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 267, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_27._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressSpaceRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 267, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_27._Automaton = _BuildAutomaton_27()




CTD_ANON_28._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileSetRefGroup'), CTD_ANON_29, scope=CTD_ANON_28, documentation='This reference is used to point the filesets that are associated with this slave port.\n\nDepending on the slave port function, there may be completely different software drivers associated with the different ports. ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 301, 6)))

CTD_ANON_28._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'transparentBridge'), CTD_ANON_35, scope=CTD_ANON_28, documentation='If this element is present, it indicates that the bus interface provides a transparent bridge to another master bus interface on the same component.  It has a masterRef attribute which contains the name of the other bus interface.\n\nAny slave interface can bridge to multiple master interfaces, and multiple slave interfaces can bridge to the same master interface.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 416, 1)))

CTD_ANON_28._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'memoryMapRef'), memoryMapRefType, scope=CTD_ANON_28, documentation='References the memory map. The name of the memory map is kept in its memoryMapRef attribute.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 522, 1)))

def _BuildAutomaton_28 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_28
    del _BuildAutomaton_28
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 297, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 301, 6))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_28._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'memoryMapRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 298, 7))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_28._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'transparentBridge')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 299, 7))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_28._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'fileSetRefGroup')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 301, 6))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_28._Automaton = _BuildAutomaton_28()




CTD_ANON_29._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'group'), pyxb.binding.datatypes.Name, scope=CTD_ANON_29, documentation='Abritray name assigned to the collections of fileSets.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 309, 9)))

CTD_ANON_29._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileSetRef'), CTD_ANON_94, scope=CTD_ANON_29, documentation='A reference to a fileSet.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 309, 4)))

def _BuildAutomaton_29 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_29
    del _BuildAutomaton_29
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 309, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 314, 9))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_29._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'group')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 309, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_29._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'fileSetRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 314, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_29._Automaton = _BuildAutomaton_29()




CTD_ANON_30._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'group'), pyxb.binding.datatypes.Name, scope=CTD_ANON_30, documentation='Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 166, 1)))

def _BuildAutomaton_30 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_30
    del _BuildAutomaton_30
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_30._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'group')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 328, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_30._Automaton = _BuildAutomaton_30()




CTD_ANON_31._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'baseAddresses'), CTD_ANON_32, scope=CTD_ANON_31, documentation='Represents a set of remap base addresses.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 338, 6)))

def _BuildAutomaton_31 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_31
    del _BuildAutomaton_31
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 337, 5))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 338, 6))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_31._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'baseAddresses')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 338, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_31._Automaton = _BuildAutomaton_31()




CTD_ANON_32._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'remapAddress'), CTD_ANON_206, scope=CTD_ANON_32, documentation='Base of an address block, expressed as the number of bitsInLAU from the containing busInterface. The state attribute indicates the name of the remap state for which this address is valid.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 344, 9)))

CTD_ANON_32._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'range'), unsignedPositiveLongintExpression, scope=CTD_ANON_32, documentation='The address range of mirrored slave, expressed as the number of bitsInLAU from the containing busInterface. ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 361, 9)))

def _BuildAutomaton_32 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_32
    del _BuildAutomaton_32
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_32._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'remapAddress')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 344, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_32._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'range')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 361, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_32._Automaton = _BuildAutomaton_32()




CTD_ANON_34._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'group'), pyxb.binding.datatypes.Name, scope=CTD_ANON_34, documentation='Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 166, 1)))

def _BuildAutomaton_33 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_33
    del _BuildAutomaton_33
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_34._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'group')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 384, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_34._Automaton = _BuildAutomaton_33()




CTD_ANON_35._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_35, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

def _BuildAutomaton_34 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_34
    del _BuildAutomaton_34
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 424, 4))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_35._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 424, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_35._Automaton = _BuildAutomaton_34()




CTD_ANON_36._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'group'), pyxb.binding.datatypes.Name, scope=CTD_ANON_36, documentation='Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 166, 1)))

def _BuildAutomaton_35 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_35
    del _BuildAutomaton_35
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_36._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'group')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 455, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_36._Automaton = _BuildAutomaton_35()




CTD_ANON_37._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'group'), pyxb.binding.datatypes.Name, scope=CTD_ANON_37, documentation='Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 166, 1)))

def _BuildAutomaton_36 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_36
    del _BuildAutomaton_36
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_37._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'group')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 475, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_37._Automaton = _BuildAutomaton_36()




abstractorBusInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractionTypes'), CTD_ANON_39, scope=abstractorBusInterfaceType, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 545, 1)))

abstractorBusInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=abstractorBusInterfaceType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

abstractorBusInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=abstractorBusInterfaceType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

abstractorBusInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=abstractorBusInterfaceType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

abstractorBusInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=abstractorBusInterfaceType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

abstractorBusInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=abstractorBusInterfaceType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

def _BuildAutomaton_37 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_37
    del _BuildAutomaton_37
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 487, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 488, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 489, 3))
    counters.add(cc_4)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(abstractorBusInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(abstractorBusInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(abstractorBusInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(abstractorBusInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'abstractionTypes')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 487, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(abstractorBusInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 488, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(abstractorBusInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 489, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
abstractorBusInterfaceType._Automaton = _BuildAutomaton_37()




CTD_ANON_38._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'indirectInterface'), indirectInterfaceType, scope=CTD_ANON_38, documentation='Describes one of the bus interfaces supported by this component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 493, 1)))

def _BuildAutomaton_38 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_38
    del _BuildAutomaton_38
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_38._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'indirectInterface')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 504, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_38._Automaton = _BuildAutomaton_38()




indirectInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'bitsInLau'), unsignedPositiveLongintExpression, scope=indirectInterfaceType, documentation='The number of bits in the least addressable unit. The default is byte addressable (8 bits).', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 96, 1)))

indirectInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'transparentBridge'), CTD_ANON_35, scope=indirectInterfaceType, documentation='If this element is present, it indicates that the bus interface provides a transparent bridge to another master bus interface on the same component.  It has a masterRef attribute which contains the name of the other bus interface.\n\nAny slave interface can bridge to multiple master interfaces, and multiple slave interfaces can bridge to the same master interface.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 416, 1)))

indirectInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'memoryMapRef'), pyxb.binding.datatypes.Name, scope=indirectInterfaceType, documentation='A reference to a memoryMap. This memoryMap is indirectly accessible through this interface.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 517, 4)))

indirectInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'endianness'), endianessType, scope=indirectInterfaceType, documentation="'big': means the most significant element of any multi-element  data field is stored at the lowest memory address. 'little' means the least significant element of any multi-element data field is stored at the lowest memory address. If this element is not present the default is 'little' endian.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 525, 3)))

indirectInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'indirectAddressRef'), pyxb.binding.datatypes.Name, scope=indirectInterfaceType, documentation='A reference to a field used for addressing the indirectly accessible memoryMap.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 535, 1)))

indirectInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'indirectDataRef'), pyxb.binding.datatypes.Name, scope=indirectInterfaceType, documentation='A reference to a field used for read/write access to the indirectly accessible memoryMap.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 540, 1)))

indirectInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=indirectInterfaceType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

indirectInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=indirectInterfaceType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

indirectInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=indirectInterfaceType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

indirectInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=indirectInterfaceType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

indirectInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=indirectInterfaceType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

def _BuildAutomaton_39 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_39
    del _BuildAutomaton_39
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 524, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 525, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 530, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 531, 3))
    counters.add(cc_5)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(indirectInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(indirectInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(indirectInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(indirectInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'indirectAddressRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 514, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(indirectInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'indirectDataRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 515, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(indirectInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'memoryMapRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 517, 4))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(indirectInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'transparentBridge')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 522, 4))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(indirectInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'bitsInLau')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 524, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(indirectInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'endianness')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 525, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(indirectInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 530, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(indirectInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 531, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_10._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
indirectInterfaceType._Automaton = _BuildAutomaton_39()




CTD_ANON_39._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractionType'), CTD_ANON_40, scope=CTD_ANON_39, documentation='The abstraction type/level of this interface. Refers to abstraction definition using vendor, library, name, version attributes along with any configurable element values needed to configure this abstraction. Bus definition can be found through a reference in this file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 548, 4)))

def _BuildAutomaton_40 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_40
    del _BuildAutomaton_40
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_39._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'abstractionType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 548, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_39._Automaton = _BuildAutomaton_40()




CTD_ANON_40._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), CTD_ANON_19, scope=CTD_ANON_40, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 101, 1)))

CTD_ANON_40._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractionRef'), configurableLibraryRefType, scope=CTD_ANON_40, documentation='Provides the VLNV of the abstraction type.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 559, 7)))

CTD_ANON_40._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'portMaps'), CTD_ANON_41, scope=CTD_ANON_40, documentation='Listing of maps between component ports and bus ports.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 564, 7)))

def _BuildAutomaton_41 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_41
    del _BuildAutomaton_41
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 554, 7))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 564, 7))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_40._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'viewRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 554, 7))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_40._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'abstractionRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 559, 7))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_40._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'portMaps')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 564, 7))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_40._Automaton = _BuildAutomaton_41()




CTD_ANON_41._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'portMap'), CTD_ANON_42, scope=CTD_ANON_41, documentation="Maps a component's port to a port in a bus description. This is the logical to physical mapping. The logical pin comes from the bus interface and the physical pin from the component.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 570, 10)))

def _BuildAutomaton_42 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_42
    del _BuildAutomaton_42
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_41._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'portMap')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 570, 10))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_41._Automaton = _BuildAutomaton_42()




CTD_ANON_42._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'logicalPort'), CTD_ANON_43, scope=CTD_ANON_42, documentation='Logical port from abstraction definition', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 577, 13)))

CTD_ANON_42._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'physicalPort'), CTD_ANON_44, scope=CTD_ANON_42, documentation='Physical port from this component', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 593, 14)))

CTD_ANON_42._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'logicalTieOff'), unsignedPositiveIntExpression, scope=CTD_ANON_42, documentation='Identifies a value to tie this logical port to.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 608, 14)))

CTD_ANON_42._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isInformative'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_42, documentation='When true, indicates that this portMap element is for information purpose only.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 614, 13), unicode_default='false'))

CTD_ANON_42._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_42, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

def _BuildAutomaton_43 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_43
    del _BuildAutomaton_43
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 576, 13))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 614, 13))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_42._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 576, 13))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_42._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'logicalPort')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 577, 13))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_42._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'physicalPort')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 593, 14))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_42._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'logicalTieOff')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 608, 14))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_42._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isInformative')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 614, 13))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_42._Automaton = _BuildAutomaton_43()




CTD_ANON_43._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_43, documentation='Bus port name as specified inside the abstraction definition', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 583, 16)))

CTD_ANON_43._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'range'), CTD_ANON_61, scope=CTD_ANON_43, documentation='Left and right bound of a reference into a vector.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 549, 1)))

def _BuildAutomaton_44 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_44
    del _BuildAutomaton_44
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 588, 16))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_43._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 583, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_43._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'range')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 588, 16))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_43._Automaton = _BuildAutomaton_44()




CTD_ANON_44._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), portName, scope=CTD_ANON_44, documentation='Component port name as specified inside the model port section', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 599, 17)))

CTD_ANON_44._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'partSelect'), CTD_ANON_62, scope=CTD_ANON_44, documentation='Bit range definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 560, 1)))

def _BuildAutomaton_45 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_45
    del _BuildAutomaton_45
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 604, 17))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_44._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 599, 17))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_44._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'partSelect')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 604, 17))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_44._Automaton = _BuildAutomaton_45()




ipxactFilesType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'ipxactFile'), ipxactFileType, scope=ipxactFilesType, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 62, 3)))

def _BuildAutomaton_46 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_46
    del _BuildAutomaton_46
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ipxactFilesType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'ipxactFile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 62, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ipxactFilesType._Automaton = _BuildAutomaton_46()




CTD_ANON_45._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'catalogs'), ipxactFilesType, scope=CTD_ANON_45, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 83, 5)))

CTD_ANON_45._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busDefinitions'), ipxactFilesType, scope=CTD_ANON_45, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 86, 5)))

CTD_ANON_45._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractionDefinitions'), ipxactFilesType, scope=CTD_ANON_45, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 89, 5)))

CTD_ANON_45._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'components'), ipxactFilesType, scope=CTD_ANON_45, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 92, 5)))

CTD_ANON_45._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractors'), ipxactFilesType, scope=CTD_ANON_45, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 95, 5)))

CTD_ANON_45._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'designs'), ipxactFilesType, scope=CTD_ANON_45, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 98, 5)))

CTD_ANON_45._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'designConfigurations'), ipxactFilesType, scope=CTD_ANON_45, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 101, 5)))

CTD_ANON_45._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'generatorChains'), ipxactFilesType, scope=CTD_ANON_45, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 104, 5)))

CTD_ANON_45._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_45, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_45._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_45, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_45._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendor'), pyxb.binding.datatypes.Name, scope=CTD_ANON_45, documentation='Name of the vendor who supplies this file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3)))

CTD_ANON_45._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'library'), pyxb.binding.datatypes.Name, scope=CTD_ANON_45, documentation='Name of the logical library this element belongs to.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3)))

CTD_ANON_45._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_45, documentation='The name of the object.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3)))

CTD_ANON_45._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'version'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_45, documentation='Indicates the version of the named element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3)))

def _BuildAutomaton_47 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_47
    del _BuildAutomaton_47
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 81, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 83, 5))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 86, 5))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 89, 5))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 92, 5))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 95, 5))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 98, 5))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 101, 5))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 104, 5))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 106, 4))
    counters.add(cc_9)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendor')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'library')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'version')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 81, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'catalogs')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 83, 5))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'busDefinitions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 86, 5))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'abstractionDefinitions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 89, 5))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'components')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 92, 5))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'abstractors')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 95, 5))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'designs')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 98, 5))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'designConfigurations')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 101, 5))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'generatorChains')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 104, 5))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 106, 4))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, True) ]))
    st_13._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_45._Automaton = _BuildAutomaton_47()




ipxactFileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vlnv'), libraryRefType, scope=ipxactFileType, documentation='VLNV of the IP-XACT file being cataloged.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 112, 3)))

ipxactFileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), stringURIExpression, scope=ipxactFileType, documentation='Name of the IP-XACT file being cataloged.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 117, 3)))

ipxactFileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=ipxactFileType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

ipxactFileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=ipxactFileType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

def _BuildAutomaton_48 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_48
    del _BuildAutomaton_48
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 122, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 123, 3))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ipxactFileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vlnv')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 112, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ipxactFileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 117, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ipxactFileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 122, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ipxactFileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/catalog.xsd', 123, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ipxactFileType._Automaton = _BuildAutomaton_48()




CTD_ANON_46._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'assert'), unsignedBitExpression, scope=CTD_ANON_46, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 93, 4)))

CTD_ANON_46._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_46, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

CTD_ANON_46._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_46, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_46._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_46, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

def _BuildAutomaton_49 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_49
    del _BuildAutomaton_49
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_46._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_46._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_46._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_46._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'assert')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 93, 4))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_46._Automaton = _BuildAutomaton_49()




CTD_ANON_47._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'assertion'), CTD_ANON_46, scope=CTD_ANON_47, documentation='Provides an expression for describing valid parameter value settings.  If a assertion assert expression evaluates false, the name, displayName and/or description can be used to communicate the assertion failure.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 86, 1)))

def _BuildAutomaton_50 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_50
    del _BuildAutomaton_50
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 104, 4))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_47._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'assertion')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 104, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_47._Automaton = _BuildAutomaton_50()




CTD_ANON_48._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameter'), parameterType, scope=CTD_ANON_48, documentation='A name value pair.  The name is specified by the name element.  The value is in the text content of the value element.  This value element supports all configurability attributes.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 81, 1)))

def _BuildAutomaton_51 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_51
    del _BuildAutomaton_51
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_48._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameter')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 114, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_48._Automaton = _BuildAutomaton_51()




def _BuildAutomaton_52 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_52
    del _BuildAutomaton_52
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.WildcardUse(pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=pyxb.binding.content.Wildcard.NC_any), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 124, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_49._Automaton = _BuildAutomaton_52()




leafAccessHandle._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), CTD_ANON_50, scope=leafAccessHandle, documentation='A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 148, 5)))

leafAccessHandle._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'indices'), CTD_ANON_51, scope=leafAccessHandle, documentation='For a multi dimensional IP-XACT object, indices can be specified to select the element the accessHandle applies to. This is an index into a multi-dimensional array and follows C-semantics for indexing.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 160, 3)))

leafAccessHandle._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'slices'), slicesType, scope=leafAccessHandle, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 174, 3)))

def _BuildAutomaton_53 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_53
    del _BuildAutomaton_53
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 148, 5))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 160, 3))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(leafAccessHandle._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'viewRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 148, 5))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(leafAccessHandle._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'indices')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 160, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(leafAccessHandle._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'slices')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 174, 3))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
leafAccessHandle._Automaton = _BuildAutomaton_53()




CTD_ANON_51._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'index'), unsignedIntExpression, scope=CTD_ANON_51, documentation='An index into the IP-XACT object.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 166, 6)))

def _BuildAutomaton_54 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_54
    del _BuildAutomaton_54
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_51._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'index')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 166, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_51._Automaton = _BuildAutomaton_54()




nonIndexedLeafAccessHandle._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), CTD_ANON_52, scope=nonIndexedLeafAccessHandle, documentation='A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 181, 5)))

nonIndexedLeafAccessHandle._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'slices'), slicesType, scope=nonIndexedLeafAccessHandle, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 193, 3)))

def _BuildAutomaton_55 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_55
    del _BuildAutomaton_55
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 181, 5))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(nonIndexedLeafAccessHandle._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'viewRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 181, 5))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(nonIndexedLeafAccessHandle._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'slices')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 193, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
nonIndexedLeafAccessHandle._Automaton = _BuildAutomaton_55()




indexedAccessHandle._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), CTD_ANON_53, scope=indexedAccessHandle, documentation='A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 200, 5)))

indexedAccessHandle._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'indices'), CTD_ANON_54, scope=indexedAccessHandle, documentation='For a multi dimensional IP-XACT object, indices can be specified to select the element the accessHandle applies to. This is an index into a multi-dimensional array and follows C-semantics for indexing.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 212, 3)))

indexedAccessHandle._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'pathSegments'), CTD_ANON_55, scope=indexedAccessHandle, documentation='An ordered list of pathSegment elements. When concatenated with a desired separator the elements in this form a HDL path for the parent slice into the referenced view.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 226, 3)))

def _BuildAutomaton_56 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_56
    del _BuildAutomaton_56
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 200, 5))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 212, 3))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(indexedAccessHandle._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'viewRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 200, 5))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(indexedAccessHandle._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'indices')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 212, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(indexedAccessHandle._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'pathSegments')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 226, 3))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
indexedAccessHandle._Automaton = _BuildAutomaton_56()




CTD_ANON_54._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'index'), unsignedIntExpression, scope=CTD_ANON_54, documentation='An index into the IP-XACT object.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 218, 6)))

def _BuildAutomaton_57 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_57
    del _BuildAutomaton_57
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_54._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'index')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 218, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_54._Automaton = _BuildAutomaton_57()




CTD_ANON_55._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'pathSegment'), pathSegmentType, scope=CTD_ANON_55, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 232, 6)))

def _BuildAutomaton_58 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_58
    del _BuildAutomaton_58
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_55._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'pathSegment')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 232, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_55._Automaton = _BuildAutomaton_58()




simpleAccessHandle._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), CTD_ANON_56, scope=simpleAccessHandle, documentation='A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 241, 5)))

simpleAccessHandle._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'pathSegments'), CTD_ANON_57, scope=simpleAccessHandle, documentation='An ordered list of pathSegment elements. When concatenated with a desired separator the elements in this form a HDL path for the parent slice into the referenced view.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 253, 3)))

def _BuildAutomaton_59 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_59
    del _BuildAutomaton_59
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 241, 5))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(simpleAccessHandle._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'viewRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 241, 5))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(simpleAccessHandle._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'pathSegments')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 253, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
simpleAccessHandle._Automaton = _BuildAutomaton_59()




CTD_ANON_57._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'pathSegment'), pathSegmentType, scope=CTD_ANON_57, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 259, 6)))

def _BuildAutomaton_60 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_60
    del _BuildAutomaton_60
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_57._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'pathSegment')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 259, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_57._Automaton = _BuildAutomaton_60()




slicesType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'slice'), sliceType, scope=slicesType, documentation='The HDL path for a slice of the IP-XACT object.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 271, 3)))

def _BuildAutomaton_61 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_61
    del _BuildAutomaton_61
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(slicesType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'slice')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 271, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
slicesType._Automaton = _BuildAutomaton_61()




sliceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'pathSegments'), CTD_ANON_58, scope=sliceType, documentation='An ordered list of pathSegment elements. When concatenated with a desired separator the elements in this form a HDL path for the parent slice into the referenced view.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 283, 3)))

sliceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'range'), CTD_ANON_61, scope=sliceType, documentation='Left and right bound of a reference into a vector.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 549, 1)))

def _BuildAutomaton_62 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_62
    del _BuildAutomaton_62
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 293, 3))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(sliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'pathSegments')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 283, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(sliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'range')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 293, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
sliceType._Automaton = _BuildAutomaton_62()




CTD_ANON_58._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'pathSegment'), pathSegmentType, scope=CTD_ANON_58, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 289, 6)))

def _BuildAutomaton_63 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_63
    del _BuildAutomaton_63
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_58._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'pathSegment')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 289, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_58._Automaton = _BuildAutomaton_63()




pathSegmentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'pathSegmentName'), pyxb.binding.datatypes.string, scope=pathSegmentType, documentation='One section of a HDL path', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 306, 3)))

pathSegmentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'indices'), indicesType, scope=pathSegmentType, documentation='Specifies a multi-dimensional index into pathSegementName', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 311, 3)))

def _BuildAutomaton_64 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_64
    del _BuildAutomaton_64
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 311, 3))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(pathSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'pathSegmentName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 306, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(pathSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'indices')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 311, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
pathSegmentType._Automaton = _BuildAutomaton_64()




nameValuePairType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=nameValuePairType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

nameValuePairType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'value'), stringExpression, scope=nameValuePairType, documentation='The value of the parameter.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 590, 1)))

nameValuePairType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.string, scope=nameValuePairType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 600, 3)))

nameValuePairType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=nameValuePairType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

nameValuePairType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=nameValuePairType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

def _BuildAutomaton_65 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_65
    del _BuildAutomaton_65
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 605, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 606, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 524, 3))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(nameValuePairType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 600, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(nameValuePairType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 605, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(nameValuePairType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 606, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(nameValuePairType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'value')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 523, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(nameValuePairType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 524, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
nameValuePairType._Automaton = _BuildAutomaton_65()




CTD_ANON_59._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'right'), unsignedIntExpression, scope=CTD_ANON_59, documentation='The optional element right specifies the right boundary.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 319, 1)))

CTD_ANON_59._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'left'), unsignedIntExpression, scope=CTD_ANON_59, documentation='The optional element left specifies the left boundary.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 324, 1)))

def _BuildAutomaton_66 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_66
    del _BuildAutomaton_66
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_59._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'left')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 534, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_59._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'right')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 535, 4))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_59._Automaton = _BuildAutomaton_66()




CTD_ANON_60._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vector'), CTD_ANON_59, scope=CTD_ANON_60, documentation='Left and right ranges of the vector.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 528, 1)))

def _BuildAutomaton_67 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_67
    del _BuildAutomaton_67
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_60._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vector')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 545, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_60._Automaton = _BuildAutomaton_67()




CTD_ANON_61._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'right'), unsignedIntExpression, scope=CTD_ANON_61, documentation='The optional element right specifies the right boundary.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 319, 1)))

CTD_ANON_61._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'left'), unsignedIntExpression, scope=CTD_ANON_61, documentation='The optional element left specifies the left boundary.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 324, 1)))

def _BuildAutomaton_68 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_68
    del _BuildAutomaton_68
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_61._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'left')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 555, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_61._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'right')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 556, 4))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_61._Automaton = _BuildAutomaton_68()




CTD_ANON_62._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'range'), CTD_ANON_61, scope=CTD_ANON_62, documentation='Left and right bound of a reference into a vector.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 549, 1)))

CTD_ANON_62._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'indices'), indicesType, scope=CTD_ANON_62, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 568, 5)))

def _BuildAutomaton_69 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_69
    del _BuildAutomaton_69
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 569, 5))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_62._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'range')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 566, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_62._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'indices')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 568, 5))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_62._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'range')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 569, 5))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_62._Automaton = _BuildAutomaton_69()




configurableArrays._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'array'), CTD_ANON_63, scope=configurableArrays, documentation='Specific left and right array bounds.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 576, 3)))

def _BuildAutomaton_70 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_70
    del _BuildAutomaton_70
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(configurableArrays._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'array')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 576, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
configurableArrays._Automaton = _BuildAutomaton_70()




CTD_ANON_63._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'right'), unsignedIntExpression, scope=CTD_ANON_63, documentation='The optional element right specifies the right boundary.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 319, 1)))

CTD_ANON_63._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'left'), unsignedIntExpression, scope=CTD_ANON_63, documentation='The optional element left specifies the left boundary.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 324, 1)))

def _BuildAutomaton_71 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_71
    del _BuildAutomaton_71
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_63._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'left')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 582, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_63._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'right')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 583, 6))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_63._Automaton = _BuildAutomaton_71()




indicesType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'index'), unsignedIntExpression, scope=indicesType, documentation='An index into an object in the referenced view.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 631, 3)))

def _BuildAutomaton_72 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_72
    del _BuildAutomaton_72
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(indicesType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'index')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 631, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
indicesType._Automaton = _BuildAutomaton_72()




componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'choices'), CTD_ANON_14, scope=componentType, documentation='Choices used by elements with an attribute ipxact:choiceRef.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 95, 1)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busInterfaces'), CTD_ANON_20, scope=componentType, documentation='A list of bus interfaces supported by this component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 115, 1)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'channels'), CTD_ANON_21, scope=componentType, documentation='Lists all channel connections between mirror interfaces of this component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 171, 1)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'remapStates'), CTD_ANON_24, scope=componentType, documentation='Contains a list of remap state names and associated port values', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 208, 1)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'indirectInterfaces'), CTD_ANON_38, scope=componentType, documentation='A list of bus interfaces supported by this component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 498, 1)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'assertions'), CTD_ANON_47, scope=componentType, documentation='List of assertions about allowed parameter values.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=componentType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=componentType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=componentType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'whiteboxElements'), CTD_ANON_64, scope=componentType, documentation='A list of whiteboxElements', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 78, 3)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'cpus'), CTD_ANON_65, scope=componentType, documentation="cpu's in the component", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 92, 3)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'otherClockDrivers'), otherClocks, scope=componentType, documentation='Defines a set of clock drivers that are not directly associated with an input port of the component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 128, 3)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'resetTypes'), CTD_ANON_67, scope=componentType, documentation='A list of user defined resetTypes applicable to this component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 133, 3)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileSets'), CTD_ANON_95, scope=componentType, documentation='List of file sets associated with component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 337, 4)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'componentGenerators'), CTD_ANON_105, scope=componentType, documentation='List of component generators.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 209, 1)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendor'), pyxb.binding.datatypes.Name, scope=componentType, documentation='Name of the vendor who supplies this file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'library'), pyxb.binding.datatypes.Name, scope=componentType, documentation='Name of the logical library this element belongs to.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.NMTOKEN, scope=componentType, documentation='The name of the object.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'version'), pyxb.binding.datatypes.NMTOKEN, scope=componentType, documentation='Indicates the version of the named element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressSpaces'), CTD_ANON_116, scope=componentType, documentation='If this component is a bus master, this lists all the address spaces\ndefined by the component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 446, 1)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'memoryMaps'), CTD_ANON_120, scope=componentType, documentation='Lists all the slave memory maps defined by the component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 527, 1)))

componentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'model'), modelType, scope=componentType, documentation='Model information.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 327, 1)))

def _BuildAutomaton_73 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_73
    del _BuildAutomaton_73
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 64, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 65, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 66, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 67, 6))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 68, 4))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 69, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 70, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 71, 3))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 76, 3))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 77, 3))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 78, 3))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 92, 3))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 128, 3))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 133, 3))
    counters.add(cc_13)
    cc_14 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 154, 3))
    counters.add(cc_14)
    cc_15 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 155, 3))
    counters.add(cc_15)
    cc_16 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 156, 3))
    counters.add(cc_16)
    cc_17 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 157, 3))
    counters.add(cc_17)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendor')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'library')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'version')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'busInterfaces')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 64, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'indirectInterfaces')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 65, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'channels')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 66, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'remapStates')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 67, 6))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressSpaces')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 68, 4))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'memoryMaps')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 69, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'model')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 70, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'componentGenerators')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 71, 3))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'choices')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 76, 3))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'fileSets')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 77, 3))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'whiteboxElements')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 78, 3))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'cpus')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 92, 3))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_12, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'otherClockDrivers')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 128, 3))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_13, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'resetTypes')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 133, 3))
    st_17 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_14, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 154, 3))
    st_18 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_18)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_15, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 155, 3))
    st_19 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_19)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_16, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'assertions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 156, 3))
    st_20 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_20)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_17, False))
    symbol = pyxb.binding.content.ElementUse(componentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 157, 3))
    st_21 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_21)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    transitions.append(fac.Transition(st_19, [
         ]))
    transitions.append(fac.Transition(st_20, [
         ]))
    transitions.append(fac.Transition(st_21, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_13, True) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_13, False) ]))
    st_17._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_14, True) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_14, False) ]))
    st_18._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_15, True) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_15, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_15, False) ]))
    st_19._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_16, True) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_16, False) ]))
    st_20._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_17, True) ]))
    st_21._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
componentType._Automaton = _BuildAutomaton_73()




CTD_ANON_64._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'whiteboxElement'), whiteboxElementType, scope=CTD_ANON_64, documentation='A whiteboxElement is a useful way to identify elements of a component that can not be identified through other means such as internal signals and non-software accessible registers.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 84, 6)))

def _BuildAutomaton_74 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_74
    del _BuildAutomaton_74
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_64._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'whiteboxElement')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 84, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_64._Automaton = _BuildAutomaton_74()




CTD_ANON_65._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'cpu'), CTD_ANON_66, scope=CTD_ANON_65, documentation='Describes a processor in this component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 98, 6)))

def _BuildAutomaton_75 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_75
    del _BuildAutomaton_75
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_65._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'cpu')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 98, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_65._Automaton = _BuildAutomaton_75()




CTD_ANON_66._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=CTD_ANON_66, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

CTD_ANON_66._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_66, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_66._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_66, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

CTD_ANON_66._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_66, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_66._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_66, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_66._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_66, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_66._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressSpaceRef'), addrSpaceRefType, scope=CTD_ANON_66, documentation='References the address space.  The name of the address space is kept in its addressSpaceRef attribute.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 441, 1)))

def _BuildAutomaton_76 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_76
    del _BuildAutomaton_76
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 109, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 115, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 120, 9))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_66._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_66._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_66._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_66._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 109, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_66._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressSpaceRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 110, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_66._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 115, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_66._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 120, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_66._Automaton = _BuildAutomaton_76()




CTD_ANON_67._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'resetType'), CTD_ANON_68, scope=CTD_ANON_67, documentation='A user defined reset policy', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 139, 6)))

def _BuildAutomaton_77 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_77
    del _BuildAutomaton_77
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_67._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'resetType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 139, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_67._Automaton = _BuildAutomaton_77()




CTD_ANON_68._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_68, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_68._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_68, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

CTD_ANON_68._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_68, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_68._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_68, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

def _BuildAutomaton_78 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_78
    del _BuildAutomaton_78
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 146, 9))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_68._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_68._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_68._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_68._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 146, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_68._Automaton = _BuildAutomaton_78()




whiteboxElementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=whiteboxElementType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

whiteboxElementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=whiteboxElementType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

whiteboxElementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=whiteboxElementType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

whiteboxElementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=whiteboxElementType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

whiteboxElementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=whiteboxElementType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

whiteboxElementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=whiteboxElementType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

whiteboxElementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'whiteboxType'), simpleWhiteboxType, scope=whiteboxElementType, documentation='Indicates the type of the element. The pin and signal types refer to elements within the HDL description. The register type refers to a register in the memory map. The interface type refers to a group of signals addressed as a single unit.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 324, 3)))

whiteboxElementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'driveable'), pyxb.binding.datatypes.boolean, scope=whiteboxElementType, documentation='If true, indicates that the white box element can be driven (e.g. have a new value forced into it).', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 329, 3), unicode_default='false'))

def _BuildAutomaton_79 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_79
    del _BuildAutomaton_79
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 323, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 329, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 334, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 335, 3))
    counters.add(cc_5)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(whiteboxElementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(whiteboxElementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(whiteboxElementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(whiteboxElementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 323, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(whiteboxElementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'whiteboxType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 324, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(whiteboxElementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'driveable')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 329, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(whiteboxElementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 334, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(whiteboxElementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/component.xsd', 335, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
whiteboxElementType._Automaton = _BuildAutomaton_79()




otherClocks._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'otherClockDriver'), CTD_ANON_198, scope=otherClocks, documentation='Describes a clock not directly associated with an input port. The clockSource attribute can be used on these clocks to indicate the actual clock source (e.g. an output port of a clock generator cell).', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 215, 1)))

def _BuildAutomaton_80 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_80
    del _BuildAutomaton_80
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(otherClocks._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'otherClockDriver')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 134, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
otherClocks._Automaton = _BuildAutomaton_80()




CTD_ANON_69._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'cellSpecification'), CTD_ANON_178, scope=CTD_ANON_69, documentation='Used to provide a generic description of a technology library cell.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 138, 4)))

def _BuildAutomaton_81 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_81
    del _BuildAutomaton_81
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_69._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'cellSpecification')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 202, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_69._Automaton = _BuildAutomaton_81()




CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'cellSpecification'), CTD_ANON_178, scope=CTD_ANON_70, documentation='Used to provide a generic description of a technology library cell.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 138, 4)))

CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'count'), unsignedPositiveIntExpression, scope=CTD_ANON_70, documentation='Indicates how many loads of the specified cell are connected. If not present, 3 is assumed.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 213, 16), unicode_default='3'))

def _BuildAutomaton_82 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_82
    del _BuildAutomaton_82
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 213, 16))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'cellSpecification')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 212, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'count')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 213, 16))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_70._Automaton = _BuildAutomaton_82()




CTD_ANON_71._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_71, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 334, 3)))

CTD_ANON_71._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_71, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_71._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_71, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_71._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'timingConstraint'), CTD_ANON_180, scope=CTD_ANON_71, documentation='Defines a timing constraint for the associated port. The constraint is relative to the clock specified by the clockName attribute. The clockEdge indicates which clock edge the constraint is associated with (default is rising edge). The delayType attribute can be specified to further refine the constraint.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 169, 4)))

CTD_ANON_71._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'driveConstraint'), CTD_ANON_69, scope=CTD_ANON_71, documentation='Defines a constraint indicating how an input is to be driven. The preferred methodology is to specify a library cell in technology independent fashion. The implemention tool should assume that the associated port is driven by the specified cell, or that the drive strength of the input port is indicated by the specified resistance value.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 196, 4)))

CTD_ANON_71._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'loadConstraint'), CTD_ANON_70, scope=CTD_ANON_71, documentation='Defines a constraint indicating the type of load on an output port.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 206, 4)))

CTD_ANON_71._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vector'), CTD_ANON_72, scope=CTD_ANON_71, documentation='The optional element vector specify the bits of a vector for which the constraints apply. The vaules of left and right must be within the range of the port. If the vector is not specified then the constraints apply to all the bits of the port.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 228, 16)))

def _BuildAutomaton_83 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_83
    del _BuildAutomaton_83
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 334, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 339, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 340, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 228, 16))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 247, 16))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 248, 16))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 249, 16))
    counters.add(cc_6)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_71._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 334, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_71._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 339, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_71._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 340, 3))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_71._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vector')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 228, 16))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_71._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'driveConstraint')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 247, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_71._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'loadConstraint')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 248, 16))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_71._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'timingConstraint')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 249, 16))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_71._Automaton = _BuildAutomaton_83()




CTD_ANON_72._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'left'), unsignedIntExpression, scope=CTD_ANON_72, documentation='The optional elements left and right can be used to select a bit-slice of a vector. ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 234, 28)))

CTD_ANON_72._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'right'), unsignedIntExpression, scope=CTD_ANON_72, documentation='The optional elements left and right can be used to select a bit-slice of a vector. ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 239, 28)))

def _BuildAutomaton_84 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_84
    del _BuildAutomaton_84
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_72._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'left')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 234, 28))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_72._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'right')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 239, 28))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_72._Automaton = _BuildAutomaton_84()




CTD_ANON_73._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'constraintSet'), CTD_ANON_71, scope=CTD_ANON_73, documentation='Defines constraints that apply to a component port. If multiple constraintSet elements are used, each must have a unique value for the constraintSetId attribute.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 221, 4)))

def _BuildAutomaton_85 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_85
    del _BuildAutomaton_85
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_73._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'constraintSet')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 265, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_73._Automaton = _BuildAutomaton_85()




CTD_ANON_74._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_74, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_74._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'localName'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_74, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 275, 12)))

def _BuildAutomaton_86 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_86
    del _BuildAutomaton_86
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 276, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_74._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'localName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 275, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_74._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 276, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_74._Automaton = _BuildAutomaton_86()




abstractionDefPortConstraintsType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'timingConstraint'), CTD_ANON_180, scope=abstractionDefPortConstraintsType, documentation='Defines a timing constraint for the associated port. The constraint is relative to the clock specified by the clockName attribute. The clockEdge indicates which clock edge the constraint is associated with (default is rising edge). The delayType attribute can be specified to further refine the constraint.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 169, 4)))

abstractionDefPortConstraintsType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'driveConstraint'), CTD_ANON_69, scope=abstractionDefPortConstraintsType, documentation='Defines a constraint indicating how an input is to be driven. The preferred methodology is to specify a library cell in technology independent fashion. The implemention tool should assume that the associated port is driven by the specified cell, or that the drive strength of the input port is indicated by the specified resistance value.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 196, 4)))

abstractionDefPortConstraintsType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'loadConstraint'), CTD_ANON_70, scope=abstractionDefPortConstraintsType, documentation='Defines a constraint indicating the type of load on an output port.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 206, 4)))

def _BuildAutomaton_87 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_87
    del _BuildAutomaton_87
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 288, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 289, 16))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 293, 16))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(abstractionDefPortConstraintsType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'timingConstraint')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 287, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(abstractionDefPortConstraintsType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'driveConstraint')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 288, 16))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(abstractionDefPortConstraintsType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'loadConstraint')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 289, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(abstractionDefPortConstraintsType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'driveConstraint')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 292, 16))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(abstractionDefPortConstraintsType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'loadConstraint')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 293, 16))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(abstractionDefPortConstraintsType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'loadConstraint')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 296, 16))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
abstractionDefPortConstraintsType._Automaton = _BuildAutomaton_87()




CTD_ANON_75._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'assertions'), CTD_ANON_47, scope=CTD_ANON_75, documentation='List of assertions about allowed parameter values.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1)))

CTD_ANON_75._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=CTD_ANON_75, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

CTD_ANON_75._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_75, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_75._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_75, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_75._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendor'), pyxb.binding.datatypes.Name, scope=CTD_ANON_75, documentation='Name of the vendor who supplies this file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3)))

CTD_ANON_75._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'library'), pyxb.binding.datatypes.Name, scope=CTD_ANON_75, documentation='Name of the logical library this element belongs to.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3)))

CTD_ANON_75._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_75, documentation='The name of the object.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3)))

CTD_ANON_75._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'version'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_75, documentation='Indicates the version of the named element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3)))

CTD_ANON_75._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'componentInstances'), CTD_ANON_166, scope=CTD_ANON_75, documentation='Sub instances of internal components.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 148, 1)))

CTD_ANON_75._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'adHocConnections'), CTD_ANON_169, scope=CTD_ANON_75, documentation='Defines the set of ad-hoc connections in a design. An ad-hoc connection represents a connection between two component pins which were not connected as a result of interface connections (i.e.the pin to pin connection was made explicitly and is represented explicitly).', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 211, 1)))

CTD_ANON_75._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'interconnections'), CTD_ANON_172, scope=CTD_ANON_75, documentation='Connections between internal sub components.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 298, 1)))

def _BuildAutomaton_88 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_88
    del _BuildAutomaton_88
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 62, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 63, 4))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 64, 4))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 65, 4))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 66, 4))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 67, 4))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 68, 4))
    counters.add(cc_6)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_75._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendor')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_75._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'library')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_75._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_75._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'version')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_75._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'componentInstances')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 62, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_75._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'interconnections')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 63, 4))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_75._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'adHocConnections')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 64, 4))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_75._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 65, 4))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_75._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 66, 4))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_75._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'assertions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 67, 4))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_75._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/design.xsd', 68, 4))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_10._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_75._Automaton = _BuildAutomaton_88()




CTD_ANON_76._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'assertions'), CTD_ANON_47, scope=CTD_ANON_76, documentation='List of assertions about allowed parameter values.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1)))

CTD_ANON_76._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=CTD_ANON_76, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

CTD_ANON_76._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_76, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_76._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_76, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_76._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'designRef'), libraryRefType, scope=CTD_ANON_76, documentation='The design to which this configuration applies', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 62, 4)))

CTD_ANON_76._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'generatorChainConfiguration'), configurableLibraryRefType, scope=CTD_ANON_76, documentation='Contains the configurable information associated with a generatorChain and its generators. Note that configurable information for generators associated with components is stored in the design file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 67, 4)))

CTD_ANON_76._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'interconnectionConfiguration'), CTD_ANON_77, scope=CTD_ANON_76, documentation='Contains the information about the abstractors required to cross between two interfaces at with different abstractionDefs.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 72, 4)))

CTD_ANON_76._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'viewConfiguration'), CTD_ANON_81, scope=CTD_ANON_76, documentation='Contains the active views for each instance in the design', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 145, 4)))

CTD_ANON_76._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendor'), pyxb.binding.datatypes.Name, scope=CTD_ANON_76, documentation='Name of the vendor who supplies this file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3)))

CTD_ANON_76._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'library'), pyxb.binding.datatypes.Name, scope=CTD_ANON_76, documentation='Name of the logical library this element belongs to.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3)))

CTD_ANON_76._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_76, documentation='The name of the object.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3)))

CTD_ANON_76._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'version'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_76, documentation='Indicates the version of the named element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3)))

def _BuildAutomaton_89 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_89
    del _BuildAutomaton_89
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 62, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 67, 4))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 72, 4))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 145, 4))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 172, 4))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 173, 4))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 174, 4))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 175, 4))
    counters.add(cc_7)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_76._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendor')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_76._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'library')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_76._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_76._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'version')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_76._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'designRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 62, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_76._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'generatorChainConfiguration')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 67, 4))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_76._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'interconnectionConfiguration')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 72, 4))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_76._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'viewConfiguration')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 145, 4))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_76._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 172, 4))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_76._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 173, 4))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_76._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'assertions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 174, 4))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_76._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 175, 4))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, True) ]))
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_76._Automaton = _BuildAutomaton_89()




CTD_ANON_77._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_77, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_77._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'interconnectionRef'), pyxb.binding.datatypes.Name, scope=CTD_ANON_77, documentation='Reference to the interconnection name, monitor interconnection name or possibly a hierConnection interfaceName in a design file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 79, 7)))

CTD_ANON_77._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractorInstances'), CTD_ANON_78, scope=CTD_ANON_77, documentation="List of abstractor-instances for this interconnection. Multiple abstractor-instances elements may be present for a 1-to-many (broadcast) interconnection. In that case, the optional interfaceRef elements must reference non-overlapping interfaces from the 'many' side of the interconnection.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 84, 7)))

def _BuildAutomaton_90 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_90
    del _BuildAutomaton_90
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 78, 14))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_77._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 78, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_77._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'interconnectionRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 79, 7))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_77._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'abstractorInstances')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 84, 7))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_77._Automaton = _BuildAutomaton_90()




CTD_ANON_78._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_78, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_78._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'interfaceRef'), CTD_ANON_79, scope=CTD_ANON_78, documentation='Defines the broadcast endpoint to which this chain of abstractors applies.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 91, 10)))

CTD_ANON_78._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractorInstance'), CTD_ANON_80, scope=CTD_ANON_78, documentation='Element to hold a the abstractor reference, the configuration and viewName. If multiple elements are present then the order is the order in which the abstractors should be chained together.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 111, 10)))

def _BuildAutomaton_91 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_91
    del _BuildAutomaton_91
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 90, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 91, 10))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_78._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 90, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_78._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'interfaceRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 91, 10))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_78._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'abstractorInstance')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 111, 10))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_78._Automaton = _BuildAutomaton_91()




CTD_ANON_79._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_79, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

def _BuildAutomaton_92 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_92
    del _BuildAutomaton_92
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 96, 13))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 97, 26))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_79._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 97, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_79._Automaton = _BuildAutomaton_92()




CTD_ANON_80._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_80, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_80._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_80, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_80._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'instanceName'), pyxb.binding.datatypes.Name, scope=CTD_ANON_80, documentation='Instance name for the abstractor', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 117, 13)))

CTD_ANON_80._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractorRef'), configurableLibraryRefType, scope=CTD_ANON_80, documentation='Abstractor reference', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 124, 13)))

CTD_ANON_80._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'viewName'), pyxb.binding.datatypes.Name, scope=CTD_ANON_80, documentation='The name of the active view for this abstractor instance.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 129, 13)))

def _BuildAutomaton_93 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_93
    del _BuildAutomaton_93
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 122, 13))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 123, 13))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_80._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'instanceName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 117, 13))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_80._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 122, 13))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_80._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 123, 13))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_80._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'abstractorRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 124, 13))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_80._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'viewName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 129, 13))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_80._Automaton = _BuildAutomaton_93()




CTD_ANON_81._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_81, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_81._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'view'), CTD_ANON_82, scope=CTD_ANON_81, documentation='The selected view for the instance.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 153, 7)))

CTD_ANON_81._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'instanceName'), pyxb.binding.datatypes.Name, scope=CTD_ANON_81, documentation='An instance name assigned to subcomponent instances and contained channels, that is unique within the parent component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 123, 1)))

def _BuildAutomaton_94 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_94
    del _BuildAutomaton_94
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 152, 7))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_81._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'instanceName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 151, 7))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_81._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 152, 7))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_81._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'view')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 153, 7))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_81._Automaton = _BuildAutomaton_94()




CTD_ANON_82._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'configurableElementValues'), CTD_ANON_164, scope=CTD_ANON_82, documentation='All configuration information for a contained component, generator, generator chain or abstractor instance.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 92, 1)))

def _BuildAutomaton_95 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_95
    del _BuildAutomaton_95
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 159, 10))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_82._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'configurableElementValues')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/designConfig.xsd', 159, 10))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_82._Automaton = _BuildAutomaton_95()




CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_83, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_83, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), stringURIExpression, scope=CTD_ANON_83, documentation='Path to the file or directory. If this path is a relative path, then it is relative to the containing XML file. ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 59, 16)))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isStructural'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_83, documentation='Indicates that the current file is purely structural.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 66, 15), unicode_default='false'))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isIncludeFile'), CTD_ANON_84, scope=CTD_ANON_83, documentation='Indicate that the file is include file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 71, 16)))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'logicalName'), CTD_ANON_85, scope=CTD_ANON_83, documentation='Logical name for this file or directory e.g. VHDL library name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 87, 16)))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'exportedName'), CTD_ANON_86, scope=CTD_ANON_83, documentation='Defines exported names that can be accessed externally, e.g. exported function names from a C source file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 103, 16)))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'buildCommand'), CTD_ANON_87, scope=CTD_ANON_83, documentation='Command and flags used to build derived files from the sourceName files. If this element is present, the command and/or flags used to to build the file will override or augment any default builders at a higher level.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 115, 16)))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'define'), nameValuePairType, scope=CTD_ANON_83, documentation='Specifies define symbols that are used in the source file.  The ipxact:name element gives the name to be defined and the text content of the ipxact:value element holds the value.  This element supports full configurability.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 156, 16)))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'imageType'), CTD_ANON_88, scope=CTD_ANON_83, documentation='Relates the current file to a certain executable image type in the design.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 161, 16)))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_83, documentation='String for describing this file to users', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 173, 16)))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'dependency'), CTD_ANON_181, scope=CTD_ANON_83, documentation='Specifies a location on which  files or fileSets may be dependent. Typically, this would be a directory that would contain included files.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 325, 4)))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileType'), CTD_ANON_183, scope=CTD_ANON_83, documentation='Enumerated file types known by IP-XACT.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/fileType.xsd', 95, 1)))

def _BuildAutomaton_96 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_96
    del _BuildAutomaton_96
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 64, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 66, 15))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 71, 16))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 87, 16))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 103, 16))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 115, 16))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 155, 16))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 156, 16))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 161, 16))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 173, 16))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 178, 16))
    counters.add(cc_10)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 59, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 64, 14))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'fileType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 65, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isStructural')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 66, 15))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isIncludeFile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 71, 16))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'logicalName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 87, 16))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'exportedName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 103, 16))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'buildCommand')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 115, 16))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'dependency')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 155, 16))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'define')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 156, 16))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'imageType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 161, 16))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 173, 16))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 178, 16))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_10, True) ]))
    st_12._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_83._Automaton = _BuildAutomaton_96()




CTD_ANON_87._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'command'), stringExpression, scope=CTD_ANON_87, documentation='Command used to build this file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 121, 28)))

CTD_ANON_87._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'flags'), CTD_ANON_207, scope=CTD_ANON_87, documentation='Flags given to the build command when building this file. If the optional attribute "append" is "true", this string will be appended to any existing flags, otherwise these flags will replace any existing default flags.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 126, 28)))

CTD_ANON_87._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'replaceDefaultFlags'), unsignedBitExpression, scope=CTD_ANON_87, documentation='If true, the value of the sibling element "flags" should replace any default flags specified at a more global level. If this is true and the sibling element "flags" is empty or missing, this has the effect of clearing any default flags.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 142, 28)))

CTD_ANON_87._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'targetName'), stringURIExpression, scope=CTD_ANON_87, documentation='Pathname to the file that is derived (built) from the source file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 147, 28)))

def _BuildAutomaton_97 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_97
    del _BuildAutomaton_97
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 121, 28))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 126, 28))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 142, 28))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 147, 28))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_87._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'command')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 121, 28))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_87._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'flags')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 126, 28))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_87._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'replaceDefaultFlags')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 142, 28))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_87._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'targetName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 147, 28))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_87._Automaton = _BuildAutomaton_97()




CTD_ANON_89._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=CTD_ANON_89, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

CTD_ANON_89._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_89, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_89._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_89, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

CTD_ANON_89._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_89, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_89._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_89, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_89._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'languageTools'), CTD_ANON_90, scope=CTD_ANON_89, documentation='Default commands and flags for software language tools needed to build the executable image.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 206, 16)))

CTD_ANON_89._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileSetRefGroup'), CTD_ANON_92, scope=CTD_ANON_89, documentation='Contains a group of file set references that indicates the set of file sets complying with the tool set of the current executable image.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 257, 16)))

def _BuildAutomaton_98 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_98
    del _BuildAutomaton_98
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 201, 13))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 206, 16))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 257, 16))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 267, 16))
    counters.add(cc_5)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_89._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_89._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_89._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_89._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 201, 13))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_89._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'languageTools')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 206, 16))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_89._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'fileSetRefGroup')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 257, 16))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_89._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 267, 16))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_89._Automaton = _BuildAutomaton_98()




CTD_ANON_90._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileBuilder'), CTD_ANON_91, scope=CTD_ANON_90, documentation='A generic placeholder for any file builder like compilers and assemblers.  It contains the file types to which the command should be applied, and the flags to be used with that command.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 212, 28)))

CTD_ANON_90._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'linker'), stringExpression, scope=CTD_ANON_90, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 245, 30)))

CTD_ANON_90._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'linkerFlags'), stringExpression, scope=CTD_ANON_90, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 248, 34)))

CTD_ANON_90._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'linkerCommandFile'), CTD_ANON_93, scope=CTD_ANON_90, documentation='Specifies a linker command file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 282, 4)))

def _BuildAutomaton_99 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_99
    del _BuildAutomaton_99
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 212, 28))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 241, 28))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 249, 34))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_90._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'fileBuilder')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 212, 28))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_90._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'linker')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 245, 30))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_90._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'linkerFlags')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 248, 34))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_90._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'linkerCommandFile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 249, 34))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_90._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'linkerCommandFile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 251, 32))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True),
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_90._Automaton = _BuildAutomaton_99()




CTD_ANON_91._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_91, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_91._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'command'), stringExpression, scope=CTD_ANON_91, documentation='Default command used to build files of the specified fileType. ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 219, 40)))

CTD_ANON_91._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'flags'), stringExpression, scope=CTD_ANON_91, documentation='Flags given to the build command when building files of this type.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 224, 40)))

CTD_ANON_91._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'replaceDefaultFlags'), unsignedBitExpression, scope=CTD_ANON_91, documentation='If true, replace any default flags value with the value in the sibling flags element. Otherwise, append the contents of the sibling flags element to any default flags value.\n\nIf the value is true and the "flags" element is empty or missing, this will have the result of clearing any default flags value.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 229, 40)))

CTD_ANON_91._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileType'), CTD_ANON_183, scope=CTD_ANON_91, documentation='Enumerated file types known by IP-XACT.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/fileType.xsd', 95, 1)))

def _BuildAutomaton_100 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_100
    del _BuildAutomaton_100
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 224, 40))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 229, 40))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 236, 40))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_91._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'fileType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 218, 40))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_91._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'command')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 219, 40))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_91._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'flags')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 224, 40))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_91._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'replaceDefaultFlags')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 229, 40))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_91._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 236, 40))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_91._Automaton = _BuildAutomaton_100()




CTD_ANON_92._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileSetRef'), CTD_ANON_94, scope=CTD_ANON_92, documentation='A reference to a fileSet.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 309, 4)))

def _BuildAutomaton_101 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_101
    del _BuildAutomaton_101
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_92._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'fileSetRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 263, 28))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_92._Automaton = _BuildAutomaton_101()




CTD_ANON_93._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_93, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_93._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), stringURIExpression, scope=CTD_ANON_93, documentation='Linker command file name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 288, 16)))

CTD_ANON_93._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'commandLineSwitch'), stringExpression, scope=CTD_ANON_93, documentation='The command line switch to specify the linker command file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 293, 16)))

CTD_ANON_93._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'enable'), unsignedBitExpression, scope=CTD_ANON_93, documentation='Specifies whether to generate and enable the linker command file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 298, 16)))

CTD_ANON_93._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'generatorRef'), CTD_ANON_99, scope=CTD_ANON_93, documentation='A reference to a generator element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 491, 4)))

def _BuildAutomaton_102 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_102
    del _BuildAutomaton_102
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 303, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 304, 16))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_93._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 288, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_93._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'commandLineSwitch')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 293, 16))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_93._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'enable')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 298, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_93._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'generatorRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 303, 16))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_93._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 304, 16))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_93._Automaton = _BuildAutomaton_102()




CTD_ANON_94._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_94, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_94._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'localName'), pyxb.binding.datatypes.Name, scope=CTD_ANON_94, documentation='Refers to a fileSet defined within this description.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 315, 16)))

def _BuildAutomaton_103 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_103
    del _BuildAutomaton_103
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 320, 2))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_94._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'localName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 315, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_94._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 320, 2))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_94._Automaton = _BuildAutomaton_103()




CTD_ANON_95._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileSet'), fileSetType, scope=CTD_ANON_95, documentation='This element specifies a list of unique pathnames to files and directories. It may also include build instructions for the files. If compilation order is important, e.g. for VHDL files, the files have to be provided in compilation order.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 189, 4)))

def _BuildAutomaton_104 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_104
    del _BuildAutomaton_104
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_95._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'fileSet')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 343, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_95._Automaton = _BuildAutomaton_104()




fileBuilderType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'command'), stringExpression, scope=fileBuilderType, documentation='Default command used to build files of the specified fileType. ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 350, 12)))

fileBuilderType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'flags'), stringExpression, scope=fileBuilderType, documentation='Flags given to the build command when building files of this type.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 355, 12)))

fileBuilderType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'replaceDefaultFlags'), unsignedBitExpression, scope=fileBuilderType, documentation='If true, replace any default flags value with the value in the sibling flags element. Otherwise, append the contents of the sibling flags element to any default flags value.\n\nIf the value is true and the "flags" element is empty or missing, this will have the result of clearing any default flags value.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 360, 12)))

fileBuilderType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileType'), CTD_ANON_183, scope=fileBuilderType, documentation='Enumerated file types known by IP-XACT.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/fileType.xsd', 95, 1)))

def _BuildAutomaton_105 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_105
    del _BuildAutomaton_105
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 350, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 355, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 360, 12))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(fileBuilderType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'fileType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 349, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(fileBuilderType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'command')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 350, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(fileBuilderType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'flags')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 355, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(fileBuilderType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'replaceDefaultFlags')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 360, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
fileBuilderType._Automaton = _BuildAutomaton_105()




fileSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=fileSetType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

fileSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=fileSetType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

fileSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=fileSetType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

fileSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=fileSetType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

fileSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'file'), CTD_ANON_83, scope=fileSetType, documentation='IP-XACT reference to a file or directory.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 53, 4)))

fileSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'dependency'), CTD_ANON_181, scope=fileSetType, documentation='Specifies a location on which  files or fileSets may be dependent. Typically, this would be a directory that would contain included files.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 325, 4)))

fileSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'group'), CTD_ANON_96, scope=fileSetType, documentation='Identifies this filleSet as belonging to a particular group or having a particular purpose. Examples might be "diagnostics", "boot", "application", "interrupt", "deviceDriver", etc.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 381, 12)))

fileSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'defaultFileBuilder'), fileBuilderType, scope=fileSetType, documentation='Default command and flags used to build derived files from the sourceName files in this file set.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 394, 12)))

fileSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'function'), CTD_ANON_97, scope=fileSetType, documentation='Generator information if this file set describes a function. For example, this file set may describe diagnostics for which the DE can generate a diagnostics driver.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 400, 12)))

def _BuildAutomaton_106 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_106
    del _BuildAutomaton_106
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 381, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 393, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 394, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 399, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 400, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 470, 12))
    counters.add(cc_7)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(fileSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(fileSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(fileSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(fileSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'group')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 381, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(fileSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'file')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 393, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(fileSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'defaultFileBuilder')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 394, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(fileSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'dependency')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 399, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(fileSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'function')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 400, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(fileSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 470, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, True) ]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
fileSetType._Automaton = _BuildAutomaton_106()




CTD_ANON_97._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'entryPoint'), pyxb.binding.datatypes.Name, scope=CTD_ANON_97, documentation='Optional name for the function.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 406, 24)))

CTD_ANON_97._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileRef'), pyxb.binding.datatypes.token, scope=CTD_ANON_97, documentation='A reference to the file that contains the entry point function.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 411, 24)))

CTD_ANON_97._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'returnType'), returnTypeType, scope=CTD_ANON_97, documentation='Function return type. Possible values are void and int.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 416, 24)))

CTD_ANON_97._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'argument'), CTD_ANON_182, scope=CTD_ANON_97, documentation='Arguments passed in when the function is called. Arguments are passed in order.\n\nThis is an extension of the name-value pair which includes the data type in the ipxact:dataType attribute.  The argument name is in the ipxact:name element and its value is in the ipxact:value element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 421, 24)))

CTD_ANON_97._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'disabled'), unsignedBitExpression, scope=CTD_ANON_97, documentation='Specifies if the SW function is enabled. If not present the function is always enabled.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 439, 24)))

CTD_ANON_97._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'sourceFile'), CTD_ANON_98, scope=CTD_ANON_97, documentation='Location information for the source file of this function.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 444, 24)))

def _BuildAutomaton_107 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_107
    del _BuildAutomaton_107
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 406, 24))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 416, 24))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 421, 24))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 439, 24))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 444, 24))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_97._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'entryPoint')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 406, 24))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_97._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'fileRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 411, 24))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_97._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'returnType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 416, 24))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_97._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'argument')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 421, 24))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_97._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'disabled')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 439, 24))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_97._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'sourceFile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 444, 24))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_97._Automaton = _BuildAutomaton_107()




CTD_ANON_98._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'sourceName'), ipxactURI, scope=CTD_ANON_98, documentation='Source file for the boot load.  Relative names are searched for in the project directory and the source of the component directory.\n    ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 450, 36)))

CTD_ANON_98._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileType'), CTD_ANON_183, scope=CTD_ANON_98, documentation='Enumerated file types known by IP-XACT.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/fileType.xsd', 95, 1)))

def _BuildAutomaton_108 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_108
    del _BuildAutomaton_108
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_98._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'sourceName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 450, 36))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_98._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'fileType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 456, 36))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_98._Automaton = _BuildAutomaton_108()




CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'choices'), CTD_ANON_14, scope=CTD_ANON_100, documentation='Choices used by elements with an attribute ipxact:choiceRef.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/autoConfigure.xsd', 95, 1)))

CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'assertions'), CTD_ANON_47, scope=CTD_ANON_100, documentation='List of assertions about allowed parameter values.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 98, 1)))

CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=CTD_ANON_100, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_100, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_100, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_100, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'generatorChainSelector'), CTD_ANON_101, scope=CTD_ANON_100, documentation='Select other generator chain files for inclusion into this chain. The boolean attribute "unique" (default false) specifies that only a single generator is valid in this context. If more that one generator is selected based on the selection criteria, DE will prompt the user to resolve to a single generator.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 59, 5)))

CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'componentGeneratorSelector'), generatorSelectorType, scope=CTD_ANON_100, documentation='Selects generators declared in components of the current design for inclusion into this generator chain.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 80, 5)))

CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'chainGroup'), CTD_ANON_102, scope=CTD_ANON_100, documentation='Identifies this generator chain as belonging to the named group. This is used by other generator chains to select this chain for programmatic inclusion.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 87, 4)))

CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'generator'), CTD_ANON_184, scope=CTD_ANON_100, documentation='Specifies a set of generators.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 114, 1)))

CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendor'), pyxb.binding.datatypes.Name, scope=CTD_ANON_100, documentation='Name of the vendor who supplies this file.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3)))

CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'library'), pyxb.binding.datatypes.Name, scope=CTD_ANON_100, documentation='Name of the logical library this element belongs to.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3)))

CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_100, documentation='The name of the object.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3)))

CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'version'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_100, documentation='Indicates the version of the named element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3)))

def _BuildAutomaton_109 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_109
    del _BuildAutomaton_109
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 87, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 99, 4))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 100, 4))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 101, 4))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 102, 4))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 103, 4))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 104, 4))
    counters.add(cc_6)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendor')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 64, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'library')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 69, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 74, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'version')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 79, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'generatorChainSelector')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 59, 5))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'componentGeneratorSelector')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 80, 5))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'generator')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 85, 5))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'chainGroup')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 87, 4))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 99, 4))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 100, 4))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'choices')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 101, 4))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 102, 4))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'assertions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 103, 4))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 104, 4))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_13._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_100._Automaton = _BuildAutomaton_109()




CTD_ANON_101._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'generatorChainRef'), configurableLibraryRefType, scope=CTD_ANON_101, documentation='Select another generator chain using the unique identifier of this generator chain.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 66, 8)))

CTD_ANON_101._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'groupSelector'), CTD_ANON_185, scope=CTD_ANON_101, documentation='Specifies a set of group names used to select subsequent generators. The attribute "multipleGroupOperator" specifies the OR or AND selection operator if there is more than one group name (default=OR).', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 134, 1)))

def _BuildAutomaton_110 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_110
    del _BuildAutomaton_110
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_101._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'groupSelector')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 65, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_101._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'generatorChainRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 66, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_101._Automaton = _BuildAutomaton_110()




generatorSelectorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'groupSelector'), CTD_ANON_185, scope=generatorSelectorType, documentation='Specifies a set of group names used to select subsequent generators. The attribute "multipleGroupOperator" specifies the OR or AND selection operator if there is more than one group name (default=OR).', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 134, 1)))

def _BuildAutomaton_111 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_111
    del _BuildAutomaton_111
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(generatorSelectorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'groupSelector')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 205, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
generatorSelectorType._Automaton = _BuildAutomaton_111()




CTD_ANON_105._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'componentGenerator'), instanceGeneratorType, scope=CTD_ANON_105, documentation='Specifies a set of component generators. The scope attribute applies to component generators and specifies whether the generator should be run for each instance of the entity (or module) or just once for all instances of the entity.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 124, 1)))

def _BuildAutomaton_112 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_112
    del _BuildAutomaton_112
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_105._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'componentGenerator')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 215, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_105._Automaton = _BuildAutomaton_112()




CTD_ANON_106._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'abstractorGenerator'), instanceGeneratorType, scope=CTD_ANON_106, documentation='Specifies a set of abstractor generators. The scope attribute applies to abstractor generators and specifies whether the generator should be run for each instance of the entity (or module) or just once for all instances of the entity.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 129, 1)))

def _BuildAutomaton_113 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_113
    del _BuildAutomaton_113
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_106._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'abstractorGenerator')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 225, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_106._Automaton = _BuildAutomaton_113()




generatorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=generatorType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

generatorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=generatorType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

generatorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=generatorType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

generatorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=generatorType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

generatorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=generatorType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

generatorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'phase'), realExpression, scope=generatorType, documentation='This is an non-negative floating point number that is used to sequence when a generator is run. The generators are run in order starting with zero. There may be multiple generators with the same phase number. In this case, the order should not matter with respect to other generators at the same phase. If no phase number is given the generator will be considered in the "last" phase and these generators will be run in the order in which they are encountered while processing generator elements.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 167, 1)))

generatorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'apiType'), CTD_ANON_186, scope=generatorType, documentation='Indicates the type of API used by the generator. Valid value are TGI_2009, TGI_2014_BASE, TGI_2014_EXTENDED, and none. If this element is not present, TGI_2014_BASE is assumed. The type TGI_2009 indicates a generator using the 1685-2009 version of the TGI API. This is not part of the 1685-2014 version of the standard and may not be supported by Design Environments.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 250, 3)))

generatorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'transportMethods'), CTD_ANON_107, scope=generatorType, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 262, 3)))

generatorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'generatorExe'), ipxactURI, scope=generatorType, documentation='The pathname to the executable file that implements the generator', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 281, 3)))

def _BuildAutomaton_114 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_114
    del _BuildAutomaton_114
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 248, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 249, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 250, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 262, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 286, 3))
    counters.add(cc_6)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(generatorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(generatorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(generatorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(generatorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'phase')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 248, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(generatorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 249, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(generatorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'apiType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 250, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(generatorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'transportMethods')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 262, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(generatorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'generatorExe')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 281, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(generatorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 286, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
generatorType._Automaton = _BuildAutomaton_114()




CTD_ANON_107._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'transportMethod'), CTD_ANON_187, scope=CTD_ANON_107, documentation="Defines a SOAP transport protocol other than HTTP which is supported by this generator. The only other currently supported protocol is 'file'.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 265, 6)))

def _BuildAutomaton_115 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_115
    del _BuildAutomaton_115
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_107._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'transportMethod')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 265, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_107._Automaton = _BuildAutomaton_115()




configurableLibraryRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'configurableElementValues'), CTD_ANON_164, scope=configurableLibraryRefType, documentation='All configuration information for a contained component, generator, generator chain or abstractor instance.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 92, 1)))

def _BuildAutomaton_116 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_116
    del _BuildAutomaton_116
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 110, 3))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(configurableLibraryRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'configurableElementValues')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/identifier.xsd', 110, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
configurableLibraryRefType._Automaton = _BuildAutomaton_116()




CTD_ANON_108._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), simpleAccessHandle, scope=CTD_ANON_108, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 115, 6)))

def _BuildAutomaton_117 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_117
    del _BuildAutomaton_117
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_108._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandle')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 115, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_108._Automaton = _BuildAutomaton_117()




CTD_ANON_109._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), simpleAccessHandle, scope=CTD_ANON_109, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 138, 6)))

def _BuildAutomaton_118 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_118
    del _BuildAutomaton_118
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_109._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandle')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 138, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_109._Automaton = _BuildAutomaton_118()




addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=addressBlockType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=addressBlockType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=addressBlockType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=addressBlockType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=addressBlockType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=addressBlockType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), CTD_ANON_110, scope=addressBlockType, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 158, 3)))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'volatile'), pyxb.binding.datatypes.boolean, scope=addressBlockType, documentation='Indicates whether the data is volatile.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), unicode_default='false'))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'access'), accessType, scope=addressBlockType, documentation="Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1)))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'baseAddress'), unsignedLongintExpression, scope=addressBlockType, documentation='Base of an address block, bank, subspace map or address space. Expressed as the number of addressable units from the containing memoryMap or localMemoryMap.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 558, 1)))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'range'), unsignedPositiveLongintExpression, scope=addressBlockType, documentation='The address range of an address block.  Expressed as the number of addressable units accessible to the block. The range and the width are related by the following formulas:\n\t\t\t\t\tnumber_of_bits_in_block = ipxact:addressUnitBits * ipxact:range\n\t\t\t\t\tnumber_of_rows_in_block = number_of_bits_in_block / ipxact:width\n\t\t\t\t\t', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 659, 3)))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'width'), unsignedIntExpression, scope=addressBlockType, documentation='The bit width of a row in the address block. The range and the width are related by the following formulas:\n\t\t\t\t\tnumber_of_bits_in_block = ipxact:addressUnitBits * ipxact:range\n\t\t\t\t\tnumber_of_rows_in_block = number_of_bits_in_block / ipxact:width\n\t\t\t\t\t', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 667, 3)))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'usage'), usageType, scope=addressBlockType, documentation="Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3)))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'register'), CTD_ANON_121, scope=addressBlockType, documentation='A single register', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 703, 3)))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'registerFile'), CTD_ANON_129, scope=addressBlockType, documentation='A structure of registers and register files', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 984, 1)))

addressBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier'), pyxb.binding.datatypes.Name, scope=addressBlockType, documentation='Identifier name used to indicate that multiple addressBlock elements contain the exact same information except for the elements in the addressBlockInstanceGroup.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1068, 3)))

def _BuildAutomaton_119 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_119
    del _BuildAutomaton_119
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 158, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 165, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1068, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 689, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 690, 3))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 691, 3))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1075, 3))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 168, 3))
    counters.add(cc_10)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandles')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 158, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 165, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'baseAddress')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 584, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1068, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'range')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 659, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'width')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 667, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'usage')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'volatile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 689, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'access')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 690, 3))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 691, 3))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'register')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 703, 3))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'registerFile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 747, 3))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(addressBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 168, 3))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, True) ]))
    st_15._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
addressBlockType._Automaton = _BuildAutomaton_119()




CTD_ANON_110._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), nonIndexedLeafAccessHandle, scope=CTD_ANON_110, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 161, 6)))

def _BuildAutomaton_120 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_120
    del _BuildAutomaton_120
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_110._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandle')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 161, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_110._Automaton = _BuildAutomaton_120()




addrSpaceRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=addrSpaceRefType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

def _BuildAutomaton_121 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_121
    del _BuildAutomaton_121
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 177, 3))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(addrSpaceRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 177, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
addrSpaceRefType._Automaton = _BuildAutomaton_121()




CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), simpleAccessHandle, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 205, 6)))

def _BuildAutomaton_122 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_122
    del _BuildAutomaton_122
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandle')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 205, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_111._Automaton = _BuildAutomaton_122()




CTD_ANON_112._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), simpleAccessHandle, scope=CTD_ANON_112, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 223, 6)))

def _BuildAutomaton_123 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_123
    del _BuildAutomaton_123
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_112._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandle')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 223, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_112._Automaton = _BuildAutomaton_123()




bankedBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=bankedBlockType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

bankedBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=bankedBlockType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

bankedBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=bankedBlockType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

bankedBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=bankedBlockType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

bankedBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=bankedBlockType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

bankedBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=bankedBlockType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

bankedBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), CTD_ANON_113, scope=bankedBlockType, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 238, 3)))

bankedBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'volatile'), pyxb.binding.datatypes.boolean, scope=bankedBlockType, documentation='Indicates whether the data is volatile.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), unicode_default='false'))

bankedBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'access'), accessType, scope=bankedBlockType, documentation="Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1)))

bankedBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'range'), unsignedPositiveLongintExpression, scope=bankedBlockType, documentation='The address range of an address block.  Expressed as the number of addressable units accessible to the block. The range and the width are related by the following formulas:\n\t\t\t\t\tnumber_of_bits_in_block = ipxact:addressUnitBits * ipxact:range\n\t\t\t\t\tnumber_of_rows_in_block = number_of_bits_in_block / ipxact:width\n\t\t\t\t\t', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 659, 3)))

bankedBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'width'), unsignedIntExpression, scope=bankedBlockType, documentation='The bit width of a row in the address block. The range and the width are related by the following formulas:\n\t\t\t\t\tnumber_of_bits_in_block = ipxact:addressUnitBits * ipxact:range\n\t\t\t\t\tnumber_of_rows_in_block = number_of_bits_in_block / ipxact:width\n\t\t\t\t\t', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 667, 3)))

bankedBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'usage'), usageType, scope=bankedBlockType, documentation="Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3)))

bankedBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'register'), CTD_ANON_121, scope=bankedBlockType, documentation='A single register', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 703, 3)))

bankedBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'registerFile'), CTD_ANON_129, scope=bankedBlockType, documentation='A structure of registers and register files', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 984, 1)))

def _BuildAutomaton_124 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_124
    del _BuildAutomaton_124
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 238, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 245, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 689, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 690, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 691, 3))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 574, 3))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 248, 3))
    counters.add(cc_9)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(bankedBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(bankedBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(bankedBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(bankedBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandles')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 238, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(bankedBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 245, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(bankedBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'range')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 659, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(bankedBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'width')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 667, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(bankedBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'usage')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(bankedBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'volatile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 689, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(bankedBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'access')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 690, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(bankedBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 691, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(bankedBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'register')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 703, 3))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(bankedBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'registerFile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 747, 3))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(bankedBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 248, 3))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, True) ]))
    st_13._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
bankedBlockType._Automaton = _BuildAutomaton_124()




CTD_ANON_113._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), nonIndexedLeafAccessHandle, scope=CTD_ANON_113, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 241, 6)))

def _BuildAutomaton_125 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_125
    del _BuildAutomaton_125
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_113._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandle')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 241, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_113._Automaton = _BuildAutomaton_125()




bankedSubspaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=bankedSubspaceType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

bankedSubspaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=bankedSubspaceType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

bankedSubspaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=bankedSubspaceType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 334, 3)))

bankedSubspaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=bankedSubspaceType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

bankedSubspaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=bankedSubspaceType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

bankedSubspaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=bankedSubspaceType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

def _BuildAutomaton_126 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_126
    del _BuildAutomaton_126
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 334, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 339, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 340, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 258, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 259, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 264, 3))
    counters.add(cc_5)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(bankedSubspaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 334, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(bankedSubspaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 339, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(bankedSubspaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 340, 3))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(bankedSubspaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 258, 3))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(bankedSubspaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 259, 3))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(bankedSubspaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 264, 3))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
bankedSubspaceType._Automaton = _BuildAutomaton_126()




fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=fieldType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=fieldType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=fieldType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=fieldType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=fieldType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=fieldType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), CTD_ANON_114, scope=fieldType, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 279, 3)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'bitOffset'), unsignedIntExpression, scope=fieldType, documentation="Offset of this field's bit 0 from bit 0 of the register.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 287, 3)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'resets'), CTD_ANON_115, scope=fieldType, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 292, 3)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'volatile'), pyxb.binding.datatypes.boolean, scope=fieldType, documentation='Indicates whether the data is volatile.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), unicode_default='false'))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'access'), accessType, scope=fieldType, documentation="Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'enumeratedValues'), CTD_ANON_128, scope=fieldType, documentation='Enumerates specific values that can be assigned to the bit field.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 815, 1)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'modifiedWriteValue'), CTD_ANON_189, scope=fieldType, documentation="If present this element describes the modification of field data caused by a write operation. 'oneToClear' means that in a bitwise fashion each write data bit of a one will clear the corresponding bit in the field. 'oneToSet' means that in a bitwise fashion each write data bit of a one will set the corresponding bit in the field.  'oneToToggle' means that in a bitwise fashion each write data bit of a one will toggle the corresponding bit in the field. 'zeroToClear' means that in a bitwise fashion each write data bit of a zero will clear the corresponding bit in the field. 'zeroToSet' means that in a bitwise fashion each write data bit of a zero will set the corresponding bit in the field. 'zeroToToggle' means that in a bitwise fashion each write data bit of a zero will toggle the corresponding bit in the field. 'clear' means any write to this field clears the field. 'set' means any write to the field sets the field. 'modify' means any write to this field may modify that data. If this element is not present the write operation data is written.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 895, 3)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'writeValueConstraint'), writeValueConstraintType, scope=fieldType, documentation='The legal values that may be written to a field. If not specified the legal values are not specified.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 907, 3)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'readAction'), CTD_ANON_190, scope=fieldType, documentation="A list of possible actions for a read to set the field after the read. 'clear' means that after a read the field is cleared. 'set' means that after a read the field is set. 'modify' means after a read the field is modified. If not present the field value is not modified after a read.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 912, 3)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'testable'), CTD_ANON_191, scope=fieldType, documentation='Can the field be tested with an automated register test routine. The presumed value is true if not specified.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 924, 3)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'reserved'), unsignedBitExpression, scope=fieldType, documentation="Indicates that the field should be documented as reserved. The presumed value is 'false' if not present.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 948, 3), unicode_default='false'))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier'), pyxb.binding.datatypes.Name, scope=fieldType, documentation='Identifier name used to indicate that multiple field elements contain the exact same information for the elements in the fieldDefinitionGroup.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1032, 3)))

fieldType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'bitWidth'), unsignedPositiveIntExpression, scope=fieldType, documentation='Width of the field in bits.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1037, 3)))

def _BuildAutomaton_127 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_127
    del _BuildAutomaton_127
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 279, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 286, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 292, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1032, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 888, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 893, 3))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 894, 3))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 895, 3))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 907, 3))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 912, 3))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 924, 3))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 948, 3))
    counters.add(cc_13)
    cc_14 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 304, 3))
    counters.add(cc_14)
    cc_15 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 305, 3))
    counters.add(cc_15)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandles')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 279, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 286, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'bitOffset')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 287, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'resets')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 292, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1032, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'bitWidth')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1037, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'volatile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 888, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'access')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 893, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'enumeratedValues')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 894, 3))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'modifiedWriteValue')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 895, 3))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'writeValueConstraint')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 907, 3))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'readAction')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 912, 3))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_12, False))
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'testable')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 924, 3))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_13, False))
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'reserved')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 948, 3))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_14, False))
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 304, 3))
    st_17 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_15, False))
    symbol = pyxb.binding.content.ElementUse(fieldType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 305, 3))
    st_18 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_18)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_13, True) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_13, False) ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_14, True) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_14, False) ]))
    st_17._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_15, True) ]))
    st_18._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
fieldType._Automaton = _BuildAutomaton_127()




CTD_ANON_114._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), nonIndexedLeafAccessHandle, scope=CTD_ANON_114, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 282, 6)))

def _BuildAutomaton_128 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_128
    del _BuildAutomaton_128
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_114._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandle')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 282, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_114._Automaton = _BuildAutomaton_128()




CTD_ANON_115._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'reset'), CTD_ANON_131, scope=CTD_ANON_115, documentation='Register value at reset.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1133, 1)))

def _BuildAutomaton_129 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_129
    del _BuildAutomaton_129
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_115._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'reset')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 295, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_115._Automaton = _BuildAutomaton_129()




memoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=memoryMapType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

memoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=memoryMapType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

memoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=memoryMapType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

memoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=memoryMapType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

memoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=memoryMapType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

memoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'subspaceMap'), subspaceRefType, scope=memoryMapType, documentation='Maps in an address subspace from across a bus bridge.  Its masterRef attribute refers by name to the master bus interface on the other side of the bridge.  It must match the masterRef attribute of a bridge element on the slave interface, and that bridge element must be designated as opaque.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 321, 3)))

memoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'memoryRemap'), memoryRemapType, scope=memoryMapType, documentation='Additional memory map elements that are dependent on the component state.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 336, 3)))

memoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'shared'), sharedType, scope=memoryMapType, documentation="When the value is 'yes', the contents of the memoryMap are shared by all the references to this memoryMap, when the value is 'no' the contents of the memoryMap is not shared and when the value is 'undefined' (default) the sharing of the memoryMap is undefined.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 346, 3)))

memoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), addressBlockType, scope=memoryMapType, documentation='This is a single contiguous block of memory inside a memory map.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 432, 1)))

memoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'bank'), addressBankType, scope=memoryMapType, documentation="Represents a bank of memory made up of address blocks or other banks.  It has a bankAlignment attribute indicating whether its blocks are aligned in 'parallel' (occupying adjacent bit fields) or 'serial' (occupying contiguous addresses). Its child blocks do not contain addresses or bit offsets.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 549, 1)))

memoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressUnitBits'), unsignedPositiveLongintExpression, scope=memoryMapType, documentation='The number of data bits in an addressable unit. The default is byte addressable (8 bits).', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 563, 1)))

def _BuildAutomaton_130 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_130
    del _BuildAutomaton_130
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 334, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 335, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 336, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 345, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 346, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 351, 3))
    counters.add(cc_7)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(memoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(memoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(memoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(memoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 334, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(memoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressBlock')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 319, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(memoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'bank')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 320, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(memoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'subspaceMap')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 321, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(memoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'memoryRemap')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 336, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(memoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressUnitBits')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 345, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(memoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'shared')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 346, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(memoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 351, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    st_10._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
memoryMapType._Automaton = _BuildAutomaton_130()




memoryRemapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=memoryRemapType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

memoryRemapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=memoryRemapType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

memoryRemapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=memoryRemapType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

memoryRemapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=memoryRemapType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

memoryRemapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'subspaceMap'), subspaceRefType, scope=memoryRemapType, documentation='Maps in an address subspace from across a bus bridge.  Its masterRef attribute refers by name to the master bus interface on the other side of the bridge.  It must match the masterRef attribute of a bridge element on the slave interface, and that bridge element must be designated as opaque.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 321, 3)))

memoryRemapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), addressBlockType, scope=memoryRemapType, documentation='This is a single contiguous block of memory inside a memory map.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 432, 1)))

memoryRemapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'bank'), addressBankType, scope=memoryRemapType, documentation="Represents a bank of memory made up of address blocks or other banks.  It has a bankAlignment attribute indicating whether its blocks are aligned in 'parallel' (occupying adjacent bit fields) or 'serial' (occupying contiguous addresses). Its child blocks do not contain addresses or bit offsets.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 549, 1)))

def _BuildAutomaton_131 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_131
    del _BuildAutomaton_131
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 361, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 362, 3))
    counters.add(cc_3)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(memoryRemapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(memoryRemapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(memoryRemapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(memoryRemapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 361, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(memoryRemapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressBlock')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 319, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(memoryRemapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'bank')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 320, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(memoryRemapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'subspaceMap')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 321, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
memoryRemapType._Automaton = _BuildAutomaton_131()




localMemoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=localMemoryMapType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

localMemoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=localMemoryMapType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

localMemoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=localMemoryMapType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

localMemoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=localMemoryMapType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

localMemoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'bank'), localAddressBankType, scope=localMemoryMapType, documentation="Represents a bank of memory made up of address blocks or other banks.  It has a bankAlignment attribute indicating whether its blocks are aligned in 'parallel' (occupying adjacent bit fields) or 'serial' (occupying contiguous addresses). Its child blocks do not contain addresses or bit offsets.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 380, 7)))

localMemoryMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), addressBlockType, scope=localMemoryMapType, documentation='This is a single contiguous block of memory inside a memory map.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 432, 1)))

def _BuildAutomaton_132 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_132
    del _BuildAutomaton_132
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 377, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 378, 3))
    counters.add(cc_3)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(localMemoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(localMemoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(localMemoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(localMemoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 377, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(localMemoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressBlock')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 379, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(localMemoryMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'bank')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 380, 7))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
localMemoryMapType._Automaton = _BuildAutomaton_132()




subspaceRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=subspaceRefType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

subspaceRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=subspaceRefType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

subspaceRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=subspaceRefType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

subspaceRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=subspaceRefType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

subspaceRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=subspaceRefType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

subspaceRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=subspaceRefType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

subspaceRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'baseAddress'), unsignedLongintExpression, scope=subspaceRefType, documentation='Base of an address block, bank, subspace map or address space. Expressed as the number of addressable units from the containing memoryMap or localMemoryMap.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 558, 1)))

def _BuildAutomaton_133 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_133
    del _BuildAutomaton_133
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 402, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 404, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 409, 3))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(subspaceRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(subspaceRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(subspaceRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(subspaceRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 402, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(subspaceRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'baseAddress')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 584, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(subspaceRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 404, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(subspaceRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 409, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
subspaceRefType._Automaton = _BuildAutomaton_133()




CTD_ANON_116._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressSpace'), CTD_ANON_117, scope=CTD_ANON_116, documentation='This defines a logical space, referenced by a bus master.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 453, 4)))

def _BuildAutomaton_134 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_134
    del _BuildAutomaton_134
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_116._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressSpace')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 453, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_116._Automaton = _BuildAutomaton_134()




CTD_ANON_117._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=CTD_ANON_117, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

CTD_ANON_117._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_117, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_117._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_117, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

CTD_ANON_117._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_117, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_117._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_117, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_117._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_117, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_117._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'executableImage'), CTD_ANON_89, scope=CTD_ANON_117, documentation='Specifies an executable software image to be loaded into a processors address space. The format of the image is not specified. It could, for example, be an ELF loadfile, or it could be raw binary or ascii hex data for loading directly into a memory model instance.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 194, 4)))

CTD_ANON_117._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'segments'), CTD_ANON_118, scope=CTD_ANON_117, documentation='Address segments withing an addressSpace ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 462, 7)))

CTD_ANON_117._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'localMemoryMap'), localMemoryMapType, scope=CTD_ANON_117, documentation='Provides the local memory map of an address space.  Blocks in this memory map are accessable to master interfaces on this component that reference this address space.   They are not accessable to any external master interface.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 496, 7)))

CTD_ANON_117._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressUnitBits'), unsignedPositiveLongintExpression, scope=CTD_ANON_117, documentation='The number of data bits in an addressable unit. The default is byte addressable (8 bits).', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 563, 1)))

CTD_ANON_117._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'range'), unsignedPositiveLongintExpression, scope=CTD_ANON_117, documentation='The address range of an address block.  Expressed as the number of addressable units accessible to the block. The range and the width are related by the following formulas:\n\t\t\t\t\tnumber_of_bits_in_block = ipxact:addressUnitBits * ipxact:range\n\t\t\t\t\tnumber_of_rows_in_block = number_of_bits_in_block / ipxact:width\n\t\t\t\t\t', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 659, 3)))

CTD_ANON_117._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'width'), unsignedIntExpression, scope=CTD_ANON_117, documentation='The bit width of a row in the address block. The range and the width are related by the following formulas:\n\t\t\t\t\tnumber_of_bits_in_block = ipxact:addressUnitBits * ipxact:range\n\t\t\t\t\tnumber_of_rows_in_block = number_of_bits_in_block / ipxact:width\n\t\t\t\t\t', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 667, 3)))

def _BuildAutomaton_135 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_135
    del _BuildAutomaton_135
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 460, 7))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 462, 7))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 494, 7))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 495, 7))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 496, 7))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 505, 7))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 510, 7))
    counters.add(cc_8)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_117._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_117._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_117._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_117._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 460, 7))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_117._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'range')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 659, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_117._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'width')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 667, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_117._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'segments')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 462, 7))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_117._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressUnitBits')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 494, 7))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_117._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'executableImage')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 495, 7))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_117._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'localMemoryMap')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 496, 7))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_117._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 505, 7))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_117._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 510, 7))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, True) ]))
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_117._Automaton = _BuildAutomaton_135()




CTD_ANON_118._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'segment'), CTD_ANON_119, scope=CTD_ANON_118, documentation='Address segment withing an addressSpace ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 468, 10)))

def _BuildAutomaton_136 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_136
    del _BuildAutomaton_136
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_118._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'segment')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 468, 10))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_118._Automaton = _BuildAutomaton_136()




CTD_ANON_119._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_119, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_119._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_119, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

CTD_ANON_119._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_119, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_119._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_119, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_119._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_119, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_119._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressOffset'), unsignedLongintExpression, scope=CTD_ANON_119, documentation='Address offset of the segment within the containing address space.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 476, 13)))

CTD_ANON_119._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'range'), unsignedPositiveLongintExpression, scope=CTD_ANON_119, documentation='The address range of asegment.  Expressed as the number of addressable units accessible to the segment. \t\t\t\t', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 481, 13)))

def _BuildAutomaton_137 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_137
    del _BuildAutomaton_137
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 475, 13))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 486, 13))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_119._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_119._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_119._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_119._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 475, 13))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_119._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressOffset')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 476, 13))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_119._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'range')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 481, 13))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_119._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 486, 13))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_119._Automaton = _BuildAutomaton_137()




CTD_ANON_120._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'memoryMap'), memoryMapType, scope=CTD_ANON_120, documentation="The set of address blocks a bus slave contributes to the bus' address space.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 533, 4)))

def _BuildAutomaton_138 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_138
    del _BuildAutomaton_138
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_120._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'memoryMap')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 533, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_120._Automaton = _BuildAutomaton_138()




CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=CTD_ANON_121, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_121, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_121, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_121, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_121, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_121, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'volatile'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_121, documentation='Indicates whether the data is volatile.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), unicode_default='false'))

CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'access'), accessType, scope=CTD_ANON_121, documentation="Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1)))

CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), CTD_ANON_122, scope=CTD_ANON_121, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 710, 6)))

CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'dim'), CTD_ANON_208, scope=CTD_ANON_121, documentation='Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 718, 6)))

CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressOffset'), unsignedLongintExpression, scope=CTD_ANON_121, documentation="Offset from the address block's baseAddress or the containing register file's addressOffset, expressed as the number of addressUnitBits from the containing memoryMap or localMemoryMap.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 730, 6)))

CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'alternateRegisters'), CTD_ANON_123, scope=CTD_ANON_121, documentation='Alternate definitions for the current register', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 754, 1)))

CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier'), pyxb.binding.datatypes.Name, scope=CTD_ANON_121, documentation='Identifier name used to indicate that multiple register elements contain the exact same information for the elements in the registerDefinitionGroup.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1083, 3)))

CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'size'), unsignedPositiveIntExpression, scope=CTD_ANON_121, documentation='Width of the register in bits.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1088, 3)))

CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'field'), fieldType, scope=CTD_ANON_121, documentation='Describes individual bit fields within the register.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1096, 4)))

def _BuildAutomaton_139 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_139
    del _BuildAutomaton_139
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 710, 6))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 717, 6))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 718, 6))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1083, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1093, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1094, 3))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 736, 6))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 737, 6))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 738, 6))
    counters.add(cc_10)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandles')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 710, 6))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 717, 6))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'dim')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 718, 6))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressOffset')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 730, 6))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1083, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'size')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1088, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'volatile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1093, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'access')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1094, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'field')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1096, 4))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'alternateRegisters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 736, 6))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 737, 6))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 738, 6))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_10, True) ]))
    st_14._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_121._Automaton = _BuildAutomaton_139()




CTD_ANON_122._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), indexedAccessHandle, scope=CTD_ANON_122, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 713, 9)))

def _BuildAutomaton_140 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_140
    del _BuildAutomaton_140
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_122._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandle')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 713, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_122._Automaton = _BuildAutomaton_140()




CTD_ANON_123._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'alternateRegister'), CTD_ANON_124, scope=CTD_ANON_123, documentation='Alternate definition for the current register', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 760, 4)))

def _BuildAutomaton_141 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_141
    del _BuildAutomaton_141
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_123._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'alternateRegister')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 760, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_123._Automaton = _BuildAutomaton_141()




CTD_ANON_124._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=CTD_ANON_124, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

CTD_ANON_124._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_124, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_124._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_124, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

CTD_ANON_124._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_124, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_124._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_124, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_124._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_124, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_124._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'volatile'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_124, documentation='Indicates whether the data is volatile.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), unicode_default='false'))

CTD_ANON_124._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'access'), accessType, scope=CTD_ANON_124, documentation="Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1)))

CTD_ANON_124._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), CTD_ANON_125, scope=CTD_ANON_124, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 767, 7)))

CTD_ANON_124._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'alternateGroups'), CTD_ANON_126, scope=CTD_ANON_124, documentation='Defines a list of grouping names that this register description belongs.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 775, 7)))

CTD_ANON_124._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier'), pyxb.binding.datatypes.Name, scope=CTD_ANON_124, documentation='Identifier name used to indicate that multiple register elements contain the exact same information for the elements in the alternateRegisterDefinitionGroup.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1113, 3)))

CTD_ANON_124._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'field'), fieldType, scope=CTD_ANON_124, documentation='Describes individual bit fields within the register.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1121, 4)))

def _BuildAutomaton_142 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_142
    del _BuildAutomaton_142
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 767, 7))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 774, 7))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1113, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1118, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1119, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 798, 7))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 799, 7))
    counters.add(cc_8)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_124._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_124._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_124._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_124._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandles')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 767, 7))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_124._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 774, 7))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_124._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'alternateGroups')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 775, 7))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_124._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1113, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_124._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'volatile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1118, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_124._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'access')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1119, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_124._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'field')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1121, 4))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_124._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 798, 7))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_124._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 799, 7))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, True) ]))
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_124._Automaton = _BuildAutomaton_142()




CTD_ANON_125._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), indexedAccessHandle, scope=CTD_ANON_125, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 770, 10)))

def _BuildAutomaton_143 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_143
    del _BuildAutomaton_143
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_125._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandle')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 770, 10))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_125._Automaton = _BuildAutomaton_143()




CTD_ANON_126._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'alternateGroup'), CTD_ANON_127, scope=CTD_ANON_126, documentation='Defines a grouping name that this register description belongs.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 781, 10)))

def _BuildAutomaton_144 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_144
    del _BuildAutomaton_144
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_126._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'alternateGroup')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 781, 10))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_126._Automaton = _BuildAutomaton_144()




CTD_ANON_128._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'enumeratedValue'), CTD_ANON_188, scope=CTD_ANON_128, documentation='Enumerates specific values that can be assigned to the bit field. The name of this enumerated value. This may be used as a token in generating code.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 821, 4)))

def _BuildAutomaton_145 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_145
    del _BuildAutomaton_145
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_128._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'enumeratedValue')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 821, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_128._Automaton = _BuildAutomaton_145()




writeValueConstraintType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'writeAsRead'), pyxb.binding.datatypes.boolean, scope=writeValueConstraintType, documentation='writeAsRead indicates that only a value immediately read before a write is a legal value to be written.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 960, 3)))

writeValueConstraintType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'useEnumeratedValues'), pyxb.binding.datatypes.boolean, scope=writeValueConstraintType, documentation='useEnumeratedValues indicates that only write enumeration value shall be legal values to be written.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 965, 3)))

writeValueConstraintType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'minimum'), unsignedBitVectorExpression, scope=writeValueConstraintType, documentation='The minimum legal value that may be written to a field', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 971, 4)))

writeValueConstraintType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'maximum'), unsignedBitVectorExpression, scope=writeValueConstraintType, documentation='The maximum legal value that may be written to a field', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 976, 4)))

def _BuildAutomaton_146 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_146
    del _BuildAutomaton_146
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(writeValueConstraintType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'writeAsRead')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 960, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(writeValueConstraintType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'useEnumeratedValues')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 965, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(writeValueConstraintType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'minimum')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 971, 4))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(writeValueConstraintType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'maximum')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 976, 4))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
writeValueConstraintType._Automaton = _BuildAutomaton_146()




CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=CTD_ANON_129, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_129, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_129, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_129, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_129, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_129, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'register'), CTD_ANON_121, scope=CTD_ANON_129, documentation='A single register', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 703, 3)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'registerFile'), CTD_ANON_129, scope=CTD_ANON_129, documentation='A structure of registers and register files', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 984, 1)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), CTD_ANON_130, scope=CTD_ANON_129, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 991, 4)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'dim'), CTD_ANON_209, scope=CTD_ANON_129, documentation='Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 999, 4)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressOffset'), unsignedLongintExpression, scope=CTD_ANON_129, documentation="Offset from the address block's baseAddress or the containing register file's addressOffset, expressed as the number of addressUnitBits from the containing memoryMap or localMemoryMap.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1011, 4)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier'), pyxb.binding.datatypes.Name, scope=CTD_ANON_129, documentation='Identifier name used to indicate that multiple registerFile elements contain the exact same information except for the elements in the registerFileInstanceGroup.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1050, 3)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'range'), unsignedPositiveLongintExpression, scope=CTD_ANON_129, documentation='The range of a register file.  Expressed as the number of addressable units accessible to the block. Specified in units of addressUnitBits.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1055, 3)))

def _BuildAutomaton_147 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_147
    del _BuildAutomaton_147
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 991, 4))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 998, 4))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 999, 4))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1050, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1060, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1017, 4))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1018, 4))
    counters.add(cc_8)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandles')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 991, 4))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 998, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'dim')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 999, 4))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressOffset')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1011, 4))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'typeIdentifier')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1050, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'range')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1055, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'register')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 703, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'registerFile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 747, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1017, 4))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1018, 4))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, True) ]))
    st_12._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_129._Automaton = _BuildAutomaton_147()




CTD_ANON_130._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), indexedAccessHandle, scope=CTD_ANON_130, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 994, 7)))

def _BuildAutomaton_148 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_148
    del _BuildAutomaton_148
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_130._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandle')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 994, 7))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_130._Automaton = _BuildAutomaton_148()




CTD_ANON_131._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'value'), unsignedBitVectorExpression, scope=CTD_ANON_131, documentation='The value itself.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1139, 4)))

CTD_ANON_131._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'mask'), unsignedBitVectorExpression, scope=CTD_ANON_131, documentation='Mask to be anded with the value before comparing to the reset value.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1144, 4)))

def _BuildAutomaton_149 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_149
    del _BuildAutomaton_149
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1144, 4))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_131._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'value')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1139, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_131._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'mask')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 1144, 4))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_131._Automaton = _BuildAutomaton_149()




designInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=designInstantiationType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

designInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.NMTOKEN, scope=designInstantiationType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3)))

designInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=designInstantiationType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

designInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=designInstantiationType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

designInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'designRef'), configurableLibraryRefType, scope=designInstantiationType, documentation='References an IP-XACT design document (by VLNV) that provides a design for the component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 65, 3)))

def _BuildAutomaton_150 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_150
    del _BuildAutomaton_150
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 353, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 354, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 70, 3))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(designInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(designInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 353, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(designInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 354, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(designInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'designRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 65, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(designInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 70, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
designInstantiationType._Automaton = _BuildAutomaton_150()




designConfigurationInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=designConfigurationInstantiationType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

designConfigurationInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=designConfigurationInstantiationType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

designConfigurationInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.NMTOKEN, scope=designConfigurationInstantiationType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3)))

designConfigurationInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=designConfigurationInstantiationType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

designConfigurationInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=designConfigurationInstantiationType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

designConfigurationInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'language'), languageType, scope=designConfigurationInstantiationType, documentation=' The hardware description language used such as "verilog" or "vhdl". If the attribute "strict" is "true", this value must match the language being generated for the design.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 80, 3)))

designConfigurationInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'designConfigurationRef'), configurableLibraryRefType, scope=designConfigurationInstantiationType, documentation="References an IP-XACT design configuration document (by VLNV) that provides a configuration for the component's design.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 85, 3)))

def _BuildAutomaton_151 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_151
    del _BuildAutomaton_151
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 353, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 354, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 80, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 90, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 91, 3))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(designConfigurationInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(designConfigurationInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 353, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(designConfigurationInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 354, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(designConfigurationInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'language')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 80, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(designConfigurationInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'designConfigurationRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 85, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(designConfigurationInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 90, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(designConfigurationInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 91, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
designConfigurationInstantiationType._Automaton = _BuildAutomaton_151()




componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=componentInstantiationType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=componentInstantiationType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.NMTOKEN, scope=componentInstantiationType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=componentInstantiationType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=componentInstantiationType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'constraintSetRef'), CTD_ANON_74, scope=componentInstantiationType, documentation='A reference to a set of port constraints.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 269, 4)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'fileSetRef'), CTD_ANON_94, scope=componentInstantiationType, documentation='A reference to a fileSet.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/file.xsd', 309, 4)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isVirtual'), pyxb.binding.datatypes.boolean, scope=componentInstantiationType, documentation='When true, indicates that this component should not be netlisted.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 101, 3), unicode_default='false'))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'language'), languageType, scope=componentInstantiationType, documentation=' The hardware description language used such as "verilog" or "vhdl". If the attribute "strict" is "true", this value must match the language being generated for the design.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 106, 3)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'libraryName'), pyxb.binding.datatypes.anyType, scope=componentInstantiationType, documentation='A string specifying the library name in which the model should be compiled. If the libraryName element is not present then its value defaults to \u201cwork\u201d.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 111, 3)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'packageName'), pyxb.binding.datatypes.string, scope=componentInstantiationType, documentation='A string describing the VHDL package containing the interface of the model. If the packageName element is not present then its value defaults to the component VLNV name concatenated with postfix \u201c_cmp_pkg\u201d which stands for component package.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 116, 3)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'moduleName'), pyxb.binding.datatypes.string, scope=componentInstantiationType, documentation='A string describing the Verilog, SystemVerilog, or SystemC module name or the VHDL entity name. If the moduleName is not present then its value defaults to the component VLNV name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 121, 3)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'architectureName'), pyxb.binding.datatypes.string, scope=componentInstantiationType, documentation='A string describing the VHDL architecture name. If the architectureName element is not present then its value defaults to \u201crtl\u201d.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 126, 3)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'configurationName'), pyxb.binding.datatypes.string, scope=componentInstantiationType, documentation='A string describing the Verilog, SystemVerilog, or VHDL configuration name. If the configurationName element is not present then its value defaults to the design configuration VLNV name of the design configuration associated with the active hierarchical view or, if there is no active hierarchical view, to the component VLNV name concatenated with postfix \u201c_rtl_cfg\u201d.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 131, 3)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'moduleParameters'), CTD_ANON_132, scope=componentInstantiationType, documentation='Model parameter name value pairs container', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 136, 3)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'defaultFileBuilder'), fileBuilderType, scope=componentInstantiationType, documentation='Default command and flags used to build derived files from the sourceName files in the referenced file sets.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 151, 3)))

componentInstantiationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'whiteboxElementRefs'), CTD_ANON_133, scope=componentInstantiationType, documentation=' Container for white box element references.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 158, 3)))

def _BuildAutomaton_152 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_152
    del _BuildAutomaton_152
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 353, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 354, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 101, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 106, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 111, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 116, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 121, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 126, 3))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 131, 3))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 136, 3))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 151, 3))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 156, 3))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 157, 3))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 158, 3))
    counters.add(cc_13)
    cc_14 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 172, 3))
    counters.add(cc_14)
    cc_15 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 173, 3))
    counters.add(cc_15)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 353, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 354, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isVirtual')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 101, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'language')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 106, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'libraryName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 111, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'packageName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 116, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'moduleName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 121, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'architectureName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 126, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'configurationName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 131, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'moduleParameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 136, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'defaultFileBuilder')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 151, 3))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'fileSetRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 156, 3))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_12, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'constraintSetRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 157, 3))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_13, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'whiteboxElementRefs')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 158, 3))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_14, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 172, 3))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_15, False))
    symbol = pyxb.binding.content.ElementUse(componentInstantiationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 173, 3))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_13, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_13, False) ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_14, True) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_14, False) ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_15, True) ]))
    st_16._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
componentInstantiationType._Automaton = _BuildAutomaton_152()




CTD_ANON_132._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'moduleParameter'), moduleParameterType, scope=CTD_ANON_132, documentation='A module parameter name value pair. The name is given in an attribute. The value is the element value. The dataType (applicable to high level modeling) is given in the dataType attribute. For hardware based models, the name should be identical to the RTL (VHDL generic or Verilog parameter). The usageType attribute indicates how the model parameter is to be used.\n\t\t\t\t\t\t\t\t\t\t', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 142, 6)))

def _BuildAutomaton_153 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_153
    del _BuildAutomaton_153
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_132._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'moduleParameter')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 142, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_132._Automaton = _BuildAutomaton_153()




CTD_ANON_133._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'whiteboxElementRef'), whiteboxElementRefType, scope=CTD_ANON_133, documentation=' Reference to a white box element which is visible within this view.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 164, 6)))

def _BuildAutomaton_154 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_154
    del _BuildAutomaton_154
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 164, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_133._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'whiteboxElementRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 164, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_133._Automaton = _BuildAutomaton_154()




modelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'views'), CTD_ANON_134, scope=modelType, documentation='Views container', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 202, 3)))

modelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'instantiations'), CTD_ANON_136, scope=modelType, documentation='Instantiations container', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 237, 3)))

modelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'ports'), CTD_ANON_137, scope=modelType, documentation='Port container', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 251, 3)))

def _BuildAutomaton_155 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_155
    del _BuildAutomaton_155
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 202, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 237, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 251, 3))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(modelType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'views')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 202, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(modelType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'instantiations')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 237, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(modelType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'ports')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 251, 3))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
modelType._Automaton = _BuildAutomaton_155()




CTD_ANON_134._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'view'), CTD_ANON_135, scope=CTD_ANON_134, documentation='Single view of a component', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 208, 6)))

def _BuildAutomaton_156 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_156
    del _BuildAutomaton_156
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_134._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'view')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 208, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_134._Automaton = _BuildAutomaton_156()




CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_135, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_135, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_135, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_135, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'envIdentifier'), CTD_ANON_192, scope=CTD_ANON_135, documentation=' Defines the hardware environment in which this view applies. The format of the string is language:tool:vendor_extension, with each piece being optional. The language must be one of the types from ipxact:fileType. The tool values are defined by the Accellera Systems Initiative, and include generic values "*Simulation" and "*Synthesis" to imply any tool of the indicated type. Having more than one envIdentifier indicates that the view applies to multiple environments.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 216, 9)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'componentInstantiationRef'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 228, 9)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'designInstantiationRef'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 229, 9)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'designConfigurationInstantiationRef'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 230, 9)))

def _BuildAutomaton_157 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_157
    del _BuildAutomaton_157
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 353, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 354, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 215, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 216, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 228, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 229, 9))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 230, 9))
    counters.add(cc_6)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 353, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 354, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 215, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'envIdentifier')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 216, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'componentInstantiationRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 228, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'designInstantiationRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 229, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'designConfigurationInstantiationRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 230, 9))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_135._Automaton = _BuildAutomaton_157()




CTD_ANON_136._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'componentInstantiation'), componentInstantiationType, scope=CTD_ANON_136, documentation='Component Instantiation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 179, 3)))

CTD_ANON_136._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'designInstantiation'), designInstantiationType, scope=CTD_ANON_136, documentation='Design Instantiation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 184, 3)))

CTD_ANON_136._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'designConfigurationInstantiation'), designConfigurationInstantiationType, scope=CTD_ANON_136, documentation='Design Configuration Instantiation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 189, 3)))

def _BuildAutomaton_158 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_158
    del _BuildAutomaton_158
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_136._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'componentInstantiation')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 179, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_136._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'designInstantiation')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 184, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_136._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'designConfigurationInstantiation')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 189, 3))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_136._Automaton = _BuildAutomaton_158()




CTD_ANON_137._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'port'), portType, scope=CTD_ANON_137, documentation='Describes port characteristics.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 452, 1)))

def _BuildAutomaton_159 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_159
    del _BuildAutomaton_159
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_137._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'port')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 257, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_137._Automaton = _BuildAutomaton_159()




abstractorModelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'views'), CTD_ANON_138, scope=abstractorModelType, documentation='Views container', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 268, 3)))

abstractorModelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'instantiations'), CTD_ANON_140, scope=abstractorModelType, documentation='Instantiations container', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 301, 3)))

abstractorModelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'ports'), CTD_ANON_141, scope=abstractorModelType, documentation='Port container', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 315, 3)))

def _BuildAutomaton_160 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_160
    del _BuildAutomaton_160
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 268, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 301, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 315, 3))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(abstractorModelType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'views')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 268, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(abstractorModelType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'instantiations')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 301, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(abstractorModelType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'ports')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 315, 3))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
abstractorModelType._Automaton = _BuildAutomaton_160()




CTD_ANON_138._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'view'), CTD_ANON_139, scope=CTD_ANON_138, documentation='Single view of an abstracto', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 274, 6)))

def _BuildAutomaton_161 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_161
    del _BuildAutomaton_161
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_138._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'view')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 274, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_138._Automaton = _BuildAutomaton_161()




CTD_ANON_139._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_139, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3)))

CTD_ANON_139._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_139, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_139._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_139, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_139._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_139, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_139._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'envIdentifier'), CTD_ANON_193, scope=CTD_ANON_139, documentation=' Defines the hardware environment in which this view applies. The format of the string is language:tool:vendor_extension, with each piece being optional. The language must be one of the types from ipxact:fileType. The tool values are defined by the Accellera Systems Initiative, and include generic values "*Simulation" and "*Synthesis" to imply any tool of the indicated type. Having more than one envIdentifier indicates that the view applies to multiple environments.  ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 282, 9)))

CTD_ANON_139._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'componentInstantiationRef'), pyxb.binding.datatypes.NMTOKEN, scope=CTD_ANON_139, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 294, 9)))

def _BuildAutomaton_162 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_162
    del _BuildAutomaton_162
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 353, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 354, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 281, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 282, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 294, 9))
    counters.add(cc_4)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_139._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 348, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_139._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 353, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_139._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 354, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_139._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 281, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_139._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'envIdentifier')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 282, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_139._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'componentInstantiationRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 294, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_139._Automaton = _BuildAutomaton_162()




CTD_ANON_140._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'componentInstantiation'), componentInstantiationType, scope=CTD_ANON_140, documentation='Component Instantiation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 307, 6)))

def _BuildAutomaton_163 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_163
    del _BuildAutomaton_163
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_140._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'componentInstantiation')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 307, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_140._Automaton = _BuildAutomaton_163()




CTD_ANON_141._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'port'), abstractorPortType, scope=CTD_ANON_141, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 321, 6)))

def _BuildAutomaton_164 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_164
    del _BuildAutomaton_164
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 321, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_141._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'port')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 321, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_141._Automaton = _BuildAutomaton_164()




whiteboxElementRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=whiteboxElementRefType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

whiteboxElementRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'location'), slicesType, scope=whiteboxElementRefType, documentation='The contents of each location element can be used to specified one location (HDL Path) through the referenced whiteBoxElement is accessible.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 366, 3)))

def _BuildAutomaton_165 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_165
    del _BuildAutomaton_165
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 365, 3))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(whiteboxElementRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 365, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(whiteboxElementRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'location')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/model.xsd', 366, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
whiteboxElementRefType._Automaton = _BuildAutomaton_165()




portType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=portType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

portType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), portName, scope=portType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 362, 3)))

portType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=portType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

portType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=portType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

portType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=portType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

portType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'wire'), portWireType, scope=portType, documentation='Defines a port whose type resolves to simple bits.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 77, 4)))

portType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'transactional'), portTransactionalType, scope=portType, documentation='Defines a port that implements or uses a service that can be implemented with functions or methods.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 82, 4)))

portType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'access'), portAccessType_, scope=portType, documentation='Port access characteristics.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 89, 3)))

portType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'arrays'), configurableArrays, scope=portType, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 567, 1)))

def _BuildAutomaton_166 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_166
    del _BuildAutomaton_166
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 367, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 368, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 72, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 88, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 89, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 94, 3))
    counters.add(cc_5)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(portType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 362, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(portType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 367, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(portType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 368, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(portType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 72, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(portType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'wire')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 77, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(portType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'transactional')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 82, 4))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(portType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'arrays')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 88, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(portType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'access')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 89, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(portType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 94, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
portType._Automaton = _BuildAutomaton_166()




CTD_ANON_142._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'protocolType'), CTD_ANON_194, scope=CTD_ANON_142, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 163, 4)))

CTD_ANON_142._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'payload'), CTD_ANON_143, scope=CTD_ANON_142, documentation='defines the structure of data transported by this port', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 214, 1)))

def _BuildAutomaton_167 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_167
    del _BuildAutomaton_167
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 172, 4))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_142._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'protocolType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 163, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_142._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'payload')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 172, 4))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_142._Automaton = _BuildAutomaton_167()




CTD_ANON_143._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_143, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_143._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.string, scope=CTD_ANON_143, documentation='Defines the name of the payload. For example: TLM2 or TLM1', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 220, 4)))

CTD_ANON_143._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'type'), STD_ANON_11, scope=CTD_ANON_143, documentation='Defines the type of the payload. ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 225, 4)))

CTD_ANON_143._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'extension'), CTD_ANON_144, scope=CTD_ANON_143, documentation='Defines the name of the payload extension. If attribute is not specified, it is by default optional.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 236, 4)))

def _BuildAutomaton_168 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_168
    del _BuildAutomaton_168
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 220, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 236, 4))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 252, 4))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_143._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 220, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_143._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'type')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 225, 4))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_143._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'extension')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 236, 4))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_143._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 252, 4))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_143._Automaton = _BuildAutomaton_168()




CTD_ANON_145._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeParameter'), moduleParameterType, scope=CTD_ANON_145, documentation='A typed parameter name value pair. The optional attribute dataType defines the type of the value and the usageType attribute indicates how the parameter is to be used.\n\t\t\t', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 267, 1)))

CTD_ANON_145._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'serviceTypeDef'), CTD_ANON_150, scope=CTD_ANON_145, documentation='Definition of a single service type defintion', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 324, 1)))

def _BuildAutomaton_169 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_169
    del _BuildAutomaton_169
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 262, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 263, 4))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_145._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'typeParameter')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 262, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_145._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'serviceTypeDef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 263, 4))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_145._Automaton = _BuildAutomaton_169()




CTD_ANON_146._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeParameters'), CTD_ANON_145, scope=CTD_ANON_146, documentation='list of port type parameters (e.g. template or constructor parameters for a systemC port or socket)', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 256, 1)))

CTD_ANON_146._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeName'), CTD_ANON_147, scope=CTD_ANON_146, documentation='The name of the port type. Can be any predefined type such sc_port or sc_export in SystemC or any user-defined type such as tlm_port.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 279, 4)))

CTD_ANON_146._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeDefinition'), CTD_ANON_148, scope=CTD_ANON_146, documentation='Where the definition of the type is contained. For SystemC and SystemVerilog it is the include file containing the type definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 295, 4)))

CTD_ANON_146._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), CTD_ANON_149, scope=CTD_ANON_146, documentation='A reference to a view name in the file for which this type applies.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 308, 4)))

def _BuildAutomaton_170 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_170
    del _BuildAutomaton_170
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 279, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 295, 4))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 307, 4))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 308, 4))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_146._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'typeName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 279, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_146._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'typeDefinition')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 295, 4))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_146._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'typeParameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 307, 4))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_146._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'viewRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 308, 4))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_146._Automaton = _BuildAutomaton_170()




CTD_ANON_150._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeParameters'), CTD_ANON_145, scope=CTD_ANON_150, documentation='list of port type parameters (e.g. template or constructor parameters for a systemC port or socket)', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 256, 1)))

CTD_ANON_150._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeName'), CTD_ANON_151, scope=CTD_ANON_150, documentation='The name of the service type. Can be any predefined type such as booean or integer or any user-defined type such as addr_type or data_type.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 330, 4)))

CTD_ANON_150._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeDefinition'), CTD_ANON_152, scope=CTD_ANON_150, documentation='Where the definition of the type is contained if the type if not part of the language. For SystemC and SystemVerilog it is the include file containing the type definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 347, 4)))

def _BuildAutomaton_171 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_171
    del _BuildAutomaton_171
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 347, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 359, 4))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_150._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'typeName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 330, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_150._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'typeDefinition')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 347, 4))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_150._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'typeParameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 359, 4))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_150._Automaton = _BuildAutomaton_171()




CTD_ANON_153._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeName'), CTD_ANON_154, scope=CTD_ANON_153, documentation='The name of the logic type. Examples could be std_logic, std_ulogic, std_logic_vector, sc_logic, ...', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 370, 4)))

CTD_ANON_153._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'typeDefinition'), CTD_ANON_155, scope=CTD_ANON_153, documentation='Where the definition of the type is contained. For std_logic, this is contained in IEEE.std_logic_1164.all. For sc_logic, this is contained in systemc.h. For VHDL this is the library and package as defined by the "used" statement. For SystemC and SystemVerilog it is the include file required. For verilog this is not needed.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 386, 4)))

CTD_ANON_153._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'viewRef'), CTD_ANON_156, scope=CTD_ANON_153, documentation='A reference to a view name in the file for which this type applies.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 398, 4)))

def _BuildAutomaton_172 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_172
    del _BuildAutomaton_172
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 370, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 386, 4))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 398, 4))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_153._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'typeName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 370, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_153._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'typeDefinition')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 386, 4))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_153._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'viewRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 398, 4))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_153._Automaton = _BuildAutomaton_172()




CTD_ANON_157._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'serviceTypeDef'), CTD_ANON_150, scope=CTD_ANON_157, documentation='Definition of a single service type defintion', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 324, 1)))

def _BuildAutomaton_173 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_173
    del _BuildAutomaton_173
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_157._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'serviceTypeDef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 420, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_157._Automaton = _BuildAutomaton_173()




CTD_ANON_158._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'wireTypeDef'), CTD_ANON_153, scope=CTD_ANON_158, documentation='Definition of a single wire type defintion that can relate to multiple views.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 364, 1)))

def _BuildAutomaton_174 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_174
    del _BuildAutomaton_174
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_158._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'wireTypeDef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 430, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_158._Automaton = _BuildAutomaton_174()




CTD_ANON_159._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'transTypeDef'), CTD_ANON_146, scope=CTD_ANON_159, documentation='Definition of a single transactional type defintion', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 273, 1)))

def _BuildAutomaton_175 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_175
    del _BuildAutomaton_175
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_159._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'transTypeDef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 444, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_159._Automaton = _BuildAutomaton_175()




portWireType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vectors'), CTD_ANON_60, scope=portWireType, documentation='Vectored information.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 539, 1)))

portWireType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'constraintSets'), CTD_ANON_73, scope=portWireType, documentation='List of constraintSet elements for a component port.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 259, 4)))

portWireType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'wireTypeDefs'), CTD_ANON_158, scope=portWireType, documentation='The group of wire type definitions. If no match to a viewName is found then the default language types are to be used. See the User Guide for these default types.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 424, 1)))

portWireType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'direction'), componentPortDirectionType, scope=portWireType, documentation="The direction of a wire style port. The basic directions for a port are 'in' for input ports, 'out' for output port and 'inout' for bidirectional and tristate ports. \nA value of 'phantom' is also allowed and define a port that exist on the IP-XACT component but not on the HDL model.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 462, 3)))

portWireType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'drivers'), CTD_ANON_163, scope=portWireType, documentation='Container for wire port driver elements.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 135, 1)))

def _BuildAutomaton_176 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_176
    del _BuildAutomaton_176
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 468, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 469, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 470, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 471, 3))
    counters.add(cc_3)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(portWireType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'direction')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 462, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(portWireType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vectors')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 468, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(portWireType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'wireTypeDefs')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 469, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(portWireType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'drivers')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 470, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(portWireType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'constraintSets')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 471, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
portWireType._Automaton = _BuildAutomaton_176()




portTransactionalType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'initiative'), initiativeType, scope=portTransactionalType, documentation='If this element is present, the type of access is restricted to the specified value.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 147, 1)))

portTransactionalType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'busWidth'), unsignedIntExpression, scope=portTransactionalType, documentation='defines the bus size in bits. This can be the result of an expression.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 152, 1)))

portTransactionalType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'protocol'), CTD_ANON_142, scope=portTransactionalType, documentation='defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 157, 1)))

portTransactionalType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'kind'), CTD_ANON_195, scope=portTransactionalType, documentation='Defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 191, 1)))

portTransactionalType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'transTypeDefs'), CTD_ANON_159, scope=portTransactionalType, documentation='The group of transactional type definitions. If no match to a viewName is found then the default language types are to be used. See the User Guide for these default types.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 438, 1)))

portTransactionalType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'connection'), CTD_ANON_160, scope=portTransactionalType, documentation='Bounds number of legal connections.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 509, 3)))

def _BuildAutomaton_177 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_177
    del _BuildAutomaton_177
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 489, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 494, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 499, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 504, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 509, 3))
    counters.add(cc_4)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(portTransactionalType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'initiative')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 484, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(portTransactionalType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'kind')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 489, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(portTransactionalType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'busWidth')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 494, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(portTransactionalType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'protocol')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 499, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(portTransactionalType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'transTypeDefs')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 504, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(portTransactionalType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'connection')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 509, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
portTransactionalType._Automaton = _BuildAutomaton_177()




CTD_ANON_160._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'maxConnections'), unsignedIntExpression, scope=CTD_ANON_160, documentation='Indicates the maximum number of connections this port supports. If this element is not present or set to 0 it implies an unbounded number of allowed connections.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 515, 6), unicode_default='0'))

CTD_ANON_160._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'minConnections'), unsignedIntExpression, scope=CTD_ANON_160, documentation='Indicates the minimum number of connections this port supports. If this element is not present, the minimum number of allowed connections is 1.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 520, 6), unicode_default='1'))

def _BuildAutomaton_178 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_178
    del _BuildAutomaton_178
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 515, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 520, 6))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_160._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'maxConnections')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 515, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_160._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'minConnections')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 520, 6))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_160._Automaton = _BuildAutomaton_178()




portAccessType_._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'portAccessType'), simplePortAccessType, scope=portAccessType_, documentation="Indicates how a netlister accesses a port. 'ref' means accessed by reference (default) and 'ptr' means accessed by pointer.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 209, 1)))

portAccessType_._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), CTD_ANON_161, scope=portAccessType_, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 558, 3)))

def _BuildAutomaton_179 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_179
    del _BuildAutomaton_179
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 553, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 558, 3))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(portAccessType_._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'portAccessType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 553, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(portAccessType_._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandles')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 558, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
portAccessType_._Automaton = _BuildAutomaton_179()




CTD_ANON_161._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandle'), leafAccessHandle, scope=CTD_ANON_161, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 561, 6)))

def _BuildAutomaton_180 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_180
    del _BuildAutomaton_180
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_161._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandle')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 561, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_161._Automaton = _BuildAutomaton_180()




CTD_ANON_162._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'singleShotOffset'), realExpression, scope=CTD_ANON_162, documentation='Time in nanoseconds until start of one-shot.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 81, 4)))

CTD_ANON_162._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'singleShotValue'), unsignedBitVectorExpression, scope=CTD_ANON_162, documentation='Value of port after first  edge of one-shot.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 86, 4)))

CTD_ANON_162._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'singleShotDuration'), realExpression, scope=CTD_ANON_162, documentation='Duration in nanoseconds of the one shot.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 91, 4)))

def _BuildAutomaton_181 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_181
    del _BuildAutomaton_181
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_162._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'singleShotOffset')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 81, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_162._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'singleShotValue')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 86, 4))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_162._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'singleShotDuration')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 91, 4))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_162._Automaton = _BuildAutomaton_181()




driverType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'range'), CTD_ANON_61, scope=driverType, documentation='Left and right bound of a reference into a vector.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 549, 1)))

driverType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'defaultValue'), unsignedBitVectorExpression, scope=driverType, documentation='Default value for a wire port.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 54, 1)))

driverType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'clockDriver'), CTD_ANON_196, scope=driverType, documentation='Describes a driven clock port. ', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 59, 1)))

driverType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'singleShotDriver'), CTD_ANON_162, scope=driverType, documentation='Describes a driven one-shot port.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 75, 1)))

def _BuildAutomaton_182 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_182
    del _BuildAutomaton_182
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 126, 2))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 127, 3))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(driverType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'range')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 127, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(driverType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'defaultValue')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 129, 4))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(driverType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'clockDriver')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 130, 4))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(driverType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'singleShotDriver')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 131, 4))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
driverType._Automaton = _BuildAutomaton_182()




CTD_ANON_163._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'driver'), driverType, scope=CTD_ANON_163, documentation='Wire port driver element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 149, 1)))

def _BuildAutomaton_183 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_183
    del _BuildAutomaton_183
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_163._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'driver')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 141, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_163._Automaton = _BuildAutomaton_183()




clockDriverType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'clockPeriod'), CTD_ANON_210, scope=clockDriverType, documentation='Clock period in units defined by the units attribute. Default is nanoseconds.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 171, 3)))

clockDriverType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'clockPulseOffset'), CTD_ANON_211, scope=clockDriverType, documentation='Time until first pulse. Units are defined by the units attribute. Default is nanoseconds.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 183, 3)))

clockDriverType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'clockPulseValue'), unsignedBitVectorExpression, scope=clockDriverType, documentation='Value of port after first clock edge.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 195, 3)))

clockDriverType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'clockPulseDuration'), CTD_ANON_212, scope=clockDriverType, documentation='Duration of first state in cycle. Units are defined by the units attribute. Default is nanoseconds.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 200, 3)))

def _BuildAutomaton_184 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_184
    del _BuildAutomaton_184
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(clockDriverType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'clockPeriod')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 171, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(clockDriverType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'clockPulseOffset')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 183, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(clockDriverType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'clockPulseValue')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 195, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(clockDriverType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'clockPulseDuration')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 200, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
clockDriverType._Automaton = _BuildAutomaton_184()




CTD_ANON_164._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'configurableElementValue'), CTD_ANON_204, scope=CTD_ANON_164, documentation='Describes the content of a configurable element. The required referenceId attribute refers to the ID attribute of the configurable element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 106, 1)))

def _BuildAutomaton_185 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_185
    del _BuildAutomaton_185
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_164._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'configurableElementValue')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 98, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_164._Automaton = _BuildAutomaton_185()




CTD_ANON_165._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_165, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_165._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_165, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_165._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_165, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_165._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_165, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_165._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'instanceName'), pyxb.binding.datatypes.Name, scope=CTD_ANON_165, documentation='An instance name assigned to subcomponent instances and contained channels, that is unique within the parent component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 123, 1)))

CTD_ANON_165._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'componentRef'), configurableLibraryRefType, scope=CTD_ANON_165, documentation='References a component to be found in an external library.  The four attributes define the VLNV of the referenced element.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 138, 4)))

def _BuildAutomaton_186 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_186
    del _BuildAutomaton_186
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 135, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 136, 4))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 137, 4))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 143, 4))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_165._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'instanceName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 134, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_165._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 135, 4))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_165._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 136, 4))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_165._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 137, 4))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_165._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'componentRef')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 138, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_165._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 143, 4))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_165._Automaton = _BuildAutomaton_186()




CTD_ANON_166._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'componentInstance'), CTD_ANON_165, scope=CTD_ANON_166, documentation='Component instance element.  The instance name is contained in the unique-value instanceName attribute.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 128, 1)))

def _BuildAutomaton_187 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_187
    del _BuildAutomaton_187
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_166._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'componentInstance')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 154, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_166._Automaton = _BuildAutomaton_187()




CTD_ANON_167._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_167, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_167._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), portName, scope=CTD_ANON_167, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 362, 3)))

CTD_ANON_167._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_167, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_167._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_167, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_167._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_167, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_167._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'tiedValue'), complexTiedValueType, scope=CTD_ANON_167, documentation='The logic value of this connection. The value can be an unsigned longint expression or open or default. Only valid for ports of style wire.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 166, 4)))

CTD_ANON_167._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'portReferences'), CTD_ANON_168, scope=CTD_ANON_167, documentation='Liist of internal and external port references involved in the adhocConnection', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 171, 4)))

def _BuildAutomaton_188 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_188
    del _BuildAutomaton_188
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 367, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 368, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 165, 4))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 166, 4))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 206, 4))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_167._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 362, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_167._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 367, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_167._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 368, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_167._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 165, 4))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_167._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'tiedValue')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 166, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_167._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'portReferences')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 171, 4))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_167._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 206, 4))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_167._Automaton = _BuildAutomaton_188()




CTD_ANON_168._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'internalPortReference'), CTD_ANON_199, scope=CTD_ANON_168, documentation='Defines a reference to a port on a component contained within the design.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 178, 8)))

CTD_ANON_168._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'externalPortReference'), CTD_ANON_200, scope=CTD_ANON_168, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 359, 1)))

def _BuildAutomaton_189 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_189
    del _BuildAutomaton_189
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 200, 8))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_168._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'internalPortReference')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 178, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_168._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'externalPortReference')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 200, 8))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_168._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'externalPortReference')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 202, 7))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_168._Automaton = _BuildAutomaton_189()




CTD_ANON_169._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'adHocConnection'), CTD_ANON_167, scope=CTD_ANON_169, documentation='Represents an ad-hoc connection between component ports.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 158, 1)))

def _BuildAutomaton_190 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_190
    del _BuildAutomaton_190
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_169._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'adHocConnection')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 217, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_169._Automaton = _BuildAutomaton_190()




CTD_ANON_170._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_170, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_170._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_170, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

CTD_ANON_170._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_170, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_170._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_170, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_170._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_170, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_170._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'hierInterface'), hierInterfaceType, scope=CTD_ANON_170, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 239, 6)))

CTD_ANON_170._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'activeInterface'), CTD_ANON_201, scope=CTD_ANON_170, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 373, 1)))

def _BuildAutomaton_191 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_191
    del _BuildAutomaton_191
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 228, 4))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 239, 6))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 243, 4))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 228, 4))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'activeInterface')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 229, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'activeInterface')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 238, 6))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'hierInterface')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 239, 6))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'hierInterface')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 241, 5))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 243, 4))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_170._Automaton = _BuildAutomaton_191()




CTD_ANON_171._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_171, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

CTD_ANON_171._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_171, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_171._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_171, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_171._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_171, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_171._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'monitoredActiveInterface'), monitorInterfaceType, scope=CTD_ANON_171, documentation='Describes an active interface of the design that all the monitors will be connected to.\n\nThe componentRef and busRef attributes indicate the instance name and bus interface name. The optional path attribute indicates the hierarchical instance name path to the component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 272, 4)))

CTD_ANON_171._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'monitorInterface'), CTD_ANON_205, scope=CTD_ANON_171, documentation='Describes a list of monitor interfaces that are connected to the single active interface.\n\nThe componentRef and busRef attributes indicate the instance name and bus interface name. The optional path attribute indicates the hierarchical instance name path to the component.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 279, 4)))

def _BuildAutomaton_192 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_192
    del _BuildAutomaton_192
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 271, 4))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_171._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_171._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_171._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_171._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 271, 4))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_171._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'monitoredActiveInterface')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 272, 4))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_171._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'monitorInterface')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 279, 4))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_171._Automaton = _BuildAutomaton_192()




CTD_ANON_172._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'interconnection'), CTD_ANON_170, scope=CTD_ANON_172, documentation='Describes a connection between two active (not monitor) busInterfaces.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 221, 1)))

CTD_ANON_172._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'monitorInterconnection'), CTD_ANON_171, scope=CTD_ANON_172, documentation='Describes a connection from the interface of one component to any number of monitor interfaces in the design.\n\nAn active interface can be connected to unlimited number of monitor interfaces.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 262, 1)))

def _BuildAutomaton_193 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_193
    del _BuildAutomaton_193
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 303, 3))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_172._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'interconnection')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 304, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_172._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'monitorInterconnection')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 305, 4))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_172._Automaton = _BuildAutomaton_193()




hierInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=hierInterfaceType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

hierInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=hierInterfaceType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

hierInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=hierInterfaceType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

def _BuildAutomaton_194 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_194
    del _BuildAutomaton_194
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 330, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 331, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 332, 3))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(hierInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 330, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(hierInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 331, 3))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(hierInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 332, 3))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
hierInterfaceType._Automaton = _BuildAutomaton_194()




CTD_ANON_173._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'excludePort'), CTD_ANON_202, scope=CTD_ANON_173, documentation='The name of a physical port to be excluded from the interface based connection.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 386, 9)))

def _BuildAutomaton_195 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_195
    del _BuildAutomaton_195
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_173._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'excludePort')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 386, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_173._Automaton = _BuildAutomaton_195()




CTD_ANON_175._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'portIndex'), unsignedIntExpression, scope=CTD_ANON_175, documentation='Index for a vectored type port. Must be a number between left and right for the port.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 233, 13)))

CTD_ANON_175._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'value'), unsignedIntExpression, scope=CTD_ANON_175, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 238, 13)))

def _BuildAutomaton_196 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_196
    del _BuildAutomaton_196
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 233, 13))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_175._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'portIndex')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 233, 13))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_175._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'value')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 238, 13))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_175._Automaton = _BuildAutomaton_196()




CTD_ANON_176._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'baseAddress'), signedLongintExpression, scope=CTD_ANON_176, documentation='Base of an address space.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 278, 11)))

def _BuildAutomaton_197 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_197
    del _BuildAutomaton_197
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 271, 7))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 177, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 278, 11))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_176._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 177, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_176._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'baseAddress')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 278, 11))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_176._Automaton = _BuildAutomaton_197()




CTD_ANON_177._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'group'), pyxb.binding.datatypes.Name, scope=CTD_ANON_177, documentation='Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 166, 1)))

def _BuildAutomaton_198 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_198
    del _BuildAutomaton_198
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 394, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_177._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'group')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/busInterface.xsd', 394, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_177._Automaton = _BuildAutomaton_198()




parameterBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=parameterBaseType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

parameterBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'arrays'), configurableArrays, scope=parameterBaseType, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 378, 3)))

parameterBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'value'), complexBaseExpression, scope=parameterBaseType, documentation='The value of the parameter.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 379, 3)))

parameterBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vectors'), CTD_ANON_60, scope=parameterBaseType, documentation='Vectored information.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 539, 1)))

parameterBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.string, scope=parameterBaseType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 600, 3)))

parameterBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=parameterBaseType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

parameterBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=parameterBaseType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

def _BuildAutomaton_199 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_199
    del _BuildAutomaton_199
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 605, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 606, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 377, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 378, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 384, 3))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(parameterBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 600, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(parameterBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 605, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(parameterBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 606, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(parameterBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vectors')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 377, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(parameterBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'arrays')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 378, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(parameterBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'value')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 379, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(parameterBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 384, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
parameterBaseType._Automaton = _BuildAutomaton_199()




CTD_ANON_178._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'cellFunction'), CTD_ANON_179, scope=CTD_ANON_178, documentation='Defines a technology library cell in library independent fashion, based on specification of a cell function and strength.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 144, 16)))

CTD_ANON_178._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'cellClass'), cellClassValueType, scope=CTD_ANON_178, documentation='Defines a technology library cell in library independent fashion, based on specification of a cell class and strength.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 156, 16)))

def _BuildAutomaton_200 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_200
    del _BuildAutomaton_200
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_178._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'cellFunction')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 144, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_178._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'cellClass')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/constraints.xsd', 156, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_178._Automaton = _BuildAutomaton_200()




def _BuildAutomaton_201 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_201
    del _BuildAutomaton_201
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 605, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 606, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 524, 3))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_182._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 600, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_182._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 605, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_182._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 606, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_182._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'value')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 523, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_182._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 524, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_182._Automaton = _BuildAutomaton_201()




def _BuildAutomaton_202 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_202
    del _BuildAutomaton_202
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 248, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 249, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 250, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 262, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 286, 3))
    counters.add(cc_6)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_184._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_184._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_184._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_184._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'phase')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 248, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_184._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 249, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_184._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'apiType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 250, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_184._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'transportMethods')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 262, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_184._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'generatorExe')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 281, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_184._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 286, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_184._Automaton = _BuildAutomaton_202()




CTD_ANON_185._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), CTD_ANON_103, scope=CTD_ANON_185, documentation='Specifies a generator group name or a generator chain group name to be selected for inclusion in the generator chain.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 140, 4)))

def _BuildAutomaton_203 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_203
    del _BuildAutomaton_203
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_185._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 140, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_185._Automaton = _BuildAutomaton_203()




instanceGeneratorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'group'), CTD_ANON_104, scope=instanceGeneratorType, documentation='An identifier to specify the generator group. This is used by generator chains for selecting which generators to run.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 176, 5)))

def _BuildAutomaton_204 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_204
    del _BuildAutomaton_204
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 248, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 249, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 250, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 262, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 286, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 176, 5))
    counters.add(cc_7)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(instanceGeneratorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(instanceGeneratorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(instanceGeneratorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(instanceGeneratorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'phase')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 248, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(instanceGeneratorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 249, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(instanceGeneratorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'apiType')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 250, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(instanceGeneratorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'transportMethods')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 262, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(instanceGeneratorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'generatorExe')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 281, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(instanceGeneratorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 286, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(instanceGeneratorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'group')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/generator.xsd', 176, 5))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, True) ]))
    st_9._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
instanceGeneratorType._Automaton = _BuildAutomaton_204()




addressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=addressBankType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

addressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=addressBankType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

addressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=addressBankType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

addressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=addressBankType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

addressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=addressBankType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

addressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=addressBankType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

addressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), CTD_ANON_108, scope=addressBankType, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 112, 3)))

addressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'volatile'), pyxb.binding.datatypes.boolean, scope=addressBankType, documentation='Indicates whether the data is volatile.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), unicode_default='false'))

addressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'access'), accessType, scope=addressBankType, documentation="Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1)))

addressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'baseAddress'), unsignedLongintExpression, scope=addressBankType, documentation='Base of an address block, bank, subspace map or address space. Expressed as the number of addressable units from the containing memoryMap or localMemoryMap.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 558, 1)))

addressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), bankedBlockType, scope=addressBankType, documentation='An address block within the bank.  No address information is supplied.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 594, 4)))

addressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'bank'), bankedBankType, scope=addressBankType, documentation='A nested bank of blocks within a bank.  No address information is supplied.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 603, 4)))

addressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'subspaceMap'), bankedSubspaceType, scope=addressBankType, documentation='A subspace map within the bank.  No address information is supplied.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 612, 4)))

addressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'usage'), usageType, scope=addressBankType, documentation="Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3)))

def _BuildAutomaton_205 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_205
    del _BuildAutomaton_205
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 112, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 592, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 689, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 690, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 691, 3))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 619, 3))
    counters.add(cc_8)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(addressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(addressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(addressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(addressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandles')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 112, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(addressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'baseAddress')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 584, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(addressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 592, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(addressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressBlock')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 594, 4))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(addressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'bank')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 603, 4))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(addressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'subspaceMap')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 612, 4))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(addressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'usage')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(addressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'volatile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 689, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(addressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'access')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 690, 3))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(addressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 691, 3))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(addressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 619, 3))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, True) ]))
    st_13._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
addressBankType._Automaton = _BuildAutomaton_205()




localAddressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=localAddressBankType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

localAddressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=localAddressBankType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

localAddressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=localAddressBankType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

localAddressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=localAddressBankType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

localAddressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=localAddressBankType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

localAddressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=localAddressBankType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

localAddressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), CTD_ANON_109, scope=localAddressBankType, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 135, 3)))

localAddressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'volatile'), pyxb.binding.datatypes.boolean, scope=localAddressBankType, documentation='Indicates whether the data is volatile.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), unicode_default='false'))

localAddressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'access'), accessType, scope=localAddressBankType, documentation="Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1)))

localAddressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'baseAddress'), unsignedLongintExpression, scope=localAddressBankType, documentation='Base of an address block, bank, subspace map or address space. Expressed as the number of addressable units from the containing memoryMap or localMemoryMap.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 558, 1)))

localAddressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), bankedBlockType, scope=localAddressBankType, documentation='An address block within the bank.  No address information is supplied.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 629, 4)))

localAddressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'bank'), localBankedBankType, scope=localAddressBankType, documentation='A nested bank of blocks within a bank.  No address information is supplied.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 638, 4)))

localAddressBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'usage'), usageType, scope=localAddressBankType, documentation="Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3)))

def _BuildAutomaton_206 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_206
    del _BuildAutomaton_206
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 135, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 627, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 689, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 690, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 691, 3))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 649, 3))
    counters.add(cc_8)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(localAddressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(localAddressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(localAddressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(localAddressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandles')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 135, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(localAddressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'baseAddress')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 584, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(localAddressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 627, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(localAddressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressBlock')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 629, 4))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(localAddressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'bank')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 638, 4))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(localAddressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'usage')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(localAddressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'volatile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 689, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(localAddressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'access')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 690, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(localAddressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 691, 3))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(localAddressBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 649, 3))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, True) ]))
    st_12._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
localAddressBankType._Automaton = _BuildAutomaton_206()




bankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=bankedBankType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

bankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=bankedBankType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

bankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=bankedBankType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

bankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=bankedBankType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

bankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=bankedBankType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

bankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=bankedBankType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

bankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), CTD_ANON_111, scope=bankedBankType, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 202, 3)))

bankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'volatile'), pyxb.binding.datatypes.boolean, scope=bankedBankType, documentation='Indicates whether the data is volatile.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), unicode_default='false'))

bankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'access'), accessType, scope=bankedBankType, documentation="Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1)))

bankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), bankedBlockType, scope=bankedBankType, documentation='An address block within the bank.  No address information is supplied.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 594, 4)))

bankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'bank'), bankedBankType, scope=bankedBankType, documentation='A nested bank of blocks within a bank.  No address information is supplied.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 603, 4)))

bankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'subspaceMap'), bankedSubspaceType, scope=bankedBankType, documentation='A subspace map within the bank.  No address information is supplied.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 612, 4)))

bankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'usage'), usageType, scope=bankedBankType, documentation="Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3)))

def _BuildAutomaton_207 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_207
    del _BuildAutomaton_207
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 202, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 592, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 689, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 690, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 691, 3))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 619, 3))
    counters.add(cc_8)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(bankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(bankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(bankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(bankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandles')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 202, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(bankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 592, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(bankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressBlock')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 594, 4))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(bankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'bank')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 603, 4))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(bankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'subspaceMap')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 612, 4))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(bankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'usage')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(bankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'volatile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 689, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(bankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'access')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 690, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(bankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 691, 3))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(bankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 619, 3))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, True) ]))
    st_12._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
bankedBankType._Automaton = _BuildAutomaton_207()




localBankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'parameters'), CTD_ANON_48, scope=localBankedBankType, documentation='A collection of parameters and associated value assertions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 108, 1)))

localBankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=localBankedBankType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

localBankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=localBankedBankType, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

localBankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=localBankedBankType, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

localBankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=localBankedBankType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

localBankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=localBankedBankType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

localBankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'accessHandles'), CTD_ANON_112, scope=localBankedBankType, location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 220, 3)))

localBankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'volatile'), pyxb.binding.datatypes.boolean, scope=localBankedBankType, documentation='Indicates whether the data is volatile.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 422, 1), unicode_default='false'))

localBankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'access'), accessType, scope=localBankedBankType, documentation="Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 427, 1)))

localBankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'addressBlock'), bankedBlockType, scope=localBankedBankType, documentation='An address block within the bank.  No address information is supplied.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 629, 4)))

localBankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'bank'), localBankedBankType, scope=localBankedBankType, documentation='A nested bank of blocks within a bank.  No address information is supplied.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 638, 4)))

localBankedBankType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'usage'), usageType, scope=localBankedBankType, documentation="Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.", location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3)))

def _BuildAutomaton_208 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_208
    del _BuildAutomaton_208
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 220, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 627, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 689, 3))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 690, 3))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 691, 3))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 649, 3))
    counters.add(cc_8)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(localBankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(localBankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(localBankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(localBankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'accessHandles')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 220, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(localBankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 627, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(localBankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'addressBlock')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 629, 4))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(localBankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'bank')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 638, 4))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(localBankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'usage')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 684, 3))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(localBankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'volatile')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 689, 3))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(localBankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'access')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 690, 3))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(localBankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'parameters')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 691, 3))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(localBankedBankType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 649, 3))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, True) ]))
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
localBankedBankType._Automaton = _BuildAutomaton_208()




CTD_ANON_188._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_188, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_188._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'name'), pyxb.binding.datatypes.Name, scope=CTD_ANON_188, documentation='Unique name', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3)))

CTD_ANON_188._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'displayName'), pyxb.binding.datatypes.string, scope=CTD_ANON_188, documentation='Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 609, 1)))

CTD_ANON_188._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_188, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_188._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'value'), unsignedBitVectorExpression, scope=CTD_ANON_188, documentation='Enumerated bit field value.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 828, 7)))

def _BuildAutomaton_209 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_209
    del _BuildAutomaton_209
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 833, 7))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_188._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 137, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_188._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 142, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_188._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 143, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_188._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'value')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 828, 7))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_188._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/memoryMap.xsd', 833, 7))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_188._Automaton = _BuildAutomaton_209()




def _BuildAutomaton_210 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_210
    del _BuildAutomaton_210
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 367, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 368, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 107, 6))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 124, 7))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 132, 6))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(abstractorPortType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 362, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(abstractorPortType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 367, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(abstractorPortType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 368, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(abstractorPortType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 107, 6))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(abstractorPortType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'wire')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 112, 7))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(abstractorPortType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'transactional')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 117, 7))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(abstractorPortType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'access')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 124, 7))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(abstractorPortType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 132, 6))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
abstractorPortType._Automaton = _BuildAutomaton_210()




def _BuildAutomaton_211 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_211
    del _BuildAutomaton_211
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 544, 5))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 545, 5))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 546, 5))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(abstractorPortWireType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'direction')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 543, 5))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(abstractorPortWireType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vectors')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 544, 5))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(abstractorPortWireType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'wireTypeDefs')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 545, 5))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(abstractorPortWireType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'drivers')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/port.xsd', 546, 5))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
abstractorPortWireType._Automaton = _BuildAutomaton_211()




def _BuildAutomaton_212 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_212
    del _BuildAutomaton_212
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_196._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'clockPeriod')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 171, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_196._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'clockPulseOffset')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 183, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_196._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'clockPulseValue')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 195, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_196._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'clockPulseDuration')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 200, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_196._Automaton = _BuildAutomaton_212()




def _BuildAutomaton_213 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_213
    del _BuildAutomaton_213
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_198._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'clockPeriod')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 171, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_198._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'clockPulseOffset')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 183, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_198._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'clockPulseValue')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 195, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_198._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'clockPulseDuration')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/signalDrivers.xsd', 200, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_198._Automaton = _BuildAutomaton_213()




CTD_ANON_199._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'partSelect'), CTD_ANON_62, scope=CTD_ANON_199, documentation='Bit range definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 560, 1)))

CTD_ANON_199._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_199, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

def _BuildAutomaton_214 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_214
    del _BuildAutomaton_214
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 184, 11))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 185, 11))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_199._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 184, 11))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_199._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'partSelect')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 185, 11))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_199._Automaton = _BuildAutomaton_214()




monitorInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=monitorInterfaceType, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

monitorInterfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=monitorInterfaceType, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

def _BuildAutomaton_215 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_215
    del _BuildAutomaton_215
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 348, 5))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 349, 5))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(monitorInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 348, 5))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(monitorInterfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 349, 5))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
monitorInterfaceType._Automaton = _BuildAutomaton_215()




CTD_ANON_200._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'partSelect'), CTD_ANON_62, scope=CTD_ANON_200, documentation='Bit range definition.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 560, 1)))

CTD_ANON_200._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_200, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

def _BuildAutomaton_216 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_216
    del _BuildAutomaton_216
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 362, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 363, 4))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_200._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 362, 4))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_200._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'partSelect')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 363, 4))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_200._Automaton = _BuildAutomaton_216()




CTD_ANON_201._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions'), CTD_ANON_49, scope=CTD_ANON_201, documentation='Container for vendor specific extensions.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 118, 1)))

CTD_ANON_201._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'description'), pyxb.binding.datatypes.string, scope=CTD_ANON_201, documentation='Full description string, typically for documentation', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 614, 1)))

CTD_ANON_201._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_201, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

CTD_ANON_201._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'excludePorts'), CTD_ANON_173, scope=CTD_ANON_201, documentation='The list of physical ports to be excluded from an interface based connection. Analogous to the removing the port map element for the named ports.', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 380, 6)))

def _BuildAutomaton_217 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_217
    del _BuildAutomaton_217
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 378, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 379, 6))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 380, 6))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 401, 6))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_201._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 378, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_201._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 379, 6))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_201._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'excludePorts')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 380, 6))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_201._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 401, 6))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_201._Automaton = _BuildAutomaton_217()




def _BuildAutomaton_218 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_218
    del _BuildAutomaton_218
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 605, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 606, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 377, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 378, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 384, 3))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(parameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 600, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(parameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 605, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(parameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 606, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(parameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vectors')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 377, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(parameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'arrays')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 378, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(parameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'value')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 379, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(parameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 384, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
parameterType._Automaton = _BuildAutomaton_218()




CTD_ANON_205._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=CTD_ANON_205, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

def _BuildAutomaton_219 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_219
    del _BuildAutomaton_219
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 348, 5))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 349, 5))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 289, 9))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_205._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 348, 5))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_205._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 349, 5))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_205._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/subInstances.xsd', 289, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_205._Automaton = _BuildAutomaton_219()




moduleParameterType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'isPresent'), unsignedBitExpression, scope=moduleParameterType, documentation='Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")', location=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 619, 1)))

def _BuildAutomaton_220 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_220
    del _BuildAutomaton_220
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 605, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 606, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 377, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 378, 3))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 384, 3))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 60, 5))
    counters.add(cc_5)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(moduleParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'name')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 600, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(moduleParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'displayName')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 605, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(moduleParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'description')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 606, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(moduleParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vectors')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 377, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(moduleParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'arrays')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 378, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(moduleParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'value')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 379, 3))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(moduleParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'vendorExtensions')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 384, 3))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(moduleParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'isPresent')), pyxb.utils.utility.Location('http://accellera.org/images/xmlschema/ipxact/1685-2014/commonStructures.xsd', 60, 5))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
moduleParameterType._Automaton = _BuildAutomaton_220()

